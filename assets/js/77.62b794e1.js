(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{113:function(t,s,a){"use strict";a.r(s);var e=a(0),_=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#写在前面"}},[t._v("写在前面")]),a("ul",[a("li",[a("a",{attrs:{href:"#rip-relative-寻址"}},[t._v("RIP-relative 寻址")])]),a("li",[a("a",{attrs:{href:"#间接寻址"}},[t._v("间接寻址")])]),a("li",[a("a",{attrs:{href:"#几个基本概念"}},[t._v("几个基本概念")])]),a("li",[a("a",{attrs:{href:"#引子"}},[t._v("引子")])])])]),a("li",[a("a",{attrs:{href:"#结构分析"}},[t._v("结构分析")]),a("ul",[a("li",[a("a",{attrs:{href:"#indirect-symbol-table"}},[t._v("Indirect Symbol Table")])]),a("li",[a("a",{attrs:{href:"#text-里的外部符号"}},[t._v("__text 里的外部符号")])]),a("li",[a("a",{attrs:{href:"#section-data-got"}},[t._v("section(_DATA _got)")])]),a("li",[a("a",{attrs:{href:"#section-text-stubs"}},[t._v("section(_TEXT _stubs)")])]),a("li",[a("a",{attrs:{href:"#section-data-la-symbol-ptr"}},[t._v("section(_DATA lasymbol_ptr)")])]),a("li",[a("a",{attrs:{href:"#section-text-stub-helper"}},[t._v("section(_TEXT stubhelper)")])]),a("li",[a("a",{attrs:{href:"#section-data-nl-symbol-ptr"}},[t._v("section(_DATA nlsymbol_ptr)")])]),a("li",[a("a",{attrs:{href:"#dyld-stub-binder"}},[t._v("dyldstubbinder")])]),a("li",[a("a",{attrs:{href:"#lazy-binding-分析"}},[t._v("Lazy Binding 分析")])])])]),a("li",[a("a",{attrs:{href:"#写在后面"}},[t._v("写在后面")])]),a("li",[a("a",{attrs:{href:"#更多阅读"}},[t._v("更多阅读")])])])]),a("p"),t._v(" "),a("h1",{attrs:{id:"写在前面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写在前面"}},[t._v("#")]),t._v(" 写在前面")]),t._v(" "),a("p",[a("router-link",{attrs:{to:"/post/macho-structure.html"}},[t._v("Mach-O 简单分析")]),t._v("描述了 Mach-O 文件的基本结构；"),a("router-link",{attrs:{to:"/post/macho-static-link.html"}},[t._v("Mach-O 与静态链接\n")]),t._v("概述了符号，分析了符号表（symbol table），这两篇算是本文的前置知识，本文旨在分析动态链接相关内容。")],1),t._v(" "),a("p",[t._v("关于动态链接，《深入理解计算机系统》和《程序员的自我修养》有着非常棒的分析，但这两本书都是站在 Linux 生态 ELF (Executable and Linkable Format) 的视角分析问题；本文借鉴这两本书，站在 Mach-O 的角度梳理我学习到的内容。")]),t._v(" "),a("p",[t._v("原本想在本文中将动态链接的方方面面的内容都装进去，慢慢发现这不是一个好主意。相较于静态链接，动态链接相关内容复杂得多，也更有意思一些，可以从各个视角去研究窥探；换句话说，随便挑一个切入点进行展开，都能完成一篇博客。")]),t._v(" "),a("p",[t._v("本文和"),a("router-link",{attrs:{to:"/post/macho-static-link.html"}},[t._v("Mach-O 与静态链接")]),t._v("类似，只是站在 Mach-O 视角，结合笔者自己的理解，将 Mach-O 本身与动态链接相关的结构给串起来，以期望对动态链接有一个基本的理解，重点仍然放在 Mach-O 文件本身上，基本上不涉及 xnu 和 dyld 的源码分析。")],1),t._v(" "),a("blockquote",[a("p",[t._v("分析 xnu 和 dyld 能帮助更全面准确地理解动态链接，但这不是本文的任务。")])]),t._v(" "),a("h2",{attrs:{id:"rip-relative-寻址"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rip-relative-寻址"}},[t._v("#")]),t._v(" RIP-relative 寻址")]),t._v(" "),a("p",[t._v("本文所在环境的系统架构是 x86-64，很多指令的寻址方式是 RIP-relative 寻址。虽然笔者汇编不甚熟悉，但是为了后续分析和阅读方便，还是得花些笔墨整理一下 RIP-relative 寻址相关内容。")]),t._v(" "),a("blockquote",[a("p",[t._v("RIP 的全拼是：Relative Instruction Pointer")])]),t._v(" "),a("p",[t._v("按照笔者的粗浅理解，基于 RIP 计算目标地址时，目标地址等于当前指令的下一条指令所在地址加上偏移量。简单来说，若看到如下二进制的反汇编内容：")]),t._v(" "),a("div",{staticClass:"language-asm6502 extra-class"},[a("pre",{pre:!0,attrs:{class:"language-asm6502"}},[a("code",[a("span",{pre:!0,attrs:{class:"token decimalnumber string"}},[t._v("0000000000001")]),t._v("fcd  jmpq  "),a("span",{pre:!0,attrs:{class:"token decimalnumber string"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token register variable"}},[t._v("x")]),a("span",{pre:!0,attrs:{class:"token decimalnumber string"}},[t._v("2")]),t._v("d(%rip)\n"),a("span",{pre:!0,attrs:{class:"token decimalnumber string"}},[t._v("0000000000001")]),t._v("fd"),a("span",{pre:!0,attrs:{class:"token decimalnumber string"}},[t._v("3")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token opcode property"}},[t._v("nop")]),t._v("\n")])])]),a("p",[t._v("则第一行代码 jmpq 的跳转目标地址是：0x1fd3 + 0x2d = 0x2000。")]),t._v(" "),a("p",[t._v("关于RIP-relative 的更加内容可参考：")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://blog.csdn.net/yeshahayes/article/details/51930610",target:"_blank",rel:"noopener noreferrer"}},[t._v("64位下的相对指令地址"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://xem.github.io/minix86/manual/intel-x86-and-64-manual-vol2/o_b5573232dd8f1481-72.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Intel x86-64 Manual Vol2"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"间接寻址"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#间接寻址"}},[t._v("#")]),t._v(" 间接寻址")]),t._v(" "),a("p",[t._v("除了 RIP-relative 寻址，也得提一下间接寻址。间接寻址是相对于直接寻址而言的，即目标地址并不是计算得到的地址值，而是该地址值存储的数据。")]),t._v(" "),a("p",[t._v("简单来说，如果看到如下二进制的反汇编内容：")]),t._v(" "),a("div",{staticClass:"language-asm6502 extra-class"},[a("pre",{pre:!0,attrs:{class:"language-asm6502"}},[a("code",[a("span",{pre:!0,attrs:{class:"token decimalnumber string"}},[t._v("0000000000001")]),t._v("fcd  jmpq  *"),a("span",{pre:!0,attrs:{class:"token decimalnumber string"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token register variable"}},[t._v("x")]),a("span",{pre:!0,attrs:{class:"token decimalnumber string"}},[t._v("2")]),t._v("d(%rip)\n"),a("span",{pre:!0,attrs:{class:"token decimalnumber string"}},[t._v("0000000000001")]),t._v("fd"),a("span",{pre:!0,attrs:{class:"token decimalnumber string"}},[t._v("3")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token opcode property"}},[t._v("nop")]),t._v("\n")])])]),a("blockquote",[a("p",[t._v("对于间接寻址，反汇编代码中，地址值前有一个"),a("code",[t._v("*")])])]),t._v(" "),a("p",[t._v("则第一行代码 jmpq 的跳转目标地址是 0x2000 (0x1fd3 + 0x2d) 里存储的内容，并非 0x2000 本身。")]),t._v(" "),a("h2",{attrs:{id:"几个基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#几个基本概念"}},[t._v("#")]),t._v(" 几个基本概念")]),t._v(" "),a("p",[t._v("在展开分析之前，先罗列本文高频出现的一些概念：")]),t._v(" "),a("ul",[a("li",[t._v("镜像：xnu、dyld 都将 Mach-O 文件看作镜像（image），本文所指的镜像即 Mach-O 文件")]),t._v(" "),a("li",[t._v("目标文件：即只编译未链接的可重定位文件")]),t._v(" "),a("li",[t._v("dylib：动态链接库，在 ELF 生态中，常被称作「共享对象」，或者「共享文件」，本文称作 dylib，或者 dylibs")]),t._v(" "),a("li",[t._v("dyld：dyld 是 Apple 生态操作系统（macOS、iOS）的动态链接器，本文直接使用 dyld 指代 Mach-O 的动态链接器")])]),t._v(" "),a("h2",{attrs:{id:"引子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引子"}},[t._v("#")]),t._v(" 引子")]),t._v(" "),a("p",[t._v("静态链接比较简单，原理上也容易理解，实践上却存在很多问题，典型问题有两点：")]),t._v(" "),a("ol",[a("li",[t._v("极大浪费磁盘和内存空间")]),t._v(" "),a("li",[t._v("给程序的更新、部署和发布带来很多麻烦")])]),t._v(" "),a("p",[t._v("稍微描述一下第二点。比如程序 Program1 所使用的 Lib.o 是由一个第三方厂商提供的，当该厂商更新了 Lib.o 的时候，那么 Program1 的开发者就要拿到最新版的 Lib.o，然后将其与 Program1.o 链接后，将新的 Program1 整个发布给用户。即一旦程序有任何模块的更新，整个程序就得重新链接、发布给用户。")]),t._v(" "),a("p",[t._v("动态链接是对这两个问题的解决方案。所谓动态链接，简单地讲，就是不对那些组成程序的目标文件进行链接，等到程序要运行时才进行链接。也就是说，把链接这个过程推迟到运行时再进行，这就是动态链接（Dynamic Linking）的基本思想。")]),t._v(" "),a("p",[t._v("动态链接的背景和基本思想理解起来蛮容易的，但实践中需要处理不少问题。本文以一个具体的 case 引出 Mach-O 动态链接中值得我们关心的问题。")]),t._v(" "),a("p",[t._v("首先，有一个文件 say.c：")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("kHelloPrefix "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hello"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("say")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("prefix"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%s, %s\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" prefix"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("该模块很简单，定义了两个符号：常量字符串"),a("code",[t._v("kHelloPrefix")]),t._v("，以及函数"),a("code",[t._v("say")]),t._v("。使用 gcc 把"),a("code",[t._v("say.c")]),t._v("编译成 dylib：")]),t._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("$ gcc -fPIC -shared say.c -o libsay.dylib\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 生成 libsay.dylib")]),t._v("\n")])])]),a("p",[t._v("再定义一个使用 say 模块的 main.c：")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("say")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("prefix"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extern")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("kHelloPrefix"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("say")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("kHelloPrefix"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Jack"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("把 main.c 编译成可重定位中间文件（只编译不链接）：")]),t._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("$ gcc -c main.c -o main.o\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 生成可重定位中间文件：main.o")]),t._v("\n")])])]),a("p",[t._v("此时的 main.o 是不可执行的，需要使用链接器 ld 将 sayHello 链接进来：")]),t._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("$ ld main.o -macosx_version_min "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10.14")]),t._v(" -o main.out -lSystem -L. -lsay\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# -macosx_version_min 用于指定最小系统版本，这是必须的")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# -lSystem 用于链接 libSystem.dylib")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# -lsay 用于链接 libsay.dylib")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# -L. 用于新增动态链接库搜索目录")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 生成可执行文件：main.out")]),t._v("\n")])])]),a("p",[t._v("这样就生成了可执行文件 main.out，执行该文件，打印「Hello, Jack」。此时若使用"),a("code",[t._v("xcrun dyldinfo -dylibs")]),t._v("查看 main.out 的依赖库，会发现有两个依赖库：")]),t._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("div",{staticClass:"highlight-lines"},[a("br"),a("br"),a("div",{staticClass:"highlighted"},[t._v(" ")]),a("div",{staticClass:"highlighted"},[t._v(" ")]),a("br")]),a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("$ xcrun dyldinfo -dylibs main.out\nattributes     dependent dylibs\n                /usr/lib/libSystem.B.dylib\n                libsay.dylib\n")])])]),a("p",[t._v("这两个动态库的依赖在 Mach-O 文件中对应两条 type 为"),a("code",[t._v("LC_LOAD_DYLIB")]),t._v("的 load commands，使用"),a("code",[t._v("otool -l")]),t._v("查看如下：")]),t._v(" "),a("div",{staticClass:"language-raw extra-class"},[a("div",{staticClass:"highlight-lines"},[a("br"),a("br"),a("br"),a("div",{staticClass:"highlighted"},[t._v(" ")]),a("br"),a("br"),a("br"),a("br"),a("br"),a("br"),a("br"),a("div",{staticClass:"highlighted"},[t._v(" ")]),a("br"),a("br"),a("br")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Load command 12\n          cmd LC_LOAD_DYLIB\n      cmdsize 56\n         name /usr/lib/libSystem.B.dylib (offset 24)\n   time stamp 2 Thu Jan  1 08:00:02 1970\n      current version 1252.200.5\ncompatibility version 1.0.0\n\nLoad command 13\n          cmd LC_LOAD_DYLIB\n      cmdsize 40\n         name libsay.dylib (offset 24)\n   time stamp 2 Thu Jan  1 08:00:02 1970\n      current version 0.0.0\n")])])]),a("blockquote",[a("p",[a("code",[t._v("LC_LOAD_DYLIB")]),t._v("命令的顺序和 ld 的链接顺序一致。")])]),t._v(" "),a("p",[a("code",[t._v("LC_LOAD_DYLIB")]),t._v("命令参数描述了 dylib 的基本信息，结构比较简单：")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("dylib")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("union")]),t._v(" lc_str  name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("             "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// dylib 的 path")]),t._v("\n    uint32_t timestamp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("             "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// dylib 构建的时间戳")]),t._v("\n    uint32_t current_version"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("       "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// dylib 的版本")]),t._v("\n    uint32_t compatibility_version"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// dylib 的兼容版本")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("无论是静态链接，还是动态链接，符号都是最重要的分析对象；来看看 main.out 的符号表（symbol table）：")]),t._v(" "),a("e-img",{attrs:{src:"/image/dynamic-main-symtab.png"}}),t._v(" "),a("p",[t._v("可以看到，symbol table 中有三个未绑定的外部符号："),a("code",[t._v("_kHelloPrefix")]),t._v("、"),a("code",[t._v("_say")]),t._v("、"),a("code",[t._v("dyld_stub_binder")]),t._v("；本文接下来对 Mach-O 文件结构的分析将围绕这 3 个符号进行展开。")]),t._v(" "),a("h1",{attrs:{id:"结构分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结构分析"}},[t._v("#")]),t._v(" 结构分析")]),t._v(" "),a("p",[t._v("先将 Mach-O 中与动态链接相关的结构给罗列出来：")]),t._v(" "),a("ul",[a("li",[t._v("Section\n"),a("ul",[a("li",[t._v("__TEXT __stubs")]),t._v(" "),a("li",[t._v("__TEXT __stub_helper")]),t._v(" "),a("li",[t._v("__DATA __nl_symbol_ptr")]),t._v(" "),a("li",[t._v("__DATA __got")]),t._v(" "),a("li",[t._v("__DATA __la_symbol_ptr")])])]),t._v(" "),a("li",[t._v("Load Command\n"),a("ul",[a("li",[t._v("LC_LOAD_DYLIB")]),t._v(" "),a("li",[t._v("LC_SYMTAB")]),t._v(" "),a("li",[t._v("LC_DYSYMTAB")])])]),t._v(" "),a("li",[t._v("Symbol Table")]),t._v(" "),a("li",[t._v("Indirect Symbol Table")]),t._v(" "),a("li",[t._v("Dynamic Loader Info\n"),a("ul",[a("li",[t._v("Binding Info")]),t._v(" "),a("li",[t._v("Lazy Binding Info")])])])]),t._v(" "),a("p",[t._v("涉及若干个 sections、load commands，以及 indirect symbol table、dynamic loader info 等。其中"),a("code",[t._v("LC_LOAD_DYLIB")]),t._v("这个命令上文已经提到，它描述了镜像依赖的 dylibs。"),a("code",[t._v("LC_SYMTAB")]),t._v("定义的符号表（symbol table）是镜像所用到的符号（包括内部符号和外部符号）的集合，"),a("router-link",{attrs:{to:"/post/macho-static-link.html#symbol-table"}},[t._v("Mach-O 与静态链接")]),t._v("对该命令和符号表有详细描述，本文不再赘述。")],1),t._v(" "),a("h2",{attrs:{id:"indirect-symbol-table"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#indirect-symbol-table"}},[t._v("#")]),t._v(" Indirect Symbol Table")]),t._v(" "),a("p",[t._v("每一个可执行的镜像文件，都有一个 symbol table，由"),a("code",[t._v("LC_SYMTAB")]),t._v("命令定义，包含了镜像所用到的所有符号信息。那么 indirect symbol table 是一个什么东西呢？本质上，indirect symbol table 是 index 数组，即每个条目的内容是一个 index 值，该 index 值（从 0 开始）指向到 symbol table 中的条目。Indirect symbol table 由"),a("code",[t._v("LC_DYSYMTAB")]),t._v("定义，后者的参数类型是一个"),a("code",[t._v("dysymtab_command")]),t._v("结构体，详见"),a("a",{attrs:{href:"https://opensource.apple.com/source/xnu/xnu-4903.221.2/EXTERNAL_HEADERS/mach-o/loader.h.auto.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("dysymtab_command"),a("OutboundLink")],1),t._v("，该结构体内容非常丰富，目前我们只需要关注"),a("code",[t._v("indirectsymoff")]),t._v("和"),a("code",[t._v("nindirectsyms")]),t._v("这两个字段：")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("dysymtab_command")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    uint32_t cmd"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("           "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* LC_DYSYMTAB */")]),t._v("\n    uint32_t cmdsize"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("       "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* sizeof(struct dysymtab_command) */")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n\n    uint32_t indirectsymoff"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* file offset to the indirect symbol table */")]),t._v("\n    uint32_t nindirectsyms"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* number of indirect symbol table entries */")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[a("code",[t._v("indirectsymoff")]),t._v("和"),a("code",[t._v("nindirectsyms")]),t._v("这两个字段定义了 indirect symbol table 的位置信息，每一个条目是一个 4 bytes 的 index 值。")]),t._v(" "),a("p",[t._v("Indirect symbol table 的结构还是蛮容易理解的，但其存在的意义是啥？先别急，后面会讲到，总之它是为"),a("code",[t._v("__stubs")]),t._v("、"),a("code",[t._v("__got")]),t._v("等 section 服务的。")]),t._v(" "),a("p",[t._v("上文 main.out 的 indirect symbol table 可使用"),a("code",[t._v("otool -I main.out")]),t._v("查看，一共包括 5 个条目：")]),t._v(" "),a("div",{staticClass:"language-raw extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Indirect symbols for (__TEXT,__stubs) 1 entries\n  address            index\n  0x0000000000001fbe     3\n\nIndirect symbols for (__DATA,__nl_symbol_ptr) 2 entries\n  address            index\n  0x0000000000002000     4\n\n0x0000000000002008 ABSOLUTE\n\nIndirect symbols for (__DATA,__got) 1 entries\n  address            index\n  0x0000000000002010     2\n\nIndirect symbols for (__DATA,__la_symbol_ptr) 1 entries\n  address            index\n  0x0000000000002018     3\n")])])]),a("blockquote",[a("p",[t._v("第三个条目的 index 值有些奇怪，还没搞清楚...")])]),t._v(" "),a("h2",{attrs:{id:"text-里的外部符号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#text-里的外部符号"}},[t._v("#")]),t._v(" __text 里的外部符号")]),t._v(" "),a("p",[t._v("回到上文提到的 main.out，使用"),a("code",[t._v("otool -tv main.out")]),t._v("命令查看 main.out 代码段的反汇编内容下：")]),t._v(" "),a("div",{staticClass:"language-raw extra-class"},[a("div",{staticClass:"highlight-lines"},[a("br"),a("br"),a("br"),a("br"),a("br"),a("div",{staticClass:"highlighted"},[t._v(" ")]),a("br"),a("br"),a("div",{staticClass:"highlighted"},[t._v(" ")]),a("br"),a("br"),a("br"),a("br"),a("br")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("_main:\n0000000000001f90  pushq %rbp\n0000000000001f91  movq  %rsp, %rbp\n0000000000001f94  subq  $0x10, %rsp\n0000000000001f98  leaq  0x3f(%rip), %rsi\n0000000000001f9f  movq  0x6a(%rip), %rax\n0000000000001fa6  movl  $0x0, -0x4(%rbp)\n0000000000001fad  movq  (%rax), %rdi\n0000000000001fb0  callq 0x1fbe\n0000000000001fb5  xorl  %eax, %eax\n0000000000001fb7  addq  $0x10, %rsp\n0000000000001fbb  popq  %rbp\n0000000000001fbc  retq\n")])])]),a("p",[t._v("上述是 main 函数的反汇编代码，注意第 6 行和第 9 行，这两行的指令分别引用了"),a("code",[t._v("_kHelloPrefix")]),t._v("和"),a("code",[t._v("_say")]),t._v("符号；这两个符号未绑定，如果是静态链接，这俩处的地址值是 0；但此处是动态链接，符号目标地址值分别指向的是偏移 0x6a 和 0x09，本文所在环境，采用的 PC 近址寻址，所以"),a("code",[t._v("_kHelloPrefix")]),t._v("和"),a("code",[t._v("_say")]),t._v("的目标地址分别是：")]),t._v(" "),a("div",{staticClass:"language-raw extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("_kHelloPrefix 的目标虚拟地址 = 0x1fa6（第 7 行指令的虚拟地址） + 0x6a = 0x2010\n_say 的目标虚拟地址 = 0x1fb5（第 10 行指令虚拟地址） + 0x09 = 0x1fbe\n")])])]),a("p",[a("code",[t._v("0x2010")]),t._v("和"),a("code",[t._v("0x1fbe")]),t._v("分别对应 main.out 中的哪个结构呢？答案是 section(__DATA __got) 和 section(__TEXT __stubs)，使用"),a("code",[t._v("otool -s")]),t._v("命令可以查看这两个 section 的地址和内容：")]),t._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("$ otool main.out -s __DATA __got\nmain.out:\nContents of "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__DATA,__got"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" section\n0000000000002010  00 00 00 00 00 00 00 00\n\n$ otool main.out -s __TEXT __stubs\nmain.out:\nContents of "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__TEXT,__stubs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" section\n0000000000001fbe  ff "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("25")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("54")]),t._v(" 00 00 00\n")])])]),a("p",[t._v("Mach-O 的代码段对 dylib 外部符号的引用地址，要么指向到"),a("code",[t._v("__got")]),t._v("，要么指向到"),a("code",[t._v("__stubs")]),t._v("。什么时候指向到前者，什么时候指向到后者呢？")]),t._v(" "),a("p",[t._v("站在逻辑的角度，符号有两种：数据型和函数型；前者的值指向到全局变量/常量，后者的值指向到函数。在动态链接的概念里，对这两种符号的绑定称为：non-lazy binding、lazy binding。对于前者，在程序运行前（加载时）就会被绑定；对于后者，在符号被第一次使用时（运行时）绑定。")]),t._v(" "),a("h2",{attrs:{id:"section-data-got"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#section-data-got"}},[t._v("#")]),t._v(" section(__DATA __got)")]),t._v(" "),a("p",[t._v("对于程序段"),a("code",[t._v("__text")]),t._v("里的代码，对数据型符号的引用，指向到了"),a("code",[t._v("__got")]),t._v("；可以把"),a("code",[t._v("__got")]),t._v("看作是一个表，每个条目是一个地址值。")]),t._v(" "),a("p",[t._v("在符号绑定（binding）前，"),a("code",[t._v("__got")]),t._v("里所有条目的内容都是 0，当镜像被加载时，dyld 会对"),a("code",[t._v("__got")]),t._v("每个条目所对应的符号进行重定位，将其真正的地址填入，作为条目的内容。换句话说，"),a("code",[t._v("__got")]),t._v("各个条目的具体值，在加载期会被 dyld 重写，这也是为啥这个 section 被分配在 __DATA segment 的原因。")]),t._v(" "),a("p",[t._v("问题来了，dyld 是如何知道"),a("code",[t._v("__got")]),t._v("中各个条目对应的符号信息（譬如符号名字、目标库等）呢？"),a("router-link",{attrs:{to:"/post/macho-structure.html"}},[t._v("Mach-O 简单分析")]),t._v("已经提到过，每个 segment 由"),a("code",[t._v("LC_SEGMENT")]),t._v("命令定义，该命令后的参数描述了 segment 包含的 section 信息，是谓 section header，对应结构体（x86_64架构）是"),a("a",{attrs:{href:"https://opensource.apple.com/source/xnu/xnu-4903.221.2/EXTERNAL_HEADERS/mach-o/loader.h.auto.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("section_64"),a("OutboundLink")],1),t._v("：")],1),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("section_64")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* for 64-bit architectures */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v("      sectname"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* name of this section */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v("      segname"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("     "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* segment this section goes in */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n    uint32_t  reserved1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("       "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* reserved (for offset or index) */")]),t._v("\n    uint32_t  reserved2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("       "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* reserved (for count or sizeof) */")]),t._v("\n    uint32_t  reserved3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("       "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* reserved */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("对于"),a("code",[t._v("__got")]),t._v("、"),a("code",[t._v("__stubs")]),t._v("、"),a("code",[t._v("__nl_symbol_ptr")]),t._v("、"),a("code",[t._v("__la_symbol_ptr")]),t._v("这几个 section，其"),a("code",[t._v("reserved1")]),t._v("描述了该 list 中条目在 indirect symbol table 中的偏移量。")]),t._v(" "),a("p",[t._v("举个栗子，本文的 main.out 中的"),a("code",[t._v("__got")]),t._v("的 section header 的"),a("code",[t._v("reserved1")]),t._v("字段值为 3，它有一个条目，那么该条目对应的符号在 symbol table 中的 index，等于 indirect symbol table 中第 3+1 个条目的值；有点绕口，用伪代码表示，main.out 的"),a("code",[t._v("__got")]),t._v("的第一个条目对应的符号是：")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[t._v("__got"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("symbol "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" symbolTable"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("indirectSymbolTable"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("__got"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sectionHeader"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("reserved1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// -> __got.sectionHeader.reserved1 == 3")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// -> indirectSymbolTable[3] == 2")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// -> symbolTable[2] = Symbol(_kHelloPrefix)")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// -> __got[0]->symbol = Symbol(_kHelloPrefix)")]),t._v("\n")])])]),a("p",[t._v("算是把"),a("code",[t._v("__got")]),t._v("讲清楚了，总之一句话，"),a("code",[t._v("__got")]),t._v("为 dyld 服务，用来存放 non-lazy 符号的最终地址值。")]),t._v(" "),a("p",[t._v("现在该说说"),a("code",[t._v("__stub")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"section-text-stubs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#section-text-stubs"}},[t._v("#")]),t._v(" section(__TEXT __stubs)")]),t._v(" "),a("p",[t._v("对于程序段"),a("code",[t._v("__text")]),t._v("里的代码，对函数型符号的引用，指向到了"),a("code",[t._v("__stubs")]),t._v("。和"),a("code",[t._v("__got")]),t._v("一样，"),a("code",[t._v("__stubs")]),t._v("也是一个表，每个表项是一小段"),a("code",[t._v("jmp")]),t._v("代码，称为「符号桩」。和"),a("code",[t._v("__got")]),t._v("不同的是，"),a("code",[t._v("__stubs")]),t._v("存在于 __TEXT segment 中，所以其中的条目内容是不可更改的。")]),t._v(" "),a("p",[t._v("查看"),a("code",[t._v("__stubs")]),t._v("里的反汇编内容：")]),t._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("$ otool -v main.out -s __TEXT __stubs\nmain.out:\nContents of "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__TEXT,__stubs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" section\n0000000000001fbe  jmpq  *0x54"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("%rip"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("来看看"),a("code",[t._v("jmp")]),t._v("指令跳到哪里去，这里使用的间接寻址，真正的地址值存在 0x0000000000002018 中。")]),t._v(" "),a("blockquote",[a("p",[t._v("0x0000000000000x2018 = 0x0000000000001fbe + 0x54")])]),t._v(" "),a("p",[a("code",[t._v("0x2018")]),t._v("是哪个部分？答案是 section(__DATA __la_symbol_ptr)...")]),t._v(" "),a("h2",{attrs:{id:"section-data-la-symbol-ptr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#section-data-la-symbol-ptr"}},[t._v("#")]),t._v(" section(__DATA __la_symbol_ptr)")]),t._v(" "),a("p",[t._v("使用"),a("code",[t._v("otool -s")]),t._v("查看"),a("code",[t._v("__la_symbol_ptr")]),t._v("的内容：")]),t._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("$ otool main.out -s __DATA __la_symbol_ptr\nmain.out:\nContents of "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__DATA,__la_symbol_ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" section\n0000000000002018  d4 1f 00 00 00 00 00 00\n")])])]),a("p",[a("code",[t._v("__la_symbol_ptr")]),t._v("的内容是 0x1FD4（小端），所以"),a("code",[t._v("__stubs")]),t._v("第一个 stub 的 jump 目标地址是 0x1FD4。该地址坐落于 section(__TEXT __stub_helper)。")]),t._v(" "),a("h2",{attrs:{id:"section-text-stub-helper"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#section-text-stub-helper"}},[t._v("#")]),t._v(" section(__TEXT __stub_helper)")]),t._v(" "),a("p",[t._v("看看"),a("code",[t._v("__stub_helper")]),t._v("里的内容：")]),t._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("div",{staticClass:"highlight-lines"},[a("br"),a("br"),a("br"),a("br"),a("br"),a("div",{staticClass:"highlighted"},[t._v(" ")]),a("br"),a("div",{staticClass:"highlighted"},[t._v(" ")]),a("br"),a("br")]),a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("$ otool -v main.out -s __TEXT __stub_helper\nmain.out:\nContents of "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__TEXT,__stub_helper"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" section\n0000000000001fc4  leaq  0x3d"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("%rip"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(", %r11\n0000000000001fcb  pushq %r11\n0000000000001fcd  jmpq  *0x2d"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("%rip"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n0000000000001fd3  nop\n0000000000001fd4  pushq "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$0x0")]),t._v("\n0000000000001fd9  jmp 0x1fc4\n")])])]),a("p",[a("code",[t._v("__stubs")]),t._v("第一个 stub 的 jump 目标地址在第 8 行；这几条汇编代码比较简单，可以看出，代码最终会跳到第 6 行；之后该何处何从？")]),t._v(" "),a("p",[t._v("不难计算，第 6 行跳转目标地址是 0x2000 (0x1fd3 + 0x2d)存储的内容，0x2000 在哪里呢？0x2000 坐落于 section(__DATA __nl_symbol_ptr)。")]),t._v(" "),a("h2",{attrs:{id:"section-data-nl-symbol-ptr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#section-data-nl-symbol-ptr"}},[t._v("#")]),t._v(" section(__DATA __nl_symbol_ptr)")]),t._v(" "),a("p",[t._v("按惯例，查看"),a("code",[t._v("__nl_symbol_ptr")]),t._v("里的内容：")]),t._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("$ otool main.out -s __DATA __nl_symbol_ptr\nmain.out:\nContents of "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__DATA,__nl_symbol_ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" section\n0000000000002000  00 00 00 00 00 00 00 00\n0000000000002008  00 00 00 00 00 00 00 00\n")])])]),a("p",[t._v("啥是"),a("code",[t._v("__nl_symbol_ptr")]),t._v("？和"),a("code",[t._v("__got")]),t._v("类似，"),a("code",[t._v("__nl_symbol_ptr")]),t._v("也是用来存储 non-lazy symbol 绑定后的地址。只是"),a("code",[t._v("__got")]),t._v("是为"),a("code",[t._v("__text")]),t._v("代码段中的符号服务的，而"),a("code",[t._v("__nl_symbol_ptr")]),t._v("不是。")]),t._v(" "),a("p",[t._v("如上，"),a("code",[t._v("__nl_symbol_ptr")]),t._v("的第一个条目的符号是"),a("code",[t._v("dyld_stub_binder")]),t._v("。")]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("dyld_stub_binder")]),t._v("是一个函数，为啥它被当做一个 non-lazy symbol 处理，这是因为它是所有 lazy binding 的基础，所以有些特殊。")])]),t._v(" "),a("h2",{attrs:{id:"dyld-stub-binder"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dyld-stub-binder"}},[t._v("#")]),t._v(" dyld_stub_binder")]),t._v(" "),a("p",[a("code",[t._v("dyld_stub_binder")]),t._v("也是一个函数，定义于"),a("a",{attrs:{href:"https://opensource.apple.com/source/dyld/dyld-635.2/src/dyld_stub_binder.s.auto.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("dyld_stub_binder.S"),a("OutboundLink")],1),t._v("，由 dyld 提供。")]),t._v(" "),a("p",[t._v("Lazy binding symbol 的绑定工作正是由 dyld_stub_binder 触发，通过调用"),a("code",[t._v("dyld::fastBindLazySymbol")]),t._v("来完成。")]),t._v(" "),a("h2",{attrs:{id:"lazy-binding-分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lazy-binding-分析"}},[t._v("#")]),t._v(" Lazy Binding 分析")]),t._v(" "),a("p",[t._v("上文结合 main.out 实例，对 Mach-O 与动态链接相关的结构做了比较全面的分析。Non-lazy binding 比较容易理解，这里稍微对如上内容进行整合，整体对 lazy binding 基本逻辑进行概述。")]),t._v(" "),a("p",[t._v("对于"),a("code",[t._v("__text")]),t._v("代码段里需要被 lazy binding 的符号引用（如上文 main.out 里的"),a("code",[t._v("_say")]),t._v("），访问它时总会跳转到 stub 中，该 stub 的本质是一个 jmp 指令，该 stub 的跳转目标地址坐落于"),a("code",[t._v("__la_symbol_ptr")]),t._v("。")]),t._v(" "),a("p",[t._v("首次访问"),a("code",[t._v("_say")]),t._v("时：")]),t._v(" "),a("ol",[a("li",[a("code",[t._v("_say")]),t._v("对应的"),a("code",[t._v("__la_symbol_ptr")]),t._v("条目内容指向到"),a("code",[t._v("__stub_helper")])]),t._v(" "),a("li",[a("code",[t._v("__stub_helper")]),t._v("里的代码逻辑，通过各种辗转最终调用"),a("code",[t._v("dyld_stub_binder")]),t._v("函数")]),t._v(" "),a("li",[a("code",[t._v("dyld_stub_binder")]),t._v("函数通过调用 dyld 内部的函数找到"),a("code",[t._v("_say")]),t._v("符号的真实地址")]),t._v(" "),a("li",[a("code",[t._v("dyld_stub_binder")]),t._v("将地址写入"),a("code",[t._v("__la_symbol_ptr")]),t._v("条目")]),t._v(" "),a("li",[a("code",[t._v("dyld_stub_binder")]),t._v("跳转到"),a("code",[t._v("_say")]),t._v("符号的真实地址")])]),t._v(" "),a("p",[t._v("之后再次访问"),a("code",[t._v("_say")]),t._v("时，stub 里的 jmp 指令直接跳转符号的真实地址，因为该地址已经被写到"),a("code",[t._v("__la_symbol_ptr")]),t._v("条目中。")]),t._v(" "),a("h1",{attrs:{id:"写在后面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写在后面"}},[t._v("#")]),t._v(" 写在后面")]),t._v(" "),a("p",[t._v("分析到这里，有种神清气爽的感觉，是那种费了老半天劲儿爬到高处欣赏风景的感觉。理解这些与动态链接有关的内容后，再去分析其他比较底层的东西，或许就有眉目了。")]),t._v(" "),a("p",[t._v("此处做一个小结：")]),t._v(" "),a("ol",[a("li",[t._v("本文并未对"),a("code",[t._v("Dynamic Loader Info")]),t._v("内容进行展开，其中涉及 Bind 相关的各种 opcode。原因有俩，其一，笔者对它们的了解并不深刻；其二，至少目前来看，了解它们的意义不大。")]),t._v(" "),a("li",[t._v("笔者看了许多其他博客，发现很少有谈到"),a("code",[t._v("__got")]),t._v("这个 section 的，本文所提到的"),a("code",[t._v("__got")]),t._v("的作用，在他们的博客中，都被冠到"),a("code",[t._v("__nl_symbol_ptr")]),t._v("中；猜测的原因是编译器的处理姿势不一样了；不过这也不是很重要了，真正重要的是会自己分析，毕竟无论是"),a("code",[t._v("__got")]),t._v("，还是"),a("code",[t._v("__nl_symbol_ptr")]),t._v("，只是一个名字而已。")])]),t._v(" "),a("p",[t._v("关于 Mach-O 的动态链接，还有很多值得分析的问题，之后的博客或许会有补充，包括但不限于：")]),t._v(" "),a("ul",[a("li",[t._v("dyld 是如何工作的？")]),t._v(" "),a("li",[t._v("如何理解 fishhook？")]),t._v(" "),a("li",[t._v("Objective-C 与动态链接碰撞出了什么样的火花？")])]),t._v(" "),a("h1",{attrs:{id:"更多阅读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更多阅读"}},[t._v("#")]),t._v(" 更多阅读")]),t._v(" "),a("ul",[a("li",[t._v("《深入理解计算机系统》")]),t._v(" "),a("li",[t._v("《程序员的自我修养》")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://adrummond.net/posts/macho",target:"_blank",rel:"noopener noreferrer"}},[t._v("Inside a Hello World executable on OS X"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://satanwoo.github.io/2017/06/13/Macho-1/",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入剖析Macho(1)"),a("OutboundLink")],1)])])],1)}),[],!1,null,null,null);s.default=_.exports}}]);