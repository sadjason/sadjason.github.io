(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{208:function(t,a,v){"use strict";v.r(a);var _=v(0),s=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("一个系统中的进程是与其他进程共享 CPU 和主存资源的。如果直接使用主存资源，可能会带来如下问题：")]),t._v(" "),v("ul",[v("li",[t._v("进程太多，可能导致主存资源不够用，当一个程序没有空间可用时，它只能怪自己运气不好了，GG")]),t._v(" "),v("li",[t._v("某个进程不小心写了另一个进程使用的内存，凉凉")])]),t._v(" "),v("p",[t._v("为了更加有效地管理内存并少出错，现代系统提供了一种对主存资源的抽象概念：虚拟内存（VM, Virtual Memory）。本文以《深入理解计算机系统》的第九章《虚拟内存》为纲，旨在记录针对虚拟内存的学习笔记。")]),t._v(" "),v("p",[t._v("何谓虚拟内存？我认为可以从两个方面理解这个概念。其一是宏观角度，它是现代操作系统管理内存的笼统概念；其二是微观角度，它和物理内存（主存，DRAM）对应。为啥要特别说明这一点呢？下文在讨论虚拟内存时，会比较笼统。")]),t._v(" "),v("p",[t._v("谈论虚拟内存，必然绕不过进程，它为每一个进程提供了一个大的、一致的和私有的地址空间。提供了三个重要的能力：")]),t._v(" "),v("ul",[v("li",[t._v("高效使用主存。将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存")]),t._v(" "),v("li",[t._v("进程地址一致。为每个进程提供了一致的地址空间，从而简化了内存管理")]),t._v(" "),v("li",[t._v("进程地址隔离。即保护了每个进程的地址空间不被其他进程破坏")])]),t._v(" "),v("h1",{attrs:{id:"基础概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基础概念"}},[t._v("#")]),t._v(" 基础概念")]),t._v(" "),v("h2",{attrs:{id:"物理寻址-虚拟寻址"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#物理寻址-虚拟寻址"}},[t._v("#")]),t._v(" 物理寻址 & 虚拟寻址")]),t._v(" "),v("p",[t._v("计算机的主存被组织成一个由 M 个连续字节大小单元组成的数组，每个字节都有一个唯一的物理地址。所谓物理寻址（Physical Addressing），指的是 CPU 直接使用物理地址访问存储器。")]),t._v(" "),v("p",[t._v("下图展示了一个物理寻址的示例，该示例的上下文是一条加载指令，它读取从物理地址 4 处开始的 4 字节字。当 CPU 执行该指令时，会生成一个有效物理地址，通过内存总线，把它传递给主存。主存取出从物理地址 4 处开始的 4 字节字，并把它返回给 CPU，CPU 把它存放在一个寄存器里。")]),t._v(" "),v("e-img",{attrs:{src:"/image/draft/physical-addressing.png"}}),t._v(" "),v("p",[t._v("早期 PC 中使用物理寻址，即便到今天，很多裸奔的单片机（譬如经典的 51 系列单片机）仍然也使用物理寻址。")]),t._v(" "),v("p",[t._v("然而，复杂的现代处理器使用的是虚拟寻址（Virtual Addressing）。使用虚拟寻址时，CPU 通过生成一个虚拟地址（Virtual Address，VA）来访问主存，这个 VA 被送到存储器之前先转换成合适的物理地址。将一个虚拟地址转换成物理地址的任务叫做地址翻译（Address Translation）。CPU 芯片上基本上都集成了内存管理单元（MMU, Memory Management Unit）的专用芯片，用来进行地址翻译。")]),t._v(" "),v("e-img",{attrs:{src:"/image/draft/virtual-addressing.png"}}),t._v(" "),v("blockquote",[v("p",[t._v("物理寻址和虚拟地址各自的好处与缺点？")])]),t._v(" "),v("h1",{attrs:{id:"能力：缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#能力：缓存"}},[t._v("#")]),t._v(" 能力：缓存")]),t._v(" "),v("p",[t._v("VM 系统将每个虚拟内存划分为大小相等的页进行管理，称为：虚拟页（VP, Virtual Page）；VP 的典型值是 4KB ~ 2MB。")]),t._v(" "),v("p",[t._v("关键问题来了：VP 的物理介质是啥，换句话说，它的数据放在哪里？这个问题其实挺难回答的，因为问题不对。")]),t._v(" "),v("p",[t._v("在任何时刻，VP 都处于如下三种状态：")]),t._v(" "),v("ul",[v("li",[t._v("未分配的：即还处于未分配状态，此时没有数据与之关联，不占用任何物理空间")]),t._v(" "),v("li",[t._v("已分配的：表示此 VP 已经被 VM 系统分配了磁盘空间\n"),v("ul",[v("li",[t._v("缓存的：表示此 VP 的数据已经被缓存到物理内存（DRAM）中")]),t._v(" "),v("li",[t._v("未缓存的：表示此 VP 的数据并未被缓存到物理内存（DRAM）中")])])])]),t._v(" "),v("blockquote",[v("p",[t._v("访问未分配的 VP，会导致什么？")])]),t._v(" "),v("p",[t._v("至此再谈论 VP 的物理介质就有些幼稚了。与其关心介质，倒不如关心数据。如果未分配，VP 则没有数据；如果分配了，VP 的 base 数据在磁盘上，如果还被缓存了，那么物理内存上也有一份它的数据。")]),t._v(" "),v("p",[t._v("显然，VP 和磁盘、物理内存是紧密相连的。为了数据传输方便，一个基本的的设定是：物理内存和磁盘都被分割为与 VP 大小相同的页。对于物理内存而言，对应的概念叫做：物理页（VP, Physical Page），也叫页帧（page frame）。")]),t._v(" "),v("p",[t._v("对于现代操作系统，有一个常常被提到的概念叫 pageSize，它既指物理页大小，也指虚拟页大小。")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("补充说明")]),t._v(" "),v("ul",[v("li",[t._v("可以改变 pageSize 吗？网上看到的说法是，i386 硬件，是可以改的（在系统内核编译阶段）；64bit 硬件，固定为 4K，无法改变。")]),t._v(" "),v("li",[t._v("*nix 系统可以通过"),v("code",[t._v("pagesize")]),t._v("命令知晓当前的 VP 和 PP 大小")])])]),t._v(" "),v("h2",{attrs:{id:"页表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#页表"}},[t._v("#")]),t._v(" 页表")]),t._v(" "),v("p",[t._v("同任何缓存一样，VM 系统必须有某个方法来判定一个虚拟页是否缓存在于 DRAM 中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中；如果否，系统必须判断这个虚拟页存放的在磁盘的哪个位置，并将它拷贝到内存中。")]),t._v(" "),v("p",[t._v("这个功能由软硬件联合提供，包括操作系统、MMU（内存管理单元）和一个存放在物理内存中叫做页表的数据结构，页表将虚拟页映射到物理页。")]),t._v(" "),v("p",[t._v("下图展示了一个页表的基本组织结构；页表就是一个页表条目（PTE, Page Table Entry）的数组：")]),t._v(" "),v("e-img",{attrs:{src:"/image/draft/vm-page-table.png"}}),t._v(" "),v("p",[t._v("页表在哪里呢？抛开进程是无法单独讨论页表的。对于进程而言，页表描述了该进程的虚拟地址空间，换句话说，每个进程都有一个页表。")]),t._v(" "),v("p",[t._v("对于 Linux 系统，每个进程都在内存中对应一个进程描述符："),v("code",[t._v("task_struct")]),t._v("，它定义于"),v("a",{attrs:{href:"https://github.com/torvalds/linux/blob/master/include/linux/sched.h",target:"_blank",rel:"noopener noreferrer"}},[t._v("sched.h"),v("OutboundLink")],1),t._v("，"),v("code",[t._v("task_struct")]),t._v("是一个 KB 级别的大结构体。其中的"),v("code",[t._v("mm")]),t._v("成员变量描述了进程的内存资源信息，进程的页表藏于该字段（对应结构体"),v("code",[t._v("mm_struct")]),t._v("，详见"),v("a",{attrs:{href:"https://github.com/torvalds/linux/blob/master/include/linux/mm_types.h",target:"_blank",rel:"noopener noreferrer"}},[t._v("mm_types.h"),v("OutboundLink")],1),t._v("）。")]),t._v(" "),v("p",[t._v("进程描述符（"),v("code",[t._v("task_struct")]),t._v("）由内核维护，它是常驻的；同样，进程页表也常驻于 DRAM 中。")]),t._v(" "),v("h2",{attrs:{id:"页命中-缺页"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#页命中-缺页"}},[t._v("#")]),t._v(" 页命中 & 缺页")]),t._v(" "),v("p",[t._v("页命中和缺页是虚拟内存中的关键概念，下图是对它们的描述：")]),t._v(" "),v("e-img",{attrs:{src:"/image/draft/vm-page-hit-missing.png"}}),t._v(" "),v("p",[t._v("DRAM 缓存不命中称为缺页（page fault）。")]),t._v(" "),v("p",[t._v("上图中，访问 VP3 会导致缺页，因为 VP 3 并未缓存在 DRAM 中。地址翻译硬件从内存中读取 PTE 3，从有效位推断出 VP 3 未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个"),v("strong",[t._v("牺牲页")]),t._v("。如果该牺牲页已经被修改了，那么内核就会将它复制回磁盘；同时内核会修改该牺牲页的 PTE 条目，即标记该 VP 状态为「未缓存的」。接下来，内核从磁盘复制 VP 3 到内存中，更新 PTE 3，随后返回。当异常程序返回时，它会重新启动导致缺页的指令。")]),t._v(" "),v("p",[t._v("在磁盘和内存之间传送页的活动叫"),v("strong",[t._v("交换")]),t._v("（swapping）或者"),v("strong",[t._v("页面调度")]),t._v("（paging）；现代操作系统使用页面的调度姿势是按需调度。")]),t._v(" "),v("h2",{attrs:{id:"分配页面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分配页面"}},[t._v("#")]),t._v(" 分配页面")]),t._v(" "),v("p",[t._v("何谓分配页面呢？指的是在磁盘上创建空间并更新 PTE，使它指向到磁盘上这个新创建的页面。")]),t._v(" "),v("blockquote",[v("p",[t._v("在程序中调用"),v("code",[t._v("malloc")]),t._v("通常就会触发页面的创建。")])]),t._v(" "),v("h1",{attrs:{id:"能力：内存管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#能力：内存管理"}},[t._v("#")]),t._v(" 能力：内存管理")]),t._v(" "),v("p",[t._v("操作系统为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。")]),t._v(" "),v("e-img",{attrs:{src:"/image/draft/vm-vp-pp.png"}}),t._v(" "),v("p",[t._v("从上图可以看出，多个虚拟页可以映射到同一个共享物理页面上。")]),t._v(" "),v("h2",{attrs:{id:"简化链接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简化链接"}},[t._v("#")]),t._v(" 简化链接")]),t._v(" "),v("p",[t._v("独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。比如说，给定的 Linux 系统上的每个进程都是使用类似的内存格式。对于 64 位地址空间，代码段总是从虚拟地址 0x400000 开始。数据段跟在代码段之后，中间有一段符合要求的对齐空白。栈占据用户进程地址空间最高的部分，并向下生长。这样的一致性极大地简化了链接器的设计和实现，允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据最终位置的。")]),t._v(" "),v("blockquote",[v("p",[t._v("如上这段拷贝自《深入理解计算机系统》，没太理解。")])]),t._v(" "),v("h2",{attrs:{id:"简化加载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简化加载"}},[t._v("#")]),t._v(" 简化加载")]),t._v(" "),v("p",[t._v("虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中 .text 和 .data 节加载到一个新创建的进程中，Linux 加载器伪代码和数据段分配虚拟页，把它们标记为为缓存的，将页表条目指向目标文件中适当的位置。有趣的是，加载器从不从磁盘到内存实际复制任何数据。在每个页初次被使用时，要么是 CPU 取指令时，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调用数据页。")]),t._v(" "),v("blockquote",[v("p",[t._v("如上这段拷贝自《深入理解计算机系统》，没太理解。")])]),t._v(" "),v("h2",{attrs:{id:"简化共享"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简化共享"}},[t._v("#")]),t._v(" 简化共享")]),t._v(" "),v("p",[t._v("下文有更详细的说明。")]),t._v(" "),v("h2",{attrs:{id:"简化内存分配"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简化内存分配"}},[t._v("#")]),t._v(" 简化内存分配")]),t._v(" "),v("p",[t._v("分配内存时，可以在虚拟地址空间内是连续的，但在物理地址空间上是不连续的。")]),t._v(" "),v("h1",{attrs:{id:"能力：内存保护"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#能力：内存保护"}},[t._v("#")]),t._v(" 能力：内存保护")]),t._v(" "),v("p",[t._v("这个比较简单。问个问题：有哪些情况会触发 segment fault。")]),t._v(" "),v("h1",{attrs:{id:"内存映射"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存映射"}},[t._v("#")]),t._v(" 内存映射")]),t._v(" "),v("h2",{attrs:{id:"共享对象-私有对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#共享对象-私有对象"}},[t._v("#")]),t._v(" 共享对象 & 私有对象")]),t._v(" "),v("p",[t._v("一个对象（理解为文件我认为也是没问题滴）可以被映射到虚拟内存的一个区域，要么作为"),v("strong",[t._v("共享对象")]),t._v("，要么作为"),v("strong",[t._v("私有对象")]),t._v("。")]),t._v(" "),v("p",[t._v("如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们的虚拟内存的其他进程而言，也是可见的。而且，这些变化也会反映到磁盘的原始对象中。")]),t._v(" "),v("e-img",{attrs:{src:"/image/draft/vm-shared-object.png"}}),t._v(" "),v("p",[t._v("另外一方面，对于一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘的原始对象中。")]),t._v(" "),v("e-img",{attrs:{src:"/image/draft/vm-copy-on-write.png"}}),t._v(" "),v("h2",{attrs:{id:"mmap"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mmap"}},[t._v("#")]),t._v(" mmap")]),t._v(" "),v("p",[t._v("对于一个存储器上的对象，它被装载到内存中时，系统该如何处理它呢？当做共享对象处理，还是私有对象处理？")]),t._v(" "),v("p",[t._v("应用级的 memory mapping，一般都通过"),v("code",[t._v("mmap()")]),t._v("系统调用完成。")]),t._v(" "),v("blockquote",[v("p",[t._v("不晓得除了"),v("code",[t._v("mmap()")]),t._v("，是否还有别的 memory mapping 姿势。")])]),t._v(" "),v("p",[v("code",[t._v("mmap()")]),t._v("的声明如下：")]),t._v(" "),v("div",{staticClass:"language-c extra-class"},[v("pre",{pre:!0,attrs:{class:"language-c"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("mmap")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("addr"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" size_t len"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" prot"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" flags"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" fd"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" off_t offset"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),v("p",[t._v("addr 和 len 描述目标虚拟区域信息；prot 描述该区域的属性，包括如下有效值：")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("PROT_NONE")]),t._v(": 不可访问")]),t._v(" "),v("li",[v("code",[t._v("PROT_READ")]),t._v(": 可读")]),t._v(" "),v("li",[v("code",[t._v("PROT_WRITE")]),t._v(": 可写")]),t._v(" "),v("li",[v("code",[t._v("PROT_EXEC")]),t._v(": 可执行")])]),t._v(" "),v("p",[v("code",[t._v("flags")]),t._v("描述对象类型，典型值包括：")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("MAP_PRIVATE")]),t._v(": Modification are private (copy-on-write)")]),t._v(" "),v("li",[v("code",[t._v("MAP_SHARED")]),t._v(": Modification are shared")])]),t._v(" "),v("blockquote",[v("p",[t._v("如何"),v("code",[t._v("addr")]),t._v("为 null 或者 0，则这个值由内核自动寻找；")])]),t._v(" "),v("p",[t._v("与"),v("code",[t._v("mmap")]),t._v("对应的是"),v("code",[t._v("munmap()")]),t._v("，它用于删除虚拟内存区域，其函数声明如下：")]),t._v(" "),v("div",{staticClass:"language-c extra-class"},[v("pre",{pre:!0,attrs:{class:"language-c"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("munmap")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("addr"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" size_t len"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),v("p",[t._v("被 munmap 处理的虚拟内存，会变成未分配的，如果访问，会触发 segment fault。")]),t._v(" "),v("h2",{attrs:{id:"fork-execve"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#fork-execve"}},[t._v("#")]),t._v(" fork & execve")]),t._v(" "),v("p",[t._v("假设运行在当前进程的程序执行了如下的 execve 调用：")]),t._v(" "),v("div",{staticClass:"language-sh extra-class"},[v("pre",{pre:!0,attrs:{class:"language-sh"}},[v("code",[t._v("execve"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[t._v('"a.out"')]),t._v(", NULL, NULL"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),v("p",[t._v("execve 函数在当前进程中加载并运行包含在可执行目标文件 a.out 中的程序，用 a.out 程序有效地替代了当前程序。加载并运行 a.out 需要一下几个步骤：")]),t._v(" "),v("ul",[v("li",[t._v("删除已存在的用于区域")]),t._v(" "),v("li",[t._v("映射私有区域")]),t._v(" "),v("li",[t._v("映射共享区域")]),t._v(" "),v("li",[t._v("设置程序计数器")])]),t._v(" "),v("h1",{attrs:{id:"动态内存分配"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#动态内存分配"}},[t._v("#")]),t._v(" 动态内存分配")]),t._v(" "),v("p",[t._v("既然有了"),v("code",[t._v("mmap()")]),t._v("，为啥还有"),v("code",[t._v("malloc()")]),t._v("？")]),t._v(" "),v("p",[t._v("这部分内容以后再补充吧。")]),t._v(" "),v("p",[t._v("需要重新认识堆。")]),t._v(" "),v("p",[t._v("如果想了解垃圾回收，也最好认真看一下这部分内容。")]),t._v(" "),v("h1",{attrs:{id:"一些问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一些问题"}},[t._v("#")]),t._v(" 一些问题")]),t._v(" "),v("p",[t._v("磁盘破损怎么办？操作系统是如何应对磁盘可靠性问题的？")])],1)}),[],!1,null,null,null);a.default=s.exports}}]);