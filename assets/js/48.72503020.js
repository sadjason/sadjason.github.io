(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{116:function(t,r,a){"use strict";a.r(r);var e=a(0),_=Object(e.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("参考资料：")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://juejin.im/post/5b189ca0f265da6e1e1adcbf",target:"_blank",rel:"noopener noreferrer"}},[t._v("面试官问到 TCP/IP 怎么回答才过关"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.im/post/5b7be0b2e51d4538db34a51e",target:"_blank",rel:"noopener noreferrer"}},[t._v("搞定计算机网络面试，看这篇就够了"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"http://blog.qiusuo.im/blog/2014/03/19/tcp-timeout/",target:"_blank",rel:"noopener noreferrer"}},[t._v("TCP 协议的那些超时"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.im/post/5c9f1dd651882567b4339bce",target:"_blank",rel:"noopener noreferrer"}},[t._v("一篇带你读懂 TCP 之滑动窗口协议"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("常见问题：")]),t._v(" "),a("ul",[a("li",[t._v("五层协议和七层协议包括哪些？")]),t._v(" "),a("li",[t._v("TCP 是哪一层协议？HTTP 是哪一层协议？TLS 是哪一层协议？")]),t._v(" "),a("li",[t._v("TCP 报文格式是啥？")]),t._v(" "),a("li",[t._v("TCP 报文携带 IP 地址吗？")]),t._v(" "),a("li",[t._v("如何理解序列号和确认号？")]),t._v(" "),a("li",[t._v("如何理解 ACK 报文？")]),t._v(" "),a("li",[t._v("如何理解 SYN 报文？")]),t._v(" "),a("li",[t._v("如何理解 FIN 报文？")]),t._v(" "),a("li",[t._v("画出三次握手连接过程？")]),t._v(" "),a("li",[t._v("Client 在哪个阶段可以给 Server 发送数据呢？")]),t._v(" "),a("li",[t._v("Client 给 Server 发送数据时，它还没准备好怎么办？")]),t._v(" "),a("li",[t._v("重新发起连接时，ISN 是否会发生变化呢？")]),t._v(" "),a("li",[t._v("握手过程中各个报文的序列号和确认号都是如何变化的？\n"),a("ul",[a("li",[t._v("关键在于理解 ACK、SYN 是否消耗确认号")])])]),t._v(" "),a("li",[t._v("客户端发送 SYN 后，没有回应怎么办？")]),t._v(" "),a("li",[t._v("服务端发送 ACK+SYN 后，没有回应怎么办？")]),t._v(" "),a("li",[t._v("画出四次挥手断开过程？")]),t._v(" "),a("li",[t._v("为什么是四次挥手，而不是三次？")]),t._v(" "),a("li",[t._v("TCP 连接会不会永远处于 FIN_WAIT_2 状态呢？")]),t._v(" "),a("li",[t._v("TCP 协议如何保证可靠传输？")]),t._v(" "),a("li",[t._v("滑动窗口是什么？\n"),a("ul",[a("li",[t._v("与流量控制有关，回答不上来也无所谓")])])]),t._v(" "),a("li",[t._v("存在哪里与 TCP 相关的连接，该如何规避？")])]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#五层协议-七层模型"}},[t._v("五层协议 & 七层模型")])]),a("li",[a("a",{attrs:{href:"#tcp-报文"}},[t._v("TCP 报文")]),a("ul",[a("li",[a("a",{attrs:{href:"#报文结构简单说明"}},[t._v("报文结构简单说明")])]),a("li",[a("a",{attrs:{href:"#一些问题"}},[t._v("一些问题")]),a("ul",[a("li",[a("a",{attrs:{href:"#tcp-报文格式是啥"}},[t._v("TCP 报文格式是啥")])]),a("li",[a("a",{attrs:{href:"#tcp-报文携带-ip-地址吗"}},[t._v("TCP 报文携带 IP 地址吗")])]),a("li",[a("a",{attrs:{href:"#tcp-报文是等长的吗？最后一个报文长度呢"}},[t._v("TCP 报文是等长的吗？最后一个报文长度呢")])]),a("li",[a("a",{attrs:{href:"#如何理解序列号和确认号"}},[t._v("如何理解序列号和确认号")])]),a("li",[a("a",{attrs:{href:"#如何理解-syn-报文和-fin-报文，为什么它们都消耗一个序列号"}},[t._v("如何理解 SYN 报文和 FIN 报文，为什么它们都消耗一个序列号")])]),a("li",[a("a",{attrs:{href:"#如何理解-ack-报文，它消耗序列号吗"}},[t._v("如何理解 ACK 报文，它消耗序列号吗")])]),a("li",[a("a",{attrs:{href:"#如何理解-ugc、psh、rst"}},[t._v("如何理解 UGC、PSH、RST")])]),a("li",[a("a",{attrs:{href:"#mss-选项"}},[t._v("MSS 选项")])])])])])]),a("li",[a("a",{attrs:{href:"#三次握手和四次挥手"}},[t._v("三次握手和四次挥手")]),a("ul",[a("li",[a("a",{attrs:{href:"#建立连接"}},[t._v("建立连接")]),a("ul",[a("li",[a("a",{attrs:{href:"#syn-ack-是两个报文吗"}},[t._v("SYN+ACK 是两个报文吗")])]),a("li",[a("a",{attrs:{href:"#为什么是三次握手，而不是两次或四次呢"}},[t._v("为什么是三次握手，而不是两次或四次呢")])]),a("li",[a("a",{attrs:{href:"#client-在哪个阶段可以给-server-发送数据呢"}},[t._v("Client 在哪个阶段可以给 Server 发送数据呢")])]),a("li",[a("a",{attrs:{href:"#client-给-server-发送数据时，它还没准备好怎么办"}},[t._v("Client 给 Server 发送数据时，它还没准备好怎么办")])]),a("li",[a("a",{attrs:{href:"#重新发起连接时，isn-是否会发生变化呢"}},[t._v("重新发起连接时，ISN 是否会发生变化呢")])]),a("li",[a("a",{attrs:{href:"#握手过程中各个报文的序列号和确认号都是如何变化的"}},[t._v("握手过程中各个报文的序列号和确认号都是如何变化的")])]),a("li",[a("a",{attrs:{href:"#如何理解连接建立的超时"}},[t._v("如何理解连接建立的超时")])])])]),a("li",[a("a",{attrs:{href:"#关闭连接"}},[t._v("关闭连接")]),a("ul",[a("li",[a("a",{attrs:{href:"#为什么是四次挥手，而不是三次"}},[t._v("为什么是四次挥手，而不是三次")])]),a("li",[a("a",{attrs:{href:"#第一次挥手的-fin-报文可以和数据报文的-ack-一起发送吗"}},[t._v("第一次挥手的 FIN 报文可以和数据报文的 ACK 一起发送吗")])]),a("li",[a("a",{attrs:{href:"#双方各个阶段如何不能发送消息"}},[t._v("双方各个阶段如何不能发送消息")])])])]),a("li",[a("a",{attrs:{href:"#tcp-的状态机"}},[t._v("TCP 的状态机")]),a("ul",[a("li",[a("a",{attrs:{href:"#如何理解-2msl-等待时间"}},[t._v("如何理解 2MSL 等待时间")])]),a("li",[a("a",{attrs:{href:"#tcp-连接会不会永远处于-fin-wait-2-状态呢"}},[t._v("TCP 连接会不会永远处于 FINWAIT2 状态呢")])]),a("li",[a("a",{attrs:{href:"#如何理解-last-ack"}},[t._v("如何理解 LAST_ACK")])])])])])]),a("li",[a("a",{attrs:{href:"#可靠性保证"}},[t._v("可靠性保证")])]),a("li",[a("a",{attrs:{href:"#滑动窗口与拥塞控制"}},[t._v("滑动窗口与拥塞控制")])]),a("li",[a("a",{attrs:{href:"#相关攻击"}},[t._v("相关攻击")]),a("ul",[a("li",[a("a",{attrs:{href:"#半连接攻击-syn-泛洪"}},[t._v("半连接攻击: SYN 泛洪")])]),a("li",[a("a",{attrs:{href:"#全连接攻击"}},[t._v("全连接攻击")])])])])])]),a("p"),t._v(" "),a("h1",{attrs:{id:"五层协议-七层模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五层协议-七层模型"}},[t._v("#")]),t._v(" 五层协议 & 七层模型")]),t._v(" "),a("p",[t._v("五层模型：物理层 - 链路层 - 网络层 - 传输层 - 应用层\n七层模型：物理层 - 链路层 - 网络层 - 会话层 - 表示层 - 应用层")]),t._v(" "),a("h1",{attrs:{id:"tcp-报文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-报文"}},[t._v("#")]),t._v(" TCP 报文")]),t._v(" "),a("h2",{attrs:{id:"报文结构简单说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#报文结构简单说明"}},[t._v("#")]),t._v(" 报文结构简单说明")]),t._v(" "),a("p",[t._v("TCP 报文被封装在一个 IP 数据报中，如下：")]),t._v(" "),a("e-img",{attrs:{src:"/image/draft/ip-message-header.png"}}),t._v(" "),a("p",[t._v("其中 TCP 首部内容通常是 20 个字节（不考虑 options 字段），如下：")]),t._v(" "),a("e-img",{attrs:{src:"/image/draft/tcp-message-header.png"}}),t._v(" "),a("p",[t._v("特别需要注意的是 6 个标识比特，意义如下：")]),t._v(" "),a("ul",[a("li",[t._v("ACK，确认序号有效")]),t._v(" "),a("li",[t._v("SYN，同步序号用来发起一个连接")]),t._v(" "),a("li",[t._v("FIN，发送端完成发送任务")]),t._v(" "),a("li",[t._v("URG，urgent pointer")]),t._v(" "),a("li",[t._v("PSH，接收方应该尽快将这个报文交给应用层")]),t._v(" "),a("li",[t._v("RST，重建连接")])]),t._v(" "),a("p",[t._v("在分析 TCP 握手连接和断开连接时会经常提及这些标志比特。这些比特位中可多个同时被置位。如果 SYN 被置位，其余位被清零，则习惯称报文为「SYN 报文」，如果 SYN 和 ACK 都被置位而其余位被清零，则称报文为「SYN+ACK 报文」，依次类推...")]),t._v(" "),a("p",[t._v("TCP 报文首部长度是可变的，可变部分就是上图中的「选项」字段。描述首部长度的字段是 4bit，单位是 32bit（4 字节），4bit 的最大值是 15，因此，TCP 报文的最大长度是 15 * 4 = 60 字节。")]),t._v(" "),a("h2",{attrs:{id:"一些问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一些问题"}},[t._v("#")]),t._v(" 一些问题")]),t._v(" "),a("p",[t._v("下面以 Q/A 的形式整理 TCP 报文的细节信息。")]),t._v(" "),a("h3",{attrs:{id:"tcp-报文格式是啥"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-报文格式是啥"}},[t._v("#")]),t._v(" TCP 报文格式是啥")]),t._v(" "),a("p",[t._v("TCP 报文格式是啥？是二进制还是文本？")]),t._v(" "),a("p",[t._v("TCP 报文的本质是字节流（每个字节 8bit），TCP 不对这些字节流作任何解释，即完全不理会传输数据是二进制数据、ASCII 字符或者其他类型数据，解释它们是应用层的任务。")]),t._v(" "),a("h3",{attrs:{id:"tcp-报文携带-ip-地址吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-报文携带-ip-地址吗"}},[t._v("#")]),t._v(" TCP 报文携带 IP 地址吗")]),t._v(" "),a("p",[t._v("TCP 只在首部携带源端和目的端的端口号信息，不携带 IP 地址信息，更不会携带 URL 信息，IP 地址信息存在于 IP 报文的首部。")]),t._v(" "),a("h3",{attrs:{id:"tcp-报文是等长的吗？最后一个报文长度呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-报文是等长的吗？最后一个报文长度呢"}},[t._v("#")]),t._v(" TCP 报文是等长的吗？最后一个报文长度呢")]),t._v(" "),a("p",[t._v("显然不是等长的。")]),t._v(" "),a("h3",{attrs:{id:"如何理解序列号和确认号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何理解序列号和确认号"}},[t._v("#")]),t._v(" 如何理解序列号和确认号")]),t._v(" "),a("p",[t._v("序列号（Sequence Number）是用来标识从 TCP 报文发送端向接收端发送的数据字节流，它表示报文第一个数据字节的 index。")]),t._v(" "),a("p",[t._v("确认号（Acknowledge Number）是 TCP 报文接收端对客户端的一种响应，它的值 = 所接收报文的首个数据字节的 index + 数据长度，也表示所期望收到的下一个序列号。")]),t._v(" "),a("p",[t._v("只有 ACK 字段被置位（为 1）时，确认号字段才有意义。")]),t._v(" "),a("p",[t._v("发送端和接收端一段建立起连接，ACK 标志总被设置为 1...")]),t._v(" "),a("p",[t._v("第一个报文的序列号是从 0 开始的吗？显然不是！第一个序列号被称为初识序列号（ISN，Initial Sequence Number），它是一个 32 bit 无符号值，不同系统获取的方式不同，基本上都与时间相关。")]),t._v(" "),a("h3",{attrs:{id:"如何理解-syn-报文和-fin-报文，为什么它们都消耗一个序列号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何理解-syn-报文和-fin-报文，为什么它们都消耗一个序列号"}},[t._v("#")]),t._v(" 如何理解 SYN 报文和 FIN 报文，为什么它们都消耗一个序列号")]),t._v(" "),a("p",[t._v("SYN 是 Synchronize Sequence Numbers 的缩写，顾名思义，SYN 包是用来同步序列号的。FIN 是 Finish 的缩写，表示完成发送任务。")]),t._v(" "),a("p",[t._v("令我非常疑惑的是为什么 SYN 和 FIN 报文都会消耗一个序列号，因为它们本身并没有携带数据。")]),t._v(" "),a("p",[t._v("搜索了一下网络上的说法，靠谱的答案很少，有两个可以参考一下："),a("a",{attrs:{href:"https://www.zhihu.com/question/24792770",target:"_blank",rel:"noopener noreferrer"}},[t._v("tcp 协议中为什么 syn 会消耗一个序号"),a("OutboundLink")],1),t._v("和"),a("a",{attrs:{href:"http://blog.sina.com.cn/s/blog_93b45b0f0101r4ty.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("为什么 SYN 和 FIN 会占一个序列号"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"如何理解-ack-报文，它消耗序列号吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何理解-ack-报文，它消耗序列号吗"}},[t._v("#")]),t._v(" 如何理解 ACK 报文，它消耗序列号吗")]),t._v(" "),a("p",[t._v("不像 SYN 报文和 FIN 报文，ACK 报文本身不消耗序列号，如果 ACK 消耗一个序列号，这意味着还要对 ACK 报文进行 ack，这是一件非常奇怪的事情，TCP 协议不对 ACK 报文进行 ACK。")]),t._v(" "),a("p",[t._v("TCP 可以表述为一个没有选择确认或否认滑动窗口协议（摘自《TCP/IP 详解 卷 1》，感觉翻译挺差劲）。挺拗口的一句话，举例来说明：")]),t._v(" "),a("ul",[a("li",[t._v("如果接收端已经成功收到 1~1024 个字节的报文，下一个接收的报文是 2049~3072 字节，接收端如何 ack？它不会对这个报文进行选择确认，所能做的是发回一个确认号为 1025（而不是 3073）的 ACK 报文")]),t._v(" "),a("li",[t._v("如果接收端已经成功收到 1025~2048 字节的报文，但是它的检验和出错，那么，它会返回一个确认号为 1025 的 ACK 报文")])]),t._v(" "),a("h3",{attrs:{id:"如何理解-ugc、psh、rst"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何理解-ugc、psh、rst"}},[t._v("#")]),t._v(" 如何理解 UGC、PSH、RST")]),t._v(" "),a("p",[t._v("这几个标志位没那么常见，还没详细分析他们意义，唯一确定的是它们和 ASK 报文一样，不消耗序列号。")]),t._v(" "),a("h3",{attrs:{id:"mss-选项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mss-选项"}},[t._v("#")]),t._v(" MSS 选项")]),t._v(" "),a("p",[t._v("最大报文长度（Maximum Segment Size，MSS）表示 TCP 传往另一端的最大块数据长度。TCP 报文中并没有为 MSS 安排特别的字段，TCP 双方往往将 MSS 信息写在「选项」字段中。值得一提的是，MSS 信息只能出现在 SYN 报文段中。根据《TCP/IP 详解 卷 1》的描述，MSS 的默认值是 536 字节。")]),t._v(" "),a("p",[t._v("MSS 是 TCP 报文的长度，还是 TCP 数据部分的长度？维基百科的词条"),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Maximum_segment_size",target:"_blank",rel:"noopener noreferrer"}},[t._v("MSS"),a("OutboundLink")],1),t._v("表示，它并不包含 TCP 首部长度。")]),t._v(" "),a("h1",{attrs:{id:"三次握手和四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三次握手和四次挥手"}},[t._v("#")]),t._v(" 三次握手和四次挥手")]),t._v(" "),a("h2",{attrs:{id:"建立连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#建立连接"}},[t._v("#")]),t._v(" 建立连接")]),t._v(" "),a("p",[t._v("三次握手的时间序列图，任谁都能粗略画出来，下图 copy 自"),a("a",{attrs:{href:"http://www.tcpipguide.com/free/t_TCPConnectionEstablishmentProcessTheThreeWayHandsh-3.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("The TCP/IP Guide"),a("OutboundLink")],1),t._v("：")]),t._v(" "),a("e-img",{attrs:{src:"/image/draft/tcp-open-3-way.png",ignore2x:!0}}),t._v(" "),a("p",[t._v("如果图中的 Client 和 Server 被淡化，直接以 A 和 B 表示会更好。")]),t._v(" "),a("p",[t._v("下面以 Q/A 的形式对这张图进行解析。")]),t._v(" "),a("h3",{attrs:{id:"syn-ack-是两个报文吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#syn-ack-是两个报文吗"}},[t._v("#")]),t._v(" SYN+ACK 是两个报文吗")]),t._v(" "),a("p",[t._v("这个问题显然很好回答，第二次握手的报文是一个报文，只是这个报文的 SYN 标志位和 ACK 标志位都被置位，因此称为「SYN+ACK」报文。")]),t._v(" "),a("h3",{attrs:{id:"为什么是三次握手，而不是两次或四次呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么是三次握手，而不是两次或四次呢"}},[t._v("#")]),t._v(" 为什么是三次握手，而不是两次或四次呢")]),t._v(" "),a("p",[t._v("这个问题，在"),a("a",{attrs:{href:"https://www.zhihu.com/question/24853633",target:"_blank",rel:"noopener noreferrer"}},[t._v("知乎"),a("OutboundLink")],1),t._v("下有非常精彩的回答。")]),t._v(" "),a("p",[t._v("握手的目的是啥？握手的目的是在发送端和接收端之间建立起连接，从技术上讲，目的是同步双方的 ISN。信道是不可靠的，为了让同步 ISN 的过程可靠，需要在某一方发送 SYN 报文后，另一方以 ACK 报文回应。")]),t._v(" "),a("p",[t._v("如果是两次握手，这就意味着 Server 端发送的 SYN 报文没有得到有效的 ACK 回应，造成的问题可以以一个例子说明：")]),t._v(" "),a("blockquote",[a("p",[t._v("client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用三次握手，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用三次握手的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。")])]),t._v(" "),a("p",[t._v("那么为什么不是四次握手呢？这个问题的实质是为什么第二次握手的报文 SYN 和 ACK 报文可以合并为一个报文。我的理解，四次握手显然是可以的，但是合并了也没啥问题，毕竟 ACK 报文不消耗序列号，只是需要将 ACK 标志位置位，然后在首部填写正确的确认号即可；而 SYN 报文的最重要负载 – ISN 是放在序列号段的，和确认号彼此独立，完全没有影响。")]),t._v(" "),a("h3",{attrs:{id:"client-在哪个阶段可以给-server-发送数据呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#client-在哪个阶段可以给-server-发送数据呢"}},[t._v("#")]),t._v(" Client 在哪个阶段可以给 Server 发送数据呢")]),t._v(" "),a("p",[t._v("Client 接收到 SYN+ACK 报文（第二次握手报文）并确定合法时，状态便变为 ESTABLISHED，此时就可以向 Server 发送数据了。对于 Server，也类似，在 ESTABLISHED 状态下才可以向 Client 数据报文。")]),t._v(" "),a("h3",{attrs:{id:"client-给-server-发送数据时，它还没准备好怎么办"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#client-给-server-发送数据时，它还没准备好怎么办"}},[t._v("#")]),t._v(" Client 给 Server 发送数据时，它还没准备好怎么办")]),t._v(" "),a("p",[t._v("Client 在 ESTABLISHED 状态时给 Server 发送数据，但是 Server 此时还未收到 ACK 报文（第三次握手），它会如何处理先到的 ACK 报文？")]),t._v(" "),a("p",[t._v("没有找到答案，我的理解是 Server 会将报文保存，直到进入了 ESTABLISHED。换句话说，对于 Client，进入 SYN-SENT 后就可以接收数据了；对于 Server，进入 SYN-RECEIVED 后就可以接收数据了。")]),t._v(" "),a("h3",{attrs:{id:"重新发起连接时，isn-是否会发生变化呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重新发起连接时，isn-是否会发生变化呢"}},[t._v("#")]),t._v(" 重新发起连接时，ISN 是否会发生变化呢")]),t._v(" "),a("p",[t._v("这个问题的本意是，当 Client 发送的 SYN 报文没有在预定时间内得到响应时，会重新发起 SYN 报文，此时 ISN 还会变化吗？")]),t._v(" "),a("p",[t._v("我的理解是，SYN 报文重发时，会获取一个新的 ISN。")]),t._v(" "),a("p",[t._v("P.S: 《TCP/IP 详解 卷 1》18.3 章节的示例图似乎暗示着重发 SYN 报文并不会使用新的 ISN...")]),t._v(" "),a("h3",{attrs:{id:"握手过程中各个报文的序列号和确认号都是如何变化的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#握手过程中各个报文的序列号和确认号都是如何变化的"}},[t._v("#")]),t._v(" 握手过程中各个报文的序列号和确认号都是如何变化的")]),t._v(" "),a("p",[t._v("理解了「SYN 报文需要消耗一个序列号」这个事实，这个问题很容易回答，下面的图摘自《TCP/IP 详解 卷 1》第十八章，算作参考：")]),t._v(" "),a("e-img",{attrs:{src:"/image/draft/tcp-ack-number.png"}}),t._v(" "),a("h3",{attrs:{id:"如何理解连接建立的超时"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何理解连接建立的超时"}},[t._v("#")]),t._v(" 如何理解连接建立的超时")]),t._v(" "),a("p",[t._v("当发起 SYN 报文时，会建立一个定时器，定时器超时却没有收到对方的 SYN+ACK 报文时，会重发 SYN 报文。下图是《TCP/IP 详解 卷 1》中的一个建立超时连接的输出图：")]),t._v(" "),a("e-img",{attrs:{src:"/image/draft/tcp-timeout.png"}}),t._v(" "),a("p",[t._v("可以看到，超时定时器的时间间隔并不是一定的...")]),t._v(" "),a("h2",{attrs:{id:"关闭连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关闭连接"}},[t._v("#")]),t._v(" 关闭连接")]),t._v(" "),a("p",[t._v("四次挥手的时间序列图如下：")]),t._v(" "),a("e-img",{attrs:{src:"/image/draft/tcp-close-4-way.png",ignore2x:!0}}),t._v(" "),a("p",[t._v("对这几次握手进行简单说明：")]),t._v(" "),a("p",[t._v("1、第一次挥手：Client 接到上层应用关闭连接的通知，发送一个 FIN 报文，并进入 FIN_WAIT_1 状态，该状态下 Client 不再发送数据报文；")]),t._v(" "),a("p",[t._v("2、第二次挥手：Server 接到来自 Client 的 FIN 报文，响应 ACK，进入 CLOSE_WAIT 状态，该状态意味着不再接收来自 Client 的数据报文；")]),t._v(" "),a("p",[t._v("3、第三次挥手：Server 也接到上层应用关闭连接的通知，发起一个 FIN 报文，进入 LAST_ACK 状态，该状态意味着 Server 不再发送数据报文；")]),t._v(" "),a("p",[t._v("4、第四次挥手：Client 接收到 Server 的 FIN 报文，响应 ACK，并在两个 MSL 后关闭连接；")]),t._v(" "),a("blockquote",[a("p",[t._v("收到 FIN 意味着对方不再发送数据报文了，但是如果仍然有数据报文来了，该如何处理？想必这和具体的实现有关吧，我估摸着直接抛弃。")])]),t._v(" "),a("h3",{attrs:{id:"为什么是四次挥手，而不是三次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么是四次挥手，而不是三次"}},[t._v("#")]),t._v(" 为什么是四次挥手，而不是三次")]),t._v(" "),a("p",[t._v("为什么终止一个连接需要 4 次握手呢？这与 TCP 的半关闭（half-close）策略有关。TCP 是全双工协议，数据在两个方向上都能同时传输，每个方向都必须要单独进行关闭。")]),t._v(" "),a("p",[t._v("简单来说，对于被动关闭的一端（上图中的 Server）来说，当它收到 FIN 报文后，它仍然可以发送数据报文，因此不宜将第二次握手和第三次握手合并。")]),t._v(" "),a("h3",{attrs:{id:"第一次挥手的-fin-报文可以和数据报文的-ack-一起发送吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第一次挥手的-fin-报文可以和数据报文的-ack-一起发送吗"}},[t._v("#")]),t._v(" 第一次挥手的 FIN 报文可以和数据报文的 ACK 一起发送吗")]),t._v(" "),a("p",[t._v("我认为是可以的，但是没找到权威的说明...")]),t._v(" "),a("h3",{attrs:{id:"双方各个阶段如何不能发送消息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双方各个阶段如何不能发送消息"}},[t._v("#")]),t._v(" 双方各个阶段如何不能发送消息")]),t._v(" "),a("p",[t._v("对于双方来说，连接关闭的各个节点分别是啥呢？")]),t._v(" "),a("h2",{attrs:{id:"tcp-的状态机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-的状态机"}},[t._v("#")]),t._v(" TCP 的状态机")]),t._v(" "),a("p",[t._v("上文在阐述建立连接和断开连接的时间序列图时，陆陆续续谈到了一些 TCP 状态，下图是基于这些状态的状态转换图（摘自《TCP/IP 详解 卷 1》：")]),t._v(" "),a("e-img",{attrs:{src:"/image/draft/tcp-state-machine.png"}}),t._v(" "),a("h3",{attrs:{id:"如何理解-2msl-等待时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何理解-2msl-等待时间"}},[t._v("#")]),t._v(" 如何理解 2MSL 等待时间")]),t._v(" "),a("p",[t._v("在断开连接中，主动发起连接的那方，在发送最后一个 ACK 后，进入 TIME_WAIT 状态，该状态又被称为「2MSL 等待状态」。")]),t._v(" "),a("p",[t._v("MSL（Maximum Segment Lifttime），它描述的是报文在网络中最大的生存时间，它经常和 TTL、RTT 拿来一起分析，它的更详细意义就不展开讨论了...")]),t._v(" "),a("p",[t._v("之所以在 TIME_WAIT 后还定义 2MSL 的等待时间，主要目的是为了 TCP 还有机会再次发送最后的 ACK 以防这个 ACK 丢失（另一端超时并重发最后的 FIN）。")]),t._v(" "),a("p",[t._v("另一个需要说明的是，TCP 连接的端口号在 TIME_WAIT 之后的 2MSL 后（即 CLOSE）后才会被回收。")]),t._v(" "),a("p",[t._v("一个常见的问题是：2MSL 真能确保另一方收到最后的 ACK 吗？我的理解是不能，2MSL 的意义是为了提高这种可能，当然，等待时间越长，对方收到最后的 ACK 的可能性越高，但是 2MSL 是 TCP 的忍耐时间，表示老夫已经仁至义尽了。")]),t._v(" "),a("h3",{attrs:{id:"tcp-连接会不会永远处于-fin-wait-2-状态呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-连接会不会永远处于-fin-wait-2-状态呢"}},[t._v("#")]),t._v(" TCP 连接会不会永远处于 FIN_WAIT_2 状态呢")]),t._v(" "),a("p",[t._v("当主动关闭发起端发起 FIN 报文，并收到对方的 ACK 报文时，它会进入 FIN_WAIT_2 状态，之后便等待对方发送 FIN 报文以进入 TIME_WAIT 状态。但问题是，如果对方不再发送 FIN 报文了呢？岂不是要永远处于 FIN_WAIT_2 状态？")]),t._v(" "),a("p",[t._v("为了避免永远处于 FIN_WAIT_2 状态的问题，一般的实现都为此定义了超时时间，不同的实现定义的超时时间都是不一样的，并且大部分系统 api 都提供了参数留给用户自己配置。譬如伯克利的实现，如果这个状态保持了 10 分钟 75 秒，就会被设置为 CLOSED 状态（来自《TCP/IP 详解 卷 1》的说法）。")]),t._v(" "),a("h3",{attrs:{id:"如何理解-last-ack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何理解-last-ack"}},[t._v("#")]),t._v(" 如何理解 LAST_ACK")]),t._v(" "),a("p",[t._v("上面已经提到，没办法确保被动关闭的一端一定能收到最后的 ACK，那么在极端情况下，会不会导致 TCP 永远处于 LAST_ACK 状态？")]),t._v(" "),a("p",[t._v("没有找到比较权威的说法，根据网上各种各样的说法，我的判断是：不同的实现导致结果不一样。也就是说，TCP 协议并未为此定义所谓的定时器时间。")]),t._v(" "),a("h1",{attrs:{id:"可靠性保证"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可靠性保证"}},[t._v("#")]),t._v(" 可靠性保证")]),t._v(" "),a("ul",[a("li",[t._v("包编号：TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。")]),t._v(" "),a("li",[t._v("校验和：TCP 将保持它首部和数据的检验和；这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。")]),t._v(" "),a("li",[t._v("超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。")])]),t._v(" "),a("h1",{attrs:{id:"滑动窗口与拥塞控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口与拥塞控制"}},[t._v("#")]),t._v(" 滑动窗口与拥塞控制")]),t._v(" "),a("h1",{attrs:{id:"相关攻击"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关攻击"}},[t._v("#")]),t._v(" 相关攻击")]),t._v(" "),a("h2",{attrs:{id:"半连接攻击-syn-泛洪"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#半连接攻击-syn-泛洪"}},[t._v("#")]),t._v(" 半连接攻击: SYN 泛洪")]),t._v(" "),a("p",[t._v("半连接攻击是一种攻击协议栈的攻击方式，坦白说就是攻击主机的一种攻击方式。通过将主机的资源消耗殆尽，从而导致应用层的程序无资源可用，导致无法运行。在正常情况下，客户端连接服务端需要通过三次握手，首先客户端构造一个 SYN 连接数据包发送至服务端，自身进入 SYN_SEND 状态，当服务端收到客户端的 SYN 包之后，为其分配内存核心内存，并将其放置在半连接队列中，服务端接收客户 SYN 包并会向客户端发送一个SYN包和ACK包，此刻服务端进入 SYN_RECV 态。客户端收到包之后，再次向服务端发送 ACK 确认包。至此连接建立完成，双方都进入 ESTABLSHED 状态。半连接就是通过不断地构造客户端的SYN连接数据包发向服务端，等到服务端的半连接队列满的时候，后续的正常用户的连接请求将会被丢弃，从而无法连接到服务端。此为半连接攻击方式。根据服务端的半连接队列的大小，不同主机的抵抗这种SYN攻击的能力也是不一样。")]),t._v(" "),a("p",[t._v("如何来解决半连接攻击？")]),t._v(" "),a("p",[t._v("可以通过拓展半连接队列的大小，来进行补救，但缺点是，不能无限制的增加，这样会耗费过多的服务端资源，导致服务端性能地下。这种方式几乎不可取。现主要通syn cookie或者syn中继机制来防范半连接攻，部位半连接分配核心内存的方式来防范。")]),t._v(" "),a("h2",{attrs:{id:"全连接攻击"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全连接攻击"}},[t._v("#")]),t._v(" 全连接攻击")]),t._v(" "),a("p",[t._v("全连接攻击是通过消费服务端进程数和连接数，只连接而不进行发送数据的一种攻击方式。当客户端连接到服务端，仅仅只是连接，此时服务端会为每一个连接创建一个进程来处理客户端发送的数据。")]),t._v(" "),a("p",[t._v("如何来解决全连接攻击？")]),t._v(" "),a("p",[t._v("可以通过不为全连接分配进程处理的方式来防范全连接攻击，具体的情况是当收到数据之后，在为其分配一个处理线程。具体的处理方式在 accept 返回之前是不分配处理线程的。直到接收相关的数据之后才为之提供一个处理过程。")])],1)}),[],!1,null,null,null);r.default=_.exports}}]);