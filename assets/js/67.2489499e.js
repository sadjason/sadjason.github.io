(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{134:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("作为一个 iOS 开发者，必须要熟练使用 GCD，本文是站在实际应用的角度总结 GCD 的用法之一：使用 barrier 保护 property。")]),t._v(" "),a("p",[t._v("在多线程环境下，如果有多个线程要执行同一份代码，那么有时会出现问题，为了保证某些资源操作的可控性，需要一些手段来对这些公共资源进行保护，无论是什么语言，只要支持多线程，都得面临这个问题，即所谓的"),a("strong",[t._v("线程同步")]),t._v("问题。本文围绕 property 讨论各种"),a("strong",[t._v("同步工具")]),t._v("的保护效果，这同样可以延伸到其他需要保护的公共资源上。")]),t._v(" "),a("h2",{attrs:{id:"atomic-保护-property"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#atomic-保护-property"}},[t._v("#")]),t._v(" atomic 保护 property")]),t._v(" "),a("p",[t._v("维持 property 原子操作的最简单的保护措施是为其添加"),a("code",[t._v("atomic")]),t._v("修饰词，这样编译器在为其生成 setter 和 getter 时对其进行原子保护。问题来了，对于使用"),a("code",[t._v("atomic")]),t._v("修饰的 property，编译器为其生成的 getter 和 setter 是什么样子的呢？在很长时间里，由于受到不靠谱网友的误导，以为是这样：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("lock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 上锁")]),t._v("\n    _ret "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" _name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// get name")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("unlock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 释放锁")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" _ret"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n \n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("setName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("newName "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("lock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 上锁")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("set name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// set name")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("unlock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 释放锁")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("看来认真看了 Apple 官方文档"),a("a",{attrs:{href:"https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Threading Programming Guide"),a("OutboundLink")],1),t._v("，意识到这种说法是错误的。Apple 的原子操作的底层实现并不是基于锁的，具体是什么样子呢？我也不知道，但肯定不是如上这样的（以后有时间深入了解一下，希望能够找到答案吧）。")]),t._v(" "),a("p",[t._v("那么修饰词"),a("code",[t._v("atomic")]),t._v("靠谱吗？它能保证相关属性 getter 和 setter 的原子性吗？能信赖它吗？")]),t._v(" "),a("p",[t._v("根据我的理解，不太靠谱。对于某个被"),a("code",[t._v("atomic")]),t._v("修饰的属性，当完全依赖于编译器自动合成 getter 和 setter 时，相信它们的原子性能够得到保证（不管它是如何合成实现的）；但是我们常常免不了自己动手写 setter 或者 getter，此时会将系统默认合成的 setter 或 getter 给覆盖掉，我们自己的代码能够保证原子性吗？如果我们只是自己实现 setter 和 getter 中的其中一个，另外一个依赖于编译器合成，那么自定义的这个该如何实现呢？")]),t._v(" "),a("p",[t._v("种种问题外加种种不确定，导致了在 iOS 开发中几乎不使用"),a("code",[t._v("atomic")]),t._v("修饰符（至少没在著名第三方库中看到使用它修饰属性的案例）。")]),t._v(" "),a("p",[t._v("P.S: 这种说法纯属一家之言，以后补充更靠谱的佐证吧！")]),t._v(" "),a("h2",{attrs:{id:"nslock-保护-property"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nslock-保护-property"}},[t._v("#")]),t._v(" NSLock 保护 property")]),t._v(" "),a("p",[t._v("上文的代码块恰好是互斥锁（"),a("code",[t._v("NSLock")]),t._v("）或者递归锁（"),a("code",[t._v("NSRecursiveLock")]),t._v("）保护 property 的基本套路，为了方便说明，再次罗列如下：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("lock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 上锁")]),t._v("\n    _ret "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" _name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// get name")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("unlock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 释放锁")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" _ret"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n \n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("setName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("newName "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("lock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 上锁")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("set name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// set name")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("unlock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 释放锁")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("根据我的理解，在一般情况下，"),a("code",[t._v("NSLock")]),t._v("是能够保证 property 原子性的。但根据《Effective Objective-C 2.0》的描述：一旦遇到死锁，就会非常麻烦。")]),t._v(" "),a("p",[t._v("什么情况下会出现死锁呢？我认为至少有这么一种情况：保护"),a("code",[t._v("name")]),t._v("属性的锁在其他地方也被使用了，即当前线程正在持有该锁，此时正在访问别处的某个公共资源，保护该资源的锁正被另外一个线程持有，而那个线程正在获取当前线程持有的这把锁...")]),t._v(" "),a("p",[t._v("当然，对于属性而言，这种情况过于极端，但如果"),a("code",[t._v("NSLock")]),t._v("保护的不是属性而是别的更复杂的公共资源，那么这种极端情况就不是那么极端了；再者，如果保护"),a("code",[t._v("name")]),t._v("属性的这把锁也被用来保护其他的资源，那么问题就变得更复杂了。")]),t._v(" "),a("p",[t._v("总之，根据我的理解，如果确实需要使用"),a("strong",[t._v("锁")]),t._v("保护 property，要做到：")]),t._v(" "),a("ul",[a("li",[t._v("尽量使用"),a("code",[t._v("NSRecursiveLock")]),t._v("，避免多次持有该锁造成死锁")]),t._v(" "),a("li",[t._v("每个属性有一个单独的锁为之服务，不可与别的资源共用，否则问题会变得更复杂")])]),t._v(" "),a("p",[t._v("P.S: 《Effective Objective-C 2.0》中关于"),a("code",[t._v("NSLock")]),t._v("保护 property 的这部分内容讲得非常不到位，以上纯属个人理解！")]),t._v(" "),a("h2",{attrs:{id:"synchronized-块保护属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-块保护属性"}},[t._v("#")]),t._v(" @synchronized 块保护属性")]),t._v(" "),a("p",[t._v("所谓"),a("code",[t._v("@synchronized")]),t._v("块在中文世界里常被称为"),a("strong",[t._v("同步块")]),t._v("，根据 Threading Programming Guide 的描述，"),a("strong",[t._v("同步块")]),t._v("是使用"),a("strong",[t._v("同步锁")]),t._v("的简写形式，本质仍然是使用同步锁保护公共资源。同步块保护属性的一般形式是：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("setSomeString"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("someString "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("synchronized")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        _someString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" someString"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n \n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("someString "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("synchronized")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" _someString"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("这种做法有什么问题呢？相对于"),a("code",[t._v("NSLock")]),t._v("，这种处理问题更大！主要问题是："),a("code",[t._v("@synchronized(self)")]),t._v("效率极低。")]),t._v(" "),a("p",[t._v("根据《Effective Objective-C 2.0》的说法。因为"),a("code",[t._v("@synchronized(){}")]),t._v("的本质是根据给定的对象，自动创建一个锁，并等待块中的代码执行完毕。执行到这段代码结尾处，锁就被释放了。通常传给"),a("code",[t._v("@synchronized")]),t._v("块的对象是"),a("code",[t._v("self")]),t._v("。这意味着同步锁将"),a("code",[t._v("self")]),t._v("整个对象都保护起来了，如果滥用，其他属性也都用"),a("code",[t._v("@synchronized(self){}")]),t._v("这种方式确保原子性，这样在"),a("code",[t._v("self")]),t._v("对象上频繁加锁，那么程序可能要等待另一段与此无关的代码执行完毕，才能继续执行当前代码，这显然会降低代码效率。")]),t._v(" "),a("h2",{attrs:{id:"gcd-串行队列保护-property"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gcd-串行队列保护-property"}},[t._v("#")]),t._v(" GCD 串行队列保护 property")]),t._v(" "),a("p",[t._v("将对 property 的读写方法都安排在同一个队列中，即可保证数据同步，如下：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@property")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nonatomic"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" strong"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@property")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nonatomic"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" strong"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" dispatch_queue_t serialQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@synthesize")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" _name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// create a serial dispatch queue")]),t._v("\n_serialQueue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_queue_create")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"com.zhangbuhuai.test"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nil"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// getter")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    __block NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("localName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_sync")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("_serialQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        localName "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" _name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" localName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// setter")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("setName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_sync")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("_serialQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        _name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("此模式的思路是：把 setter 和 getter 都安排在序列化的队列里执行，这样的话，所有针对属性的访问就都同步了。为了使代码块能够设置局部变量，getter 中用到了"),a("code",[t._v("__block")]),t._v("关键字，若是抛开这一点，这种写法比之前的那些更为整洁。全部加锁任务都在 GCD 中处理，而 GCD 是在相当深的底层来实现的，于是能够做许多优化。因此，开发者无需担心那些事，只要专心把访问方法写好就行了。")]),t._v(" "),a("p",[t._v("然而，"),a("strong",[t._v("还可以进一步优化，毕竟 setter 方法不一定非得是同步的。设置实例变量所用的 block，并不需要向 setter 返回什么值")]),t._v("。")]),t._v(" "),a("p",[t._v("也就是说，setter 代码可以改成下面这样：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// setter")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("setName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_async")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("_serialQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        _name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("这次只是把同步派发改成了异步派发，从调用者的角度来看，这个小改动可以提升设置方法的执行速度（毕竟直接返回而不用等待 block 执行完成），而读取操作与写入操作依然会按顺序执行。但是这么改有一个坏处：如果测试一下程序的性能，那么可能发现这种写法比原来慢，因为执行异步派发时，需要拷贝 block。若拷贝 block 所用的时间明显超过执行块所用时间，则这种做法将比原来更慢。")]),t._v(" "),a("p",[t._v("所以，setter 的 block 设置为 asynchronous 或者 synchronous，得看 setter 的 block 的复杂度。")]),t._v(" "),a("h2",{attrs:{id:"gcd-并行队列和-barrier-保护-property"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gcd-并行队列和-barrier-保护-property"}},[t._v("#")]),t._v(" GCD 并行队列和 barrier 保护 property")]),t._v(" "),a("p",[t._v("其实在更多的时候，调用 getter 可以并发执行，而 getter 和 setter 之前不能并发执行。利用这个特点，还能写一些更快一些的代码。此时正可以体现出 GCD 写法的好处。用同步块或锁对象，是无法轻易实现出如下这种方案的，这次不用 serial dispatch queue，而改用并发队列：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@property")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nonatomic"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" strong"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@property")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nonatomic"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" strong"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" dispatch_queue_t concurrentQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@synthesize")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" _name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// create a concurrent dispatch queue")]),t._v("\n_concurrentQueue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_queue_create")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"com.zhangbuhuai.test"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// getter")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    __block NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("localName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_sync")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("_concurrentQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        localName "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" _name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" localName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// setter")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("setName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_async")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("_concurrentQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        _name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("然而，如上这样的代码，还无法正确实现同步。所有读取操作与写入操作都会在同一个队列上执行，不过由于是并发队列，所以读取与写入操作可能随时执行。而我们恰恰不想让这些操作随意执行。此问题用一个简单的 GCD 功能即可解决，它就是栅栏（barrier）。下列函数可以向队列中派发块，将其作为栅栏使用：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_barrier_sync")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dispatch_queue_t queue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" dispatch_block_t block"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_barrier_async")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dispatch_queue_t queue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" dispatch_block_t block"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("在队列中，栅栏块必须单独执行，不能与其他块并行。这只对并发队列有意义，因为串行队列中的块总是按顺序逐个来执行的。并发队列如果发现接下来的要处理的 block 是 barrier block，那么就一直要等当前所有并发块都执行完毕，才会单独执行这个栅栏块。待栅栏块执行完成后，再按正常方式继续向下执行。")]),t._v(" "),a("p",[t._v("在本例中，可以用栅栏块来实现属性的 setter 方法。在设置方法中使用了栅栏块之后，对属性的读取操作依然可以并发执行，但是写入操作却必须单独执行了，如下图所示：")]),t._v(" "),a("e-img",{attrs:{src:"/image/barrier_block.png",retina:""}}),t._v(" "),a("p",[t._v("代码实现很简单：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@property")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nonatomic"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" strong"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@property")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nonatomic"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" strong"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" dispatch_queue_t concurrentQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@synthesize")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" _name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// create a concurrent dispatch queue")]),t._v("\n_concurrentQueue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_queue_create")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"com.zhangbuhuai.test"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// getter")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    __block NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("localName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_sync")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("_concurrentQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        localName "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" _name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" localName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// setter")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("setName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_barrier_async")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("_concurrentQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        _name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("测试一下性能，就会发现，这种做法肯定比使用串行队列要快。当然，将上述代码中的"),a("code",[t._v("dispatch_barrier_async")]),t._v("改为"),a("code",[t._v("dispatch_barrier_sync")]),t._v("也是没问题的，也可能会更高效，至于原因上文已经讲到了。在实际使用时，最好还是测一测每种做法的性能，然后从中选出最适合当前场景的方案。")]),t._v(" "),a("h2",{attrs:{id:"本文参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本文参考"}},[t._v("#")]),t._v(" 本文参考")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://book.douban.com/subject/21370593/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Effective Objective-C 2.0"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Threading Programming Guide"),a("OutboundLink")],1)])])],1)}),[],!1,null,null,null);s.default=e.exports}}]);