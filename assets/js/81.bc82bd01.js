(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{173:function(t,e,a){"use strict";a.r(e);var n=a(0),s=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("15 年，刚开始接触 runtime 的时候，记录过消息转发相关的博客，最近做需求涉及到了一些消息转发相关的内容，得闲将旧博客翻出来重新梳理了一下。")]),t._v(" "),a("p",[t._v("为什么标题含有「NSObject」关键字眼呢？因为本文叙述的消息转发机制是针对"),a("code",[t._v("NSObject")]),t._v("对象；在我看来，Objective-C 世界里的另一个根类"),a("code",[t._v("NSProxy")]),t._v("的消息转发逻辑和"),a("code",[t._v("NSObject")]),t._v("完全不同。")]),t._v(" "),a("p",[t._v("P.S: 如果没有特别说明，本文的"),a("code",[t._v("NSObject")]),t._v("指的是"),a("code",[t._v("class NSObject")]),t._v("，而不是"),a("code",[t._v("protocol NSObject")]),t._v("。")]),t._v(" "),a("p",[t._v("如下这张取自《Effective Objective-C 2.0》的图片描述了"),a("code",[t._v("NSObject")]),t._v("对象的消息转发全流程：")]),t._v(" "),a("e-img",{attrs:{src:"/image/QQ20150427-1.png"}}),t._v(" "),a("p",[t._v("简单来说，当一个 OC 对象（receiver）接收到 Unknown selector 时，会进入如图流程，用户可以在这三个步骤中 override receiver 的相关方法，进而避免"),a("code",[t._v("doesNotRecognizeSelector:")]),t._v("异常。")]),t._v(" "),a("p",[t._v("这三次处理时机有何区别呢？《Effective Objective-C 2.0》的描述是：")]),t._v(" "),a("blockquote",[a("p",[t._v("步骤越往后，处理消息的代价就越大；最好能在第一步就处理完，这样的话，runtime 系统就可以将此方法缓存起来，进而提高效率。若想在第三步里把消息转发给备援的 receiver，那还不如把转发操作提前到第二步。因为第三步只是修改了调用目标，这项改动放在第二步会更为简单，不然的话，还得创建并处理完整的"),a("code",[t._v("NSInvocation")]),t._v("。")])]),t._v(" "),a("p",[t._v("本文旨在梳理这三个步骤。")]),t._v(" "),a("h2",{attrs:{id:"resolveinstancemethod"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#resolveinstancemethod"}},[t._v("#")]),t._v(" +resolveInstanceMethod")]),t._v(" "),a("p",[t._v("Receiver 在收到 unknown selector 后，首先将调用其本类的"),a("code",[t._v("resolveInstanceMethod:")]),t._v("方法，该方法定义如下：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("BOOL"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("resolveInstanceMethod"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("SEL"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("sel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("该方法的参数就是那个 unknown selector，其返回值为"),a("code",[t._v("Boolean")]),t._v("类型，表示这个类是否能新增一个实例方法用以处理该 unknown selector。在继续往下执行转发机制之前，本类有机会新增一个处理此 selector 的方法。所以"),a("code",[t._v("resolveInstanceMethod:")]),t._v("的一般使用套路是：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("BOOL"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("resolveInstanceMethod"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("SEL"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("aSelector "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* aSelector满足某个条件  */")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/*\n         调用class_addMethod为该类添加一个处理aSelector的方法，譬如：\n         class_addMethod(self, aSelector, aImp, @"v@:@");\n         */')]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" YES"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),t._v(" resolveInstanceMethod"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("aSelector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("假如尚未实现的方法不是实例方法而是类方法，那么 runtime 系统会调用另外一个与"),a("code",[t._v("resolveInstanceMethod:")]),t._v("类似的方法"),a("code",[t._v("resolveClassMethod:")]),t._v("。")]),t._v(" "),a("p",[t._v("就我经验而言，"),a("code",[t._v("resolveInstanceMethod:")]),t._v("的使用场景一般用来动态添加 setter 和 getter。")]),t._v(" "),a("h2",{attrs:{id:"forwardingtargetforselector"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#forwardingtargetforselector"}},[t._v("#")]),t._v(" -forwardingTargetForSelector")]),t._v(" "),a("p",[t._v("当前 receiver 还有第二次机会能处理 unknown selector，在这一步中，runtime 系统会问它：可否把这条消息转给其他对象处理？该步骤对应的处理方法是"),a("code",[t._v("forwardingTargetForSelector:")]),t._v("，定义于"),a("code",[t._v("<objc/NSObject.h>")]),t._v("中：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("forwardingTargetForSelector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("SEL"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("aSelector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("若当前 receiver 能找到备援对象，则将其返回，当然，备援对象必须能够响应 aSelector，否则依然会抛出"),a("code",[t._v("doesNotRecognizeSelector:")]),t._v("异常；若找不到，则返回"),a("code",[t._v("nil")]),t._v("。")]),t._v(" "),a("p",[a("code",[t._v("-forwardingTargetForSelector:")]),t._v("的使用逻辑非常简单，应用场景包括：")]),t._v(" "),a("ul",[a("li",[t._v("实现多继承。Objective-C 不允许多继承，基于"),a("code",[t._v("-forwardingTargetForSelector:")]),t._v("，可以通过组合的方式，模拟出多继承的某些特性。")]),t._v(" "),a("li",[t._v("为协议遵循者提供默认实现。譬如某个协议定义了多个方法，有必要为这几个方法提供默认实现；具体做法是定义一个类（假设为 Implement），用于实现这几个方法，然后 override 协议遵循者的"),a("code",[t._v("-forwardingTargetForSelector:")]),t._v("方法，将协议方法的 receiver 定位到 Implement 对象。")])]),t._v(" "),a("h2",{attrs:{id:"forwardinvocation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#forwardinvocation"}},[t._v("#")]),t._v(" -forwardInvocation")]),t._v(" "),a("p",[a("code",[t._v("-forwardInvocation:")]),t._v("要和"),a("code",[t._v("-methodSignatureForSelector:")]),t._v("配套使用，后者为"),a("code",[t._v("NSMethodSignature")]),t._v("对象，该对象携带 selector 的签名信息，包括参数类型、返回值类型和长度等。Runtime 内部会基于"),a("code",[t._v("NSMethodSignature")]),t._v("实例构建一个"),a("code",[t._v("NSInvocation")]),t._v("对象，作为回调"),a("code",[t._v("-forwardInvocation:")]),t._v("的入参。")]),t._v(" "),a("p",[t._v("P.S: 知道"),a("code",[t._v("NSMethodSignature")]),t._v("对象携带 selector 的签名信息一般就够了，彻底了解它还得搞清楚 type encodings，这东西挺没劲的，很少会和它打交道，更多信息参考"),a("a",{attrs:{href:"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),a("OutboundLink")],1),t._v("和"),a("a",{attrs:{href:"http://nshipster.com/type-encodings/",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("p",[t._v("只要回调"),a("code",[t._v("-methodSignatureForSelector:")]),t._v("的返回值不为空，就会进入"),a("code",[t._v("-forwardInvocation:")]),t._v("方法，用户可以在此过程中修改 invocation 的 target，将 receiver 定位到别处：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("forwardInvocation"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSInvocation "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("invocation "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("invocation setTarget"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("target"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 让self.target成为消息的receiver")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("invocation invoke"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("值得一提的是，除了修改 receiver，还可以修改入参，甚至是返回值。"),a("code",[t._v("NSInvocation#invoke")]),t._v("会触发 receiver 的 selector 的调用，如果不想调用怎么办？没怎么办，只要确保 invocation 的返回值（"),a("code",[t._v("NSInvocation#setReturnValue:")]),t._v("）的类型和长度一致即可。")]),t._v(" "),a("p",[t._v("Unknown selector 触发的三个回调介绍完毕，简单总结一下。")]),t._v(" "),a("p",[t._v("就作用而言，"),a("code",[t._v("+resolveInstanceMethod:")]),t._v("主要用于为类动态增加实例方法；"),a("code",[t._v("-forwardingTargetForSelector:")]),t._v("用于将 selector 的 receiver 从"),a("code",[t._v("self")]),t._v("定位到别的 target；这两个方法的使用都比较直接简单，不太能整出花样。"),a("code",[t._v("-forwardInvocation:")]),t._v("就不同了，在它身上可以动的手脚比较多，不光可以修改 receiver，还可以篡改入参、返回值；当然，"),a("code",[t._v("-forwardInvocation:")]),t._v("的代价比较大一些，毕竟还会触发"),a("code",[t._v("-methodSignatureForSelector:")]),t._v("，构建"),a("code",[t._v("NSMethodSignature")]),t._v("和"),a("code",[t._v("NSInvocation")]),t._v("实例。")]),t._v(" "),a("p",[t._v("如果需要动态新增方法，可以在"),a("code",[t._v("+resolveInstanceMethod:")]),t._v("阶段完成；如果只是需要篡改 receiver，在"),a("code",[t._v("-forwardingTargetForSelector:")]),t._v("阶段完成更省事儿；如果需要更高阶的玩法，或许真的只有"),a("code",[t._v("-forwardInvocation:")]),t._v("能满足需求。")]),t._v(" "),a("h2",{attrs:{id:"一些应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一些应用场景"}},[t._v("#")]),t._v(" 一些应用场景")]),t._v(" "),a("p",[t._v("这一部分罗列一些简单而有意思的应用场景。")]),t._v(" "),a("h3",{attrs:{id:"可以接受任何消息的-nsnull"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可以接受任何消息的-nsnull"}},[t._v("#")]),t._v(" 可以接受任何消息的 NSNull")]),t._v(" "),a("p",[t._v("Objective-C 里的"),a("code",[t._v("nil")]),t._v("是个好东西，向它发送任何消息都不会导致"),a("code",[t._v("doesNotRecognizeSelector:")]),t._v("异常；然而，它不能作为集合类型的有效元素，也不能作为 nonnull 类型的入参或返回值。"),a("code",[t._v("NSNull")]),t._v("是表达「空」这一概念的另一种类型，但它的局限在于不能像"),a("code",[t._v("nil")]),t._v("一样安全接受任何消息。然而，基于"),a("code",[t._v("-forwardInvocation:")]),t._v("可以比较容易完成这一目标，即让"),a("code",[t._v("NSNull")]),t._v("能安全接受任何消息，代码如下：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@implementation")]),t._v(" NSNull "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Safe"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("forwardInvocation"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSInvocation "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("invocation "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),t._v(" respondsToSelector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("invocation selector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("invocation invokeWithTarget"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSMethodSignature "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("methodSignatureForSelector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("SEL"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("selector "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    NSMethodSignature "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("methodSignature "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSNull class"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" instanceMethodSignatureForSelector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("selector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("methodSignature"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        methodSignature "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSMethodSignature signatureWithObjCTypes"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"@:"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// `@:`是随便定义的有效type encodings")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" methodSignature"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@end")]),t._v("\n")])])]),a("p",[t._v("且不说这种设计的好坏，但它确实达到了目的：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("-methodSignatureForSelector:")]),t._v("的处理使得"),a("code",[t._v("NSNull")]),t._v("对象可以接受任何 selector 而不产生"),a("code",[t._v("doesNotRecognizeSelector:")]),t._v("异常")]),t._v(" "),a("li",[a("code",[t._v("-forwardInvocation:")]),t._v("的处理使得"),a("code",[t._v("NSNull")]),t._v("实例接受到 unknown selector 时，不做任何处理，即空操作")])]),t._v(" "),a("p",[t._v("更多有趣的应用场景，有待补充...")]),t._v(" "),a("p",[a("strong",[t._v("本文参考")])]),t._v(" "),a("ul",[a("li",[t._v("《Effective Objective-C 2.0》")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Message Forwarding"),a("OutboundLink")],1)])])],1)}),[],!1,null,null,null);e.default=s.exports}}]);