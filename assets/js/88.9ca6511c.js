(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{166:function(t,a,s){"use strict";s.r(a);var e=s(0),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[s("strong",[t._v("说明")])]),t._v(" "),s("p",[t._v("本文转自《"),s("a",{attrs:{href:"http://www.cocoachina.com/industry/20140605/8683.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("NSHashtable and NSMaptable"),s("OutboundLink")],1),t._v("》，其原作者是"),s("a",{attrs:{href:"http://nshipster.com/nshashtable-and-nsmaptable/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Mattt Thompson"),s("OutboundLink")],1),t._v("，该大神是 AFNetworking 的作者。作者简单介绍了一下 iOS 开发中相对于 NSDictionary 和 NSSet 来说，不常被人使用 NSHashTable 和 NSMapTable 的相关知识。")]),t._v(" "),s("blockquote",[s("p",[t._v("P.S: 笔者关注《"),s("a",{attrs:{href:"http://www.cocoachina.com/industry/20140605/8683.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("NSHashtable and NSMaptable"),s("OutboundLink")],1),t._v("》这篇博客的原因是因为以前遇到「如何实现 NSNotificationCenter」这样的问题，我意识到实现 NSNotificationCenter 的关键在于找到一个能够支持弱指针的容器，而 NSHashTable 和 NSMaptable 恰好是这样的容器。")])]),t._v(" "),s("p",[t._v("NSSet，NSDictionary，NSArray 是 Foundation 框架关于集合操作的常用类，和"),s("a",{attrs:{href:"http://en.wikipedia.org/wiki/Java_collections_framework",target:"_blank",rel:"noopener noreferrer"}},[t._v("其他标准的集合操作库"),s("OutboundLink")],1),t._v("不同，他们的实现方法对开发者进行"),s("a",{attrs:{href:"http://ridiculousfish.com/blog/posts/array.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("隐藏"),s("OutboundLink")],1),t._v("，只允许开发者写一些简单的代码，让他们相信这些代码有理由正常的工作。")]),t._v(" "),s("p",[t._v("然而这样的话最好的代码抽象风格就会被打破，苹果的本意也被曲解了。在这种情况下，开发者寻求更好的抽象方式来使用集合，或者说寻找一种更通用的方式。")]),t._v(" "),s("p",[t._v("对于 NSSet 和 NSDictionary，打破代码抽象风格的是他们在内存中存取 object 的方式。在 NSSet 中，objects 是被强引用的（strongly referenced），同样 NSDictionary 中的 keys 和 values 也会被 NSDictionary 复制。如果一个开发者想要存储一个 weak 类型的值或者使用一个没有实现 NSCopying 协议的 object 作为 NSDictionary 的 key，他可能会很聪明的想到"),s("a",{attrs:{href:"http://nshipster.com/nsvalue/",target:"_blank",rel:"noopener noreferrer"}},[t._v("NSValue+valueWithNonretainedObject"),s("OutboundLink")],1),t._v("。 iOS6 和 OSX 10.5 以后，可以分别使用和 NSSet，NSDictionary 地位相同的 NSHashTable，NSMapTable。")]),t._v(" "),s("p",[t._v("这两个类在 Foundation 的 collection 中不常用到，为了避免你慌乱无措，下面将介绍这两个类的用法。")]),t._v(" "),s("h2",{attrs:{id:"nshashtable"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nshashtable"}},[t._v("#")]),t._v(" NSHashTable")]),t._v(" "),s("p",[t._v("NSHashTable 是更广泛意义的 NSSet，区别于 NSSet/NSMutableSet，NSHashTable 有如下特性：")]),t._v(" "),s("ul",[s("li",[t._v("NSHashTable 是可变的；")]),t._v(" "),s("li",[t._v("NSHashTable 可以持有 weak 类型的成员变量；")]),t._v(" "),s("li",[t._v("NSHashTable 可以在添加成员变量的时候复制成员；")]),t._v(" "),s("li",[t._v("NSHashTable 可以随意的存储指针并且利用指针的唯一性来进行 hash 同一性检查（检查成员变量是否有重复）和对比操作（equal）；")])]),t._v(" "),s("p",[t._v("用法如下：")]),t._v(" "),s("div",{staticClass:"language-objectivec extra-class"},[s("pre",{pre:!0,attrs:{class:"language-objectivec"}},[s("code",[t._v("NSHashTable "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("hashTable "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSHashTable hashTableWithOptions"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("NSPointerFunctionsCopyIn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("hashTable addObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('@"foo"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("hashTable addObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('@"bar"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("hashTable addObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("@")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("hashTable removeObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('@"bar"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("NSLog")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('@"Members: %@"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("hashTable allObjects"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("NSHashTable 是根据一个 option 参数来进行初始化的，因为从 OSX 平台上移植到 iOS 平台上，原来 OSX 平台上使用的枚举类型被放弃了，从而用 option 来代替，命名也发生了一些变化：")]),t._v(" "),s("ul",[s("li",[t._v("NSHashTableStrongMemory")])]),t._v(" "),s("p",[t._v("等同于 NSPointerFunctionsStrongMemory。对成员变量进行强引用，这是一个默认值，如果采用这个默认值，NSHashTable 和 NSSet 就没什么区别了。")]),t._v(" "),s("ul",[s("li",[t._v("NSHashTableWeakMemory")])]),t._v(" "),s("p",[t._v("等同于 NSPointerFunctionsWeakMemory。对成员变量进行弱引用，使用 NSPointerFunctionsWeakMemory，object 引用在最后释放的时候会被指向 NULL。")]),t._v(" "),s("ul",[s("li",[t._v("NSHashTableZeroingWeakMemory")])]),t._v(" "),s("p",[t._v("已被抛弃，使用 NSHashTableWeakMemory 代替。")]),t._v(" "),s("ul",[s("li",[t._v("NSHashTableCopyIn")])]),t._v(" "),s("p",[t._v("在对象被加入集合之前进行复制（"),s("a",{attrs:{href:"https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSPointerFunctions_Class/index.html#//apple_ref/occ/instp/NSPointerFunctions/acquireFunction",target:"_blank",rel:"noopener noreferrer"}},[t._v("NSPointerFunction-acquireFunction"),s("OutboundLink")],1),t._v("），等同于 NSPointerFunctionsCopyIn。")]),t._v(" "),s("ul",[s("li",[t._v("NSHashTableObjectPointerPersonality")])]),t._v(" "),s("p",[t._v("用指针来等同代替实际的值，当打印这个指针的时候相当于调用 description 方法。和 NSPointerFunctionsObjectPointerPersonality 等同。")]),t._v(" "),s("h2",{attrs:{id:"nsmaptable"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nsmaptable"}},[t._v("#")]),t._v(" NSMapTable")]),t._v(" "),s("p",[t._v("NSMapTable 是对更广泛意义的 NSDictionary。和 NSDictionary/NSMutableDictionary 相比具有如下特性：")]),t._v(" "),s("ul",[s("li",[t._v("NSDictionary/NSMutableDictionary 会复制 keys 并且通过强引用 values 来实现存储；")]),t._v(" "),s("li",[t._v("NSMapTable 是可变的；")]),t._v(" "),s("li",[t._v("NSMapTable 可以通过弱引用来持有 keys 和 values，所以当 key 或者 value 被 deallocated 的时候，所存储的实体也会被移除；")]),t._v(" "),s("li",[t._v("NSMapTable 可以在添加 value 的时候对 value 进行复制；")])]),t._v(" "),s("p",[t._v("和 NSHashTable 类似，NSMapTable 可以随意的存储指针，并且利用指针的唯一性来进行对比和重复检查。")]),t._v(" "),s("p",[t._v("用法：假设用 NSMapTable 来存储不用被复制的 keys 和被若引用的 value，这里的 value 就是某个 delegate 或者一种弱类型。")]),t._v(" "),s("div",{staticClass:"language-objectivec extra-class"},[s("pre",{pre:!0,attrs:{class:"language-objectivec"}},[s("code",[t._v("id delegate "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nNSMapTable "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("mapTable "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSMapTable mapTableWithKeyOptions"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("NSMapTableStrongMemory\n                                             valueOptions"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("NSMapTableWeakMemory"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("mapTable setObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("delegate forKey"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('@"foo"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("NSLog")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('@"Keys: %@"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("mapTable keyEnumerator"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" allObjects"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("看完上面几个小例子后，你可能会想 “为什么不使用 object subscripting 呢?”。一些激进的 NSHipster 估计已经开始动手写 NSMapTable 的 subscripting category 了。")]),t._v(" "),s("p",[s("strong",[t._v("那么为什么 NSMapTable 不能继承 subscripting？")])]),t._v(" "),s("p",[t._v("来看看下面的代码：")]),t._v(" "),s("div",{staticClass:"language-objectivec extra-class"},[s("pre",{pre:!0,attrs:{class:"language-objectivec"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("objectForKeyedSubscript"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("NSCopying"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("setObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("obj forKeyedSubscript"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("NSCopying"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[s("strong",[t._v("注意：参数 key 是类型的")]),t._v("。这对 NSDictionary NSMutableDictionary 来讲是非常有用的，但是我们不能臆断对 NSMapTable 也同样适用。我们陷入一个僵局：通过 id，我们不能利用 NSMapTable 实现 subscripting。如果 object subscripting 的代理方法放弃了约束，那么使用 NSMutableDictionary -setObject:forKeyedSubscript:的时候编译将得不到想要的结果。")]),t._v(" "),s("p",[t._v("所以说实话，对比 NSMapTable 所处的位置，句法的方便和快捷并不是大数人所关注的。")]),t._v(" "),s("p",[t._v("通常，记住编程不是为了让人更聪明，而是最大化抽象一个问题的能力。NSSet 和 NSDictionary 是非常伟大的类，他们能解决 99%的问题，也无疑是用来工作的正确工具。如果，然而你的问题牵扯到上述的内存问题时候，NSHashTable 和 NSMapTable 是值得一看的。")])])}),[],!1,null,null,null);a.default=n.exports}}]);