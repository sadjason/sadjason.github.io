(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{167:function(r,o,e){"use strict";e.r(o);var a=e(0),t=Object(a.a)({},(function(){var r=this,o=r.$createElement,e=r._self._c||o;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h2",{attrs:{id:"写在前面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#写在前面"}},[r._v("#")]),r._v(" 写在前面")]),r._v(" "),e("p",[r._v("在 iOS 开发中，"),e("code",[r._v("NSError")]),r._v("的使用非常常见，使用也比较简单，也正因为简单，所以对这一部分知识不甚注重。但是近期在做 app 底层网络封装时发现了一些问题。我使用的网络框架是 AFNetworking，AFNetworking 常常会返回一些错误信息，有时需要将这些错误信息告诉用户，通常做法是将"),e("code",[r._v("NSError#localizedDescription")]),r._v("以弹框的形式原原本本展现给用户（譬如“网络不畅”之类的），但是这样非常不友好，一是这些信息往往是英文，二是这些信息过于冗长，不够简洁。所以自然想到了对这些 error 信息进行包装。这就迫使我不得不去了解更多关于 NSError 相关的信息，本文着重叙述 Error Domain 和 Error Code。")]),r._v(" "),e("h2",{attrs:{id:"error-domain"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#error-domain"}},[r._v("#")]),r._v(" Error Domain")]),r._v(" "),e("p",[r._v("首先，error domain 是一个字符串。因为历史原因，在 OS X 中将 errors 分为不同的 domains。譬如，对于 Carbon 框架的 error，归于 OSStatus domain（"),e("code",[r._v("NSOSStatusErrorDomain")]),r._v("），对于 POSIX error，归于"),e("code",[r._v("NSPOSIXErrorDomain")]),r._v("，而对于我们的 iOS 开发，一般使用"),e("code",[r._v("NSCocoaErrorDomain")]),r._v("。NSError.h 定义了四个 domain，如下：")]),r._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[r._v("// Predefined domain for errors from most AppKit and Foundation APIs.")]),r._v("\nFOUNDATION_EXPORT NSString "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("*")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("const")]),r._v(" NSCocoaErrorDomain"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(";")]),r._v("\n    \n"),e("span",{pre:!0,attrs:{class:"token comment"}},[r._v('// Other predefined domains; value of "code" will correspond to preexisting values in these domains.')]),r._v("\nFOUNDATION_EXPORT NSString "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("*")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("const")]),r._v(" NSPOSIXErrorDomain"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(";")]),r._v("\nFOUNDATION_EXPORT NSString "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("*")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("const")]),r._v(" NSOSStatusErrorDomain"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(";")]),r._v("\nFOUNDATION_EXPORT NSString "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("*")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("const")]),r._v(" NSMachErrorDomain"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(";")]),r._v("\n")])])]),e("p",[r._v("除了上述的四个 domain 之外，不同的 framework 甚至一些 classes group（相关的几个 classes）也定义了自己的 domain，譬如对于 Web Kit framework，定义了"),e("code",[r._v("WebKitErrorDomain")]),r._v("，而更常见的，URL 相关的 classes 定义了"),e("code",[r._v("NSURLErrorDomain")]),r._v("。")]),r._v(" "),e("p",[r._v("Domains 非常有用，特别当程序非常复杂庞大时，官方文档是这么说的：")]),r._v(" "),e("blockquote",[e("p",[r._v("Domains serve several useful purposes. They give Cocoa programs a way to identify the OS X subsystem that is detecting an error. They also help to prevent collisions between error codes from different subsystems with the same numeric value. In addition, domains allow for a causal relationship between error codes based on the layering of subsystems; for example, an error in the NSOSStatusErrorDomain may have an underlying error in the NSMachErrorDomain.")])]),r._v(" "),e("p",[r._v("用户也可以为自己的 framework 或者 app 定义自己的 domain，官方推荐的 domain 命名规则是：\n"),e("code",[r._v("com.company.framework_or_app.ErrorDomain")]),r._v("。")]),r._v(" "),e("h2",{attrs:{id:"error-code"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#error-code"}},[r._v("#")]),r._v(" Error Code")]),r._v(" "),e("p",[r._v("Error Code 的类型是 signed integer。Error Code 指定了特殊的错误。这个信息对于程序开发来说极为有用。比如访问 URL 资源 timeout 错误对应的是"),e("code",[r._v("NSURLErrorTimedOut")]),r._v("（"),e("code",[r._v("-1001")]),r._v("）。")]),r._v(" "),e("p",[r._v("那么如何知道各个 error code 对应什么样的值呢？iOS 开发中常用的 error code 所对应的头文件如下：")]),r._v(" "),e("ul",[e("li",[r._v("Foundation/FoundationErrors.h - Generic Foundation error codes")]),r._v(" "),e("li",[r._v("CoreData/CoreDataErrors.h - Core Data error codes")]),r._v(" "),e("li",[r._v("Foundation/NSURLError.h - URL error codes")])]),r._v(" "),e("p",[r._v("以 Foundation/NSURLError.h 为例，其中的 URLError Code 值从"),e("code",[r._v("NSURLErrorDataLengthExceedsMaximum")]),r._v("到"),e("code",[r._v("NSURLErrorCancelled")]),r._v("，二者分别对应"),e("code",[r._v("-1103")]),r._v("和"),e("code",[r._v("-999")]),r._v("。如果对所有网络 error 笼统处理，这两个值可以为我所用。")]),r._v(" "),e("h2",{attrs:{id:"the-user-info-dictionary"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#the-user-info-dictionary"}},[r._v("#")]),r._v(" The User Info Dictionary")]),r._v(" "),e("p",[r._v("Every NSError object has a “user info” dictionary to hold error information beyond domain and code.")]),r._v(" "),e("p",[r._v("User info 可以包含很多自定义信息，最常用的或许是 localized error information。访问 localized error information 有两种方式，其一是访问 NSError 的 localizedDescription 属性，其二是访问"),e("code",[r._v("NSError#userInfo")]),r._v("的"),e("code",[r._v("NSLocalizedDescriptionKey")]),r._v("域。")]),r._v(" "),e("p",[r._v("关于 user info dictionary，比较常见，这里不多讲了，更多内容参考《Error Handling Programming Guide》。")])])}),[],!1,null,null,null);o.default=t.exports}}]);