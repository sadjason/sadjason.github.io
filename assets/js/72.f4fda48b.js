(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{115:function(t,v,e){"use strict";e.r(v);var _=e(0),r=Object(_.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("本文是我了解 HTTPS 过程中记录的一些碎片信息。")]),t._v(" "),e("h2",{attrs:{id:"基本概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),e("ul",[e("li",[t._v("对称密钥加密系统：编/解码使用相同密钥的算法")]),t._v(" "),e("li",[t._v("不对称密钥加密系统：编/解码使用不同密钥的算法")]),t._v(" "),e("li",[t._v("公开密钥加密系统：一种能够使百万计算机便携地发送机密报文的系统")]),t._v(" "),e("li",[t._v("数字签名：用来验证报文未被伪造或篡改的校验和")]),t._v(" "),e("li",[t._v("数字证书：由一个可信的组织验证和签发的识别信息")])]),t._v(" "),e("h3",{attrs:{id:"对称密钥加密技术"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对称密钥加密技术"}},[t._v("#")]),t._v(" 对称密钥加密技术")]),t._v(" "),e("p",[t._v("保持密钥的机密状态是很重要的。在很多情况下，编/解码算法都是众所周知的，密钥是唯一保密的东西。")]),t._v(" "),e("p",[t._v("好的加密算法会迫使攻击者尝遍每一个可能的密钥，才能破解代码。")]),t._v(" "),e("p",[t._v("可用密钥值的数量取决于密钥的位数，以及可能的密钥中有多少位是有效的。有些加密技术中只有部分密钥是有效的。")]),t._v(" "),e("p",[e("strong",[t._v("枚举攻击")]),t._v("：用暴力去尝试所有的密钥值称为枚举攻击（enumeration attack）。")]),t._v(" "),e("p",[t._v("对称密钥加密技术的痛点之一：发送者和接收者在互相对话之前，一定要有一个共享的保密密钥。如果有 N 个节点，每个节点都要和其他所有 N-1 个节点进行安全对话，总共大概会有 N*N 个保密密钥，这几乎无法管理。")]),t._v(" "),e("p",[t._v("常见的对称加密算法有 DES、3DES、AES、Blowfish、IDEA、RC5、RC6。")]),t._v(" "),e("h3",{attrs:{id:"公开密钥加密技术"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#公开密钥加密技术"}},[t._v("#")]),t._v(" 公开密钥加密技术")]),t._v(" "),e("p",[t._v("公开密钥加密技术没有为每对主机使用单独的加密/解密密钥，而是使用了两个非对称密钥：一个用来对主机报文编码，另一个用来对主机报文解码。")]),t._v(" "),e("p",[t._v("编码密钥是众所周知的，但是解码密钥只能为报文的目标主机所持有。")]),t._v(" "),e("p",[t._v("P.S: 公开密钥加密技术似乎只适合多对一通信。")]),t._v(" "),e("p",[t._v("公开密钥加密一般都是非对称的，即加密密钥和解密密钥不同。共同挑战是，要确保即便有人拥有了下面线索，也无法计算出保密的私有密钥：")]),t._v(" "),e("ul",[e("li",[t._v("公开密钥（是公有的，所有人都可以获得）")]),t._v(" "),e("li",[t._v("一小片拦截下来的密文（可通过对网络的嗅探获取）")]),t._v(" "),e("li",[t._v("一条报文与之相关的密文（对任意一段文本运行加密器就可以得到）")])]),t._v(" "),e("p",[e("strong",[t._v("RSA")])]),t._v(" "),e("p",[t._v("RSA 是一个满足了所有上述条件的公开密钥加密系统，破解 RSA 系统的私密钥匙的困难程度相当于对一个极大的数进行质因数分解，这是计算机科学中最困难的问题之一。")]),t._v(" "),e("p",[t._v("关于更多 RSA 的内容，参考："),e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("RSA 算法原理（一）"),e("OutboundLink")],1),t._v("、"),e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("RSA 算法原理（二）"),e("OutboundLink")],1),t._v("。")]),t._v(" "),e("h3",{attrs:{id:"数字签名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数字签名"}},[t._v("#")]),t._v(" 数字签名")]),t._v(" "),e("p",[t._v("数字签名是附加在报文上的特殊加密校验码，即所谓的校验和。")]),t._v(" "),e("p",[t._v("数字签名算法的输入是啥呢？报文消息？No！数字签名算法对消息的长度和格式是有要求的，要求数据满足一定的条件。所以不能直接使用报文消息作为输入。一般策略是是对报文消息先进行哈希，得到固定长度的哈希值，然后在对哈希值进行签名。如下图：")]),t._v(" "),e("e-img",{attrs:{src:"/image/QQ20170227-2@2x.png"}}),t._v(" "),e("ul",[e("li",[t._v("节点 A 将变长报文进行哈希，生成定长的消息摘要")]),t._v(" "),e("li",[t._v("节点 A 对摘要应用了一个签名函数，该函数会将用户的私有密钥作为参数，输出校验和")]),t._v(" "),e("li",[t._v("签名被附着在报文的末尾，一并发送给节点 B")]),t._v(" "),e("li",[t._v("接收端 B 对签名进行逆向处理（使用公开密钥），将得到的消息摘要与自己计算得到的消息摘要进行对比，进而判断报文是否被篡改")])]),t._v(" "),e("p",[t._v("显然，签名一般是在非对称公开加密技术基础上建立的，签名作者持有私钥，签名接收者持有公钥。")]),t._v(" "),e("p",[t._v("综上，签名的作用有两点：")]),t._v(" "),e("ul",[e("li",[t._v("证明是作者编写了这条报文，因为只有作者持有的密钥才能生成校验和")]),t._v(" "),e("li",[t._v("签名可以防止报文被篡改，攻击者若拦截报文，然后对之进行修改，然而校验和无法匹配，这会在接收者那里被识破")])]),t._v(" "),e("p",[t._v("P.S: 消息摘要是哈希算法通过哈希处理得到的，哈希算法的安全性从很大程度上决定了数字签名的安全性，所谓哈希算法的安全性，在这里指的是，如果消息报文被篡改了，那么篡改后的摘要和篡改前的摘要必须不同。最近 Google 宣布实现了对著名的哈希算法 SHA-1 的碰撞，详见"),e("a",{attrs:{href:"https://www.zhihu.com/question/56234281/answer/148349930",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),e("OutboundLink")],1),t._v("。")]),t._v(" "),e("h3",{attrs:{id:"数字证书"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数字证书"}},[t._v("#")]),t._v(" 数字证书")]),t._v(" "),e("p",[t._v("数字证书是由证书颁发机构签发的，像身份证一样，不易伪造。包括如下内容：")]),t._v(" "),e("ul",[e("li",[t._v("证书序列号")]),t._v(" "),e("li",[t._v("证书签名算法")]),t._v(" "),e("li",[t._v("证书颁发者")]),t._v(" "),e("li",[t._v("有效期")]),t._v(" "),e("li",[t._v("公开密钥")]),t._v(" "),e("li",[t._v("证书签发机构的数字签名")]),t._v(" "),e("li",[t._v("等等")])]),t._v(" "),e("p",[t._v("P.S: 特别需要注意的是 "),e("em",[t._v("证书签发机构的数字签名")]),t._v("，浏览器收到某个 Web 服务器的证书时，会对签名颁发机构的签名进行检查，一般来说，浏览器事先就已经预安装了很多签名颁发机构的证书（含有公开密钥），因此可以对签名进行验证。如果浏览器对签名颁发机构一无所知，浏览器就无法确定是否应该信任该签名颁发机构，它通常会向用户显示一个对话框，看看用户是否相信这个签名发布者，这种签名发布者往往是本地的 IT 部门或者软件厂商。")]),t._v(" "),e("p",[t._v("P.S: 大多数证书都遵循 X.509 v3 标准。")]),t._v(" "),e("p",[t._v("基于 X.509 证书的签名有好几种，包括：")]),t._v(" "),e("ul",[e("li",[t._v("Web 服务器证书")]),t._v(" "),e("li",[t._v("客户端电子邮件证书")]),t._v(" "),e("li",[t._v("软件代码签名证书")]),t._v(" "),e("li",[t._v("证书颁发机构证书")])]),t._v(" "),e("h2",{attrs:{id:"http-的缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-的缺点"}},[t._v("#")]),t._v(" HTTP 的缺点")]),t._v(" "),e("p",[t._v("HTTP 主要有三大不足：")]),t._v(" "),e("ul",[e("li",[t._v("通信使用明文（不加密），内容可能会被窃听")]),t._v(" "),e("li",[t._v("不验证通信方的身份，有可能遭到伪装")]),t._v(" "),e("li",[t._v("无法证明报文的完整性，报文可能被篡改")])]),t._v(" "),e("p",[t._v("或者参考阮一峰大神的博客"),e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("SSL/TLS 协议运行机制"),e("OutboundLink")],1),t._v("的概述的说法，简称为三大风险：")]),t._v(" "),e("ul",[e("li",[t._v("窃听风险（eavesdropping）")]),t._v(" "),e("li",[t._v("冒充风险（pretending）")]),t._v(" "),e("li",[t._v("篡改风险（tampering）")])]),t._v(" "),e("p",[t._v("本文的目的是就是详细阐述这三大问题，以便以后更好地理解 HTTPS。")]),t._v(" "),e("h3",{attrs:{id:"窃听风险与加密"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#窃听风险与加密"}},[t._v("#")]),t._v(" 窃听风险与加密")]),t._v(" "),e("p",[t._v("一个重要的事实是：TCP/IP 是可能被窃听的网络。TCP/IP 协议簇的工作机制，通信内容在所有的通信线路上都有可能遭到窥视：")]),t._v(" "),e("e-img",{attrs:{src:"/image/QQ20170121-0@2x.png"}}),t._v(" "),e("p",[t._v("所谓互联网，是由能联通到全世界的网络设备组成的，无论哪里的 server 和 client 通信，此线路上的网络设备（包括电缆、计算机、路由器、交换机等）都不可能是个人的私有物，因此根本无法避免某个环节的报文会被窥探。")]),t._v(" "),e("p",[t._v("窃听报文并非难事，只要收集互联网上流动的数据包即可，然后对它们进行解析。")]),t._v(" "),e("h3",{attrs:{id:"通过加密防止报文被窃听"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通过加密防止报文被窃听"}},[t._v("#")]),t._v(" 通过加密防止报文被窃听")]),t._v(" "),e("p",[t._v("在应对报文被窃听的对策中，最为普遍的做法是加密技术，加密并不是个陌生的概念，两个重要问题：被加密的对象是啥？采用哪种加密方式？")]),t._v(" "),e("p",[e("strong",[t._v("对内容进行加密")])]),t._v(" "),e("p",[t._v("对内容本身进行加密是最容易想到的，加密后的内容，即便报文被捕获，没有解密秘钥，拿到的也是一堆乱码。此处的 "),e("em",[t._v("内容")]),t._v(" 指的是啥？众所周知，HTTP message 有三大组成部分：起始行、首部、报文主体。对内容加密的这种方式，被加密对象是哪一种呢？")]),t._v(" "),e("p",[t._v("一般来说，不会对起始行和首部进行加密。为啥呢？根据我的理解，一方面是意义不大，另一方面首部和起始行信息不光是给接收端看的，也是给沿路中的各种代理看的，加密后的首部和起始行叫人家怎么看？因此，加密对象一般是报文主体或者部分报文主体（敏感内容）。")]),t._v(" "),e("p",[t._v("诚然，为了做到有效的内容加密，前提是要求 client 和 server 同时具备加密和解密机制。")]),t._v(" "),e("p",[e("strong",[t._v("内容加密的相关算法")])]),t._v(" "),e("p",[t._v("另一个问题，对内容加密的方式中，一般采用何种加密呢？加密算法太多了，这里就不展开了...")]),t._v(" "),e("p",[e("strong",[t._v("对内容加密的不足")])]),t._v(" "),e("p",[t._v("只要加密算法足够安全，并且密钥被保护得当，对内容加密能够避免报文主体的敏感内容被监听，但是仍然无法避免内容被篡改。")]),t._v(" "),e("p",[t._v("这个也容易理解，在传输过程中，窃听者虽然读不懂报文的内容的意义，但是仍然可以修改报文内容，譬如把报文的主体内容给清掉，进而对接收者进行误导。")]),t._v(" "),e("p",[e("strong",[t._v("对信道加密")])]),t._v(" "),e("p",[t._v("相对于内容加密，"),e("em",[t._v("信道加密")]),t._v(" 这个概念比较生僻一些，内容是比较容易理解的，那么，何为 "),e("em",[t._v("信道")]),t._v(" 呢？")]),t._v(" "),e("p",[t._v("我们知道，网络协议是一层层的，HTTP 建立在 TCP 的基础上，TCP 建立在 IP 的基础上。对于 HTTP 协议来说，所谓信道，其实是 TCP 层（类似，TCP 报文的信道是 IP 层），如果 TCP 层的通信是安全的，那么我们谈论 HTTP 加密似乎就没啥意义了。因此，所谓信道加密，是指 HTTP 所依赖的更底层协议被加密。")]),t._v(" "),e("p",[t._v("这里所指的信道加密和 SSL/TLS 有关，搁在后面再讲。")]),t._v(" "),e("p",[t._v("P.S: 对 "),e("em",[t._v("信道")]),t._v(" 和 "),e("em",[t._v("信道加密")]),t._v(" 的阐述，只是我的理解，可能是错的。")]),t._v(" "),e("h3",{attrs:{id:"冒充风险与身份认证"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#冒充风险与身份认证"}},[t._v("#")]),t._v(" 冒充风险与身份认证")]),t._v(" "),e("p",[t._v("另一个重要的事实是：任何人都可以发起请求。")]),t._v(" "),e("p",[t._v("HTTP 协议并没有要求对通信方进行确认，server 只要接收到 request，就会给出一个相应的 response，因此会存在如下隐患：")]),t._v(" "),e("ul",[e("li",[t._v("无法保证 request 发送到了目标 server，有可能接收者是伪装的 server")]),t._v(" "),e("li",[t._v("无法保证 response 是被正确的 client 接收，有可能接收者是伪装的 client")]),t._v(" "),e("li",[t._v("无法确定正在通信的对方是否具备访问权限，因为某些 Web 服务器上保存着重要的信息，只想发给具备某种特定权限的 client")]),t._v(" "),e("li",[t._v("无法避免无意义的 request 涌入，既无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）")])]),t._v(" "),e("p",[e("strong",[t._v("通过证书验证身份")])]),t._v(" "),e("p",[t._v("身份认证可以解决这个问题，SSL/TLS 提供了这种服务，详见之后的博客。")]),t._v(" "),e("h3",{attrs:{id:"篡改风险与完整性保护"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#篡改风险与完整性保护"}},[t._v("#")]),t._v(" 篡改风险与完整性保护")]),t._v(" "),e("p",[t._v("上文已经提到，通过内容加密方式，可以避免报文敏感信息被窃听，但是无法避免报文被篡改。譬如，request 或 response 在传输途中，遭受攻击者拦截并篡改内容，这种攻击行为被称为中间人攻击（Man-In-The-Middle attack，MITM attack）。")]),t._v(" "),e("p",[t._v("什么是完整性保护呢？所谓完整性并不是指报文没有受损，而是指报文的准确度；换句话说，如果无法证明报文的完整性，那么意味着无法判断报文信息是否准确。")]),t._v(" "),e("p",[t._v("与窃听风险、冒充风险不同，篡改风险的应对措施比较多，根据《HTTP 权威指南》的说法，至少包括：基本认证、摘要认证，以及数字签名。")]),t._v(" "),e("p",[t._v("在 HTTP 应用中，一种常见的策略是使用散列值校验，简单来说，发送方使用散列值算法（最常见的有 MD5、SHA-1，又被称为 "),e("em",[t._v("摘要算法")]),t._v(" ），对消息进行哈希，得到固定长度的哈希值（是谓 "),e("em",[t._v("摘要")]),t._v(" ），将该哈希值与消息一起传给对方，对方在收到 message 后，也使用约定的散列值算法对报文进行哈希，再与发送方的哈希值进行对比，如果不一致，则说明报文已被篡改，不安全。")]),t._v(" "),e("p",[t._v("然而，这是会存在问题的，一方面是 MD5、SHA-1 不再安全，另一方面摘要本身也是可以被篡改的。")]),t._v(" "),e("p",[t._v("更好的做法是，对摘要本身也进行保护，这个过程一般被称为数字签名，上文已经对数字签名有所阐述，这里就不再赘述。")]),t._v(" "),e("h2",{attrs:{id:"初步了解-ssl-tls"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#初步了解-ssl-tls"}},[t._v("#")]),t._v(" 初步了解 SSL/TLS")]),t._v(" "),e("p",[t._v("HTTPS（Hypertext Transfer Protocol Secure）被称为 "),e("em",[t._v("HTTP over TLS")]),t._v(" 或 "),e("em",[t._v("HTTP over SSL")]),t._v(" 或 "),e("em",[t._v("HTTP Secure")]),t._v(" 。它并不是应用层的一种新协议，只是 HTTP 通信接口部分用 SSL 或 TLS 协议代替而已。通常，HTTP 直接和 TCP 通信，当使用 SSL/TLS 时，则演变为先和 SSL/TLS 通信，再由 SSL/TLS 和 TCP 通信，简单来说，HTTPS 在 HTTP 和 TCP 之间隔了一层 SSL/TLS（通常被称为安全层）。")]),t._v(" "),e("p",[t._v("上文谈到了 HTTP 存在的三个重大毛病，SSL/TLS 解决了三个毛病的哪一个呢？答案是：所有。")]),t._v(" "),e("p",[t._v("因此，此处引用《图解 HTTP》对 HTTPS 的总结：")]),t._v(" "),e("blockquote",[e("p",[t._v("HTTPS = HTTP + 加密 + 认证 + 完整性保护。")])]),t._v(" "),e("p",[t._v("简单来说，建立在 SSL/TLS 协议之上，HTTP 具备加密、认证和完整性保护这些特点。本文旨在理清 SSL/TLS 是如何实现加密、认证和完整性保护的。")]),t._v(" "),e("p",[t._v("首先一个必要的任务是搞清楚 SSL 和 TLS 的关系。SSL 是网景公司推出的，3.0 版本后，被 IETF 标准化，写入 RFC，是谓 TLS。下表是对它们的说明：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"left"}},[t._v("版本")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("发布时间")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("RFC")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("SSL 1.0")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("无")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("无")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("从未公开过，因为存在严重的安全漏洞")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("SSL 2.0")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("1995 年 2 月")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("无")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("因为存在数个严重的安全漏洞而被摈弃")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("SSL 3.0")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("1996 年")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("无（后来作为历史文献被添加到 RFC 中，即"),e("a",{attrs:{href:"https://tools.ietf.org/html/rfc6101",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC6101"),e("OutboundLink")],1),t._v("）")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("2014 年 10 月，Google 发现在 SSL 3.0 中发现设计缺陷，建议禁用此一协议，后续 Microsoft、Mozilla 跟进")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("TLS 1.0")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("1999 年 1 月")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[e("a",{attrs:{href:"https://tools.ietf.org/html/rfc2246",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC2246"),e("OutboundLink")],1)]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("从技术上讲，TLS 1.0 与 SSL 3.0 的差异非常微小")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("TLS 1.1")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("2006 年 4 月")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[e("a",{attrs:{href:"https://tools.ietf.org/html/rfc4346",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC4346"),e("OutboundLink")],1)]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("TLS 1.2")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("2008 年 8 月")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[e("a",{attrs:{href:"https://tools.ietf.org/html/rfc5246",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC5246"),e("OutboundLink")],1)]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("现在主流")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("TLS 1.3")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("草案阶段")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}}),t._v(" "),e("td",{staticStyle:{"text-align":"left"}})])])]),t._v(" "),e("p",[t._v("可见，SSL 已是历史了；但是大家仍然习惯使用术语 SSL 指代 SSL 或 TLS。")]),t._v(" "),e("p",[t._v("对于 SSL/TLS，最重要的内容莫过于其握手过程的分析，以后专门开辟博客阐述吧。")]),t._v(" "),e("h2",{attrs:{id:"各种劫持与攻击"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#各种劫持与攻击"}},[t._v("#")]),t._v(" 各种劫持与攻击")]),t._v(" "),e("p",[t._v("经常看到或者听到一些与安全相关的名词，譬如 DNS 劫持、HTTP 劫持、DDoS 攻击等，这一部分旨在对这些名词进行简单概述。")]),t._v(" "),e("h3",{attrs:{id:"http-报文劫持"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-报文劫持"}},[t._v("#")]),t._v(" HTTP 报文劫持")]),t._v(" "),e("p",[t._v("所谓 HTTP 报文劫持，指的是 HTTP 报文在 server 和 client 的传输过程中被修改的现象，这是运营商（ISP）比较喜欢做的事情，凑不要脸！HTTP 劫持主要发生在 Web 网页中，故而又被称为网页注入。简单来说，运营商常常在 server 发往 client 的 HTTP 报文中插入一段代码，这段代码通常与广告信息有关。相当于你让某个商店邮寄一包东西到你家，你收到的包裹里却有运营商附加的一坨屎。")]),t._v(" "),e("p",[e("strong",[t._v("HTTPS 能解决 HTTP 报文劫持的问题吗？")])]),t._v(" "),e("p",[t._v("显然可以，SSL 的完整性保护确保了这件事情不会发生。")]),t._v(" "),e("h3",{attrs:{id:"dns-劫持"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dns-劫持"}},[t._v("#")]),t._v(" DNS 劫持")]),t._v(" "),e("p",[t._v("DNS（域名系统）的作用是把网络地址对应到能够识别的 IP 地址，以便设备能够进一步通信，传递网址和内容等。DNS 劫持的实质是把 client 的域名劫持指向到非正常的 IP 地址。")]),t._v(" "),e("p",[t._v("P.S: DNS 劫持是流量劫持的一种，又称 "),e("em",[t._v("域名劫持")]),t._v(" ，或称 "),e("em",[t._v("DNS 钓鱼攻击")]),t._v(" 。")]),t._v(" "),e("p",[t._v("P.P.S: 除了 DNS 劫持，流量劫持还包括哪些呢？")]),t._v(" "),e("p",[e("strong",[t._v("HTTPS 能解决 DNS 劫持的问题吗？")])]),t._v(" "),e("p",[t._v("答案是一般可以，但没有什么事情是绝对的。Server 与 client 建立 HTTPS 通信的前提是 server 持有受信任的合法证书；换句话说，如果被劫持到的目标 server 搞到一张假的受信任的证书，又或者它自己签发一个证书，并且 client 信任了该证书，那么 DNS 攻击依然存在。")]),t._v(" "),e("p",[t._v("总之，HTTPS 下的 DNS 攻击门槛非常高，要么搞定 CA 机构，要么让用户信任自签发的证书。从另外一个角度来看，作为用户，我们不应该轻易相信别人自签发的证书，根据我的理解，这一点在网页端的问题要比移动客户端严重得多。")]),t._v(" "),e("p",[t._v("P.S: "),e("a",{attrs:{href:"https://www.zhihu.com/question/22795329",target:"_blank",rel:"noopener noreferrer"}},[t._v("知乎"),e("OutboundLink")],1),t._v("的这个话题下有些比较好的说明。")]),t._v(" "),e("p",[t._v("P.S: DNS 劫持也常常发生在路由器中，譬如被人诟病的小米路由器。")]),t._v(" "),e("h3",{attrs:{id:"运营商-路由器缓存造成的劫持"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#运营商-路由器缓存造成的劫持"}},[t._v("#")]),t._v(" 运营商/路由器缓存造成的劫持")]),t._v(" "),e("p",[t._v("上述的 HTTP 报文劫持和 DNS 劫持都被统称为网络劫持，除了这两种，还有一种常见的劫持：运营商或者路由器无脑的缓存。")]),t._v(" "),e("p",[t._v("点评大神周辉我司内部分享时举了一个相关例子：")]),t._v(" "),e("e-img",{attrs:{src:"/image/tree-pics@2x.png"}}),t._v(" "),e("p",[t._v("如上图所示，不同用户居然获取到同一个用户的个人信息，这几个用户连接的都是上海地铁上的花生 wifi，最后定位到的原因是花生 wifi 服务商对 HTTP response 进行了缓存，缓存的 key 自然是 HTTP request，但是在对 request 处理时居然将参数给去掉了...")]),t._v(" "),e("h3",{attrs:{id:"ddos-攻击"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ddos-攻击"}},[t._v("#")]),t._v(" DDoS 攻击")]),t._v(" "),e("p",[t._v("这种攻击比较简单了，一般情况下的 SSL/TLS 通信模式是单向认证，并不能解决 DDoS 问题...")]),t._v(" "),e("h2",{attrs:{id:"https-与实践"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#https-与实践"}},[t._v("#")]),t._v(" HTTPS 与实践")]),t._v(" "),e("p",[t._v("本文记录我的一些 HTTPS 实践经历或体会。")]),t._v(" "),e("p",[t._v("P.S: 然而，到目前为止，其实没啥近距离的 HTTPS 实践机会...")]),t._v(" "),e("h3",{attrs:{id:"ats"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ats"}},[t._v("#")]),t._v(" ATS")]),t._v(" "),e("p",[t._v("ATS 并不等价于"),e("em",[t._v("所有 App 的 HTTP API 都得使用 HTTPS")]),t._v(" ，它比后者要求得更多，"),e("a",{attrs:{href:"https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW57",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),e("OutboundLink")],1),t._v("有详细说明。简单来说：")]),t._v(" "),e("ul",[e("li",[t._v("默认情况下，server 的 TLS 版本得是 1.2+")]),t._v(" "),e("li",[t._v("对此加密算法得是 AES-128 或者 AES-256 级别的")]),t._v(" "),e("li",[t._v("等等")])]),t._v(" "),e("p",[t._v("处理业务时，遇到一个 case：外网 https://api.guanaitong.com 的 web 页面在我们 app 内不能访问，经查，发现是 server 的 TLS 版本过低（TLS 1.0），给他们的 server 反馈后，已解决...可惜当时没留下截图，一个难得的 case。")]),t._v(" "),e("p",[e("strong",[t._v("如何知道 server 支持的 TLS 的版本呢？")])]),t._v(" "),e("p",[t._v("可以使用 openssl 工具，譬如"),e("code",[t._v("openssl s_client -connect api.guanaitong.com:443 -tls1_2")]),t._v("，参考自："),e("a",{attrs:{href:"https://serverfault.com/questions/638691/how-can-i-verify-if-tls-1-2-is-supported-on-a-remote-web-server-from-the-rhel-ce",target:"_blank",rel:"noopener noreferrer"}},[t._v("How can I verify if TLS 1.2 is supported on a remote Web server from the RHEL/CentOS shell?"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("P.S: macOS 默认已安装 openssl 工具，但是版本比较老（低于 v1.0），使用"),e("code",[t._v("-tls1_2")]),t._v("选项会有问题，需要升级...")]),t._v(" "),e("p",[e("strong",[t._v("如何知道 server 对 ATS 的支持情况呢？")])]),t._v(" "),e("p",[t._v("使用另一个工具 nscurl，譬如：")]),t._v(" "),e("div",{staticClass:"language-sh extra-class"},[e("pre",{pre:!0,attrs:{class:"language-sh"}},[e("code",[t._v("nscurl --ats-diagnostics --verbose https://api.guanaitong.com\n")])])])],1)}),[],!1,null,null,null);v.default=r.exports}}]);