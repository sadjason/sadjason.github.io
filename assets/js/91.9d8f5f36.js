(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{163:function(t,s,n){"use strict";n.r(s);var a=n(0),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("什么是"),n("code",[t._v("NSURLProtocol")]),t._v("？一句话概括："),n("code",[t._v("NSURLProtocol")]),t._v("就是一个苹果允许的中间人攻击。使用"),n("code",[t._v("NSURLProtocol")]),t._v("，你不必改动应用在网络调用上的其他部分，即可改变 URL 加载行为的全部细节，有如下应用场景：")]),t._v(" "),n("ul",[n("li",[t._v("拦截图片加载请求，转为从本地文件加载")]),t._v(" "),n("li",[t._v("为了测试对 HTTP 返回内容进行 mock 和 stub")]),t._v(" "),n("li",[t._v("对发出请求的 header 进行格式化")]),t._v(" "),n("li",[t._v("对发出的媒体请求进行签名")]),t._v(" "),n("li",[t._v("创建本地代理服务，用于数据变化时对 URL 请求的更改")]),t._v(" "),n("li",[t._v("故意制造畸形或非法返回数据来测试程序的鲁棒性")]),t._v(" "),n("li",[t._v("在既有协议基础上完成对"),n("code",[t._v("NSURLConnection")]),t._v("的实现且与原逻辑不产生矛盾")])]),t._v(" "),n("p",[n("code",[t._v("NSURLProtocol")]),t._v("是一个抽象类，用户需要自己使用并继承，对它定义的几个重要方法进行说明：")]),t._v(" "),n("div",{staticClass:"language-objectivec extra-class"},[n("pre",{pre:!0,attrs:{class:"language-objectivec"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// `canInitWithRequest:`是整个逻辑的入口，")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当它返回`YES`时，URL Loading System会创建一个对应的实例，意味着该请求就会被该Protocol实例控制")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当它返回`NO`时，则直接跳入下一个Protocol")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("BOOL"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("canInitWithRequest"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSURLRequest "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("request"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果想要用特定的某个方式来修改一个请求，应该使用该方法。")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 一般来说，每一个subclass都应该依据某一个规范，一个protocol应该保证只有唯一的规范范式")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 补充：具体来说，`canonicalRequestForRequest`返回值会作为Protocol实例")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 构造器`initWithRequest:cachedResponse:client:`的参数")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSURLRequest "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("canonicalRequestForRequest"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSURLRequest "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("request"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这几个方法允许添加、获取、删除一个request对象的任意metedata，而不需要私有扩展或者method swizzling。")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Objective-C中，通过extension可以为NSURLRequest新增方法，但是不能直接新增属性；如何解决这个问题？")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 一种很自然能想到的方案是：关联对象。")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 而这几个方法提供了另外一种方案。相较于关联对象，这种方式更干净，且更简单，且与Runtime无关。")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("propertyForKey"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSString "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("key inRequest"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSURLRequest "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("request"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("setProperty"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("value forKey"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSString "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("key inRequest"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSMutableURLRequest "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("request"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("removePropertyForKey"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSString "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("key inRequest"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSMutableURLRequest "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("request"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Designated Initializer")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// URL Loading System使用该构造器来构建Protocol实例，关于这几个参数：")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   * 每一个Protocol实例对应一个request")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   * 每一个Protocol实例对应一个client，该client用于和URL Loading System进行通信")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("instancetype"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("initWithRequest"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSURLRequest "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("request\n                 cachedResponse"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSCachedURLResponse "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("cachedResponse\n                         client"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("NSURLProtocolClient"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("client"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这两个方法顾名思义是与loading request有关，前者开启一个request请求，后者则结束/取消。")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在自定义URLProtocol时，这两个方法是必须要实现的。简单来说，在实现时：")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1. `startLoading`的实现逻辑里，要启动一个request，对于`NSURLConnection`而言，要创建一个`NSURLConnection`对象，譬如：")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//      self.connection = [[NSURLConnection alloc] initWithRequest:request delegate:self];")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2. `stopLoading`的实现逻辑里，一般都是cancel掉request，譬如：")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//      [self.connection cancel];")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// `startLoading`中构建connection的request从哪里来？在构建protocol实例时，URL Loading System会传入一个request...")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("startLoading"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("stopLoading"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建一个NSURLProtocol子类后，需要使用`registerClass:`注册到URL Loading System，")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当URL Loading System开始load request时，会询问已注册的Protocol是否要处理对应的request，")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果处理（`canInitWithRequest:`的返回值），则会初始化该Protocol对应的实例，以便后续处理。")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 需要注意的是：并不是所有已注册的Protocol都会被询问，URL Loading System根据Protocols的注册")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 顺序逆序询问，当某个Protocol的`canInitWithRequest:`返回`YES`时，后续的Protocol便不再被询问。")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// P.S: 关于逆序询问，Doc的描述：Classes are consulted in the reverse order of their registration。")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// P.S: 如何理解「当URL Loading System开始load request时」呢？对于`NSURLConnection`框架而言，")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这指的是一个`NSURLConnection`实例被创建了。")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("BOOL"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("registerClassass"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Class"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("protocolClass"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("unregisterClass"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Class"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("protocolClass"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  \n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**************** NSURLProtocol实例的常用属性 ****************/")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 上文已有描述，此处不再赘述 */")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@property")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("readonly"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" copy"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" NSURLRequest "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("request"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// client用来干嘛？其作用主要是与URL Loading System进行通信，它的方法和`NSURLConnectionDelegate`非常类似")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用户需要做的事情是在合适的时候调用其中的方法...")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@property")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nullable"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" readonly"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" retain"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" id "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("NSURLProtocolClient"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" client"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("p",[t._v("一些注意事项：")]),t._v(" "),n("ul",[n("li",[t._v("当某个 URL Protocol 接收对某 request 的处理（即"),n("code",[t._v("+canInitWithRequest:")]),t._v("返回"),n("code",[t._v("YES")]),t._v("）时，它通常会创建一个新的"),n("code",[t._v("NSURLConnection")]),t._v("实例，这可能又会触发该 URL Protocol 的"),n("code",[t._v("+canInitWithRequest:")]),t._v("被调用，如果仍然返回"),n("code",[t._v("YES")]),t._v("，则会陷入死循环，所以通常的处理是在"),n("code",[t._v("startLoading")]),t._v("里，对 request 附上一个 flag，以确保在进入"),n("code",[t._v("+canInitWithRequest:")]),t._v("时能够被甄别出来并进行过滤处理。")])]),t._v(" "),n("p",[t._v("参考：")]),t._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"http://nshipster.cn/nsurlprotocol/",target:"_blank",rel:"noopener noreferrer"}},[t._v("NSURLProtocol"),n("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=e.exports}}]);