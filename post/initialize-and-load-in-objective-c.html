<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Objective-C 中的+initialize 和+load | 张不坏的博客</title>
    <meta name="description" content="Just For Fun">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.37bfab3d.css" as="style"><link rel="preload" href="/assets/js/app.50bca889.js" as="script"><link rel="preload" href="/assets/js/5.081d1701.js" as="script"><link rel="preload" href="/assets/js/75.6d63415f.js" as="script"><link rel="prefetch" href="/assets/js/10.7bb33f06.js"><link rel="prefetch" href="/assets/js/100.014ff06c.js"><link rel="prefetch" href="/assets/js/101.28f11de0.js"><link rel="prefetch" href="/assets/js/102.be9d2e87.js"><link rel="prefetch" href="/assets/js/103.a1210d81.js"><link rel="prefetch" href="/assets/js/104.7101a956.js"><link rel="prefetch" href="/assets/js/105.833e6f80.js"><link rel="prefetch" href="/assets/js/106.978e1fc0.js"><link rel="prefetch" href="/assets/js/107.5af47fd0.js"><link rel="prefetch" href="/assets/js/108.efc3ce89.js"><link rel="prefetch" href="/assets/js/109.a69d6b5a.js"><link rel="prefetch" href="/assets/js/11.2de4afc9.js"><link rel="prefetch" href="/assets/js/110.30984b63.js"><link rel="prefetch" href="/assets/js/12.bfc099bd.js"><link rel="prefetch" href="/assets/js/13.20253e0d.js"><link rel="prefetch" href="/assets/js/14.67131b1c.js"><link rel="prefetch" href="/assets/js/15.1af26cbd.js"><link rel="prefetch" href="/assets/js/16.4b261ee0.js"><link rel="prefetch" href="/assets/js/17.1216332f.js"><link rel="prefetch" href="/assets/js/18.c0159773.js"><link rel="prefetch" href="/assets/js/19.0f007f87.js"><link rel="prefetch" href="/assets/js/2.b4633a05.js"><link rel="prefetch" href="/assets/js/20.4b295001.js"><link rel="prefetch" href="/assets/js/21.0c46767c.js"><link rel="prefetch" href="/assets/js/22.a5e065ea.js"><link rel="prefetch" href="/assets/js/23.f43a6a7e.js"><link rel="prefetch" href="/assets/js/24.245f4f15.js"><link rel="prefetch" href="/assets/js/25.618f74a1.js"><link rel="prefetch" href="/assets/js/26.274a606b.js"><link rel="prefetch" href="/assets/js/27.c2d8fe18.js"><link rel="prefetch" href="/assets/js/28.5c522d2a.js"><link rel="prefetch" href="/assets/js/29.c90fdb1a.js"><link rel="prefetch" href="/assets/js/3.9babd8f1.js"><link rel="prefetch" href="/assets/js/30.1ccbdebc.js"><link rel="prefetch" href="/assets/js/31.acf3eca6.js"><link rel="prefetch" href="/assets/js/32.ccfdc859.js"><link rel="prefetch" href="/assets/js/33.9b262756.js"><link rel="prefetch" href="/assets/js/34.c59a4044.js"><link rel="prefetch" href="/assets/js/35.2b10fefb.js"><link rel="prefetch" href="/assets/js/36.2daeeb7b.js"><link rel="prefetch" href="/assets/js/37.d649866c.js"><link rel="prefetch" href="/assets/js/38.aba1ac95.js"><link rel="prefetch" href="/assets/js/39.58a95fd1.js"><link rel="prefetch" href="/assets/js/4.a7413ce2.js"><link rel="prefetch" href="/assets/js/40.8ef4d374.js"><link rel="prefetch" href="/assets/js/41.5799de7a.js"><link rel="prefetch" href="/assets/js/42.b7ee7489.js"><link rel="prefetch" href="/assets/js/43.28a65d64.js"><link rel="prefetch" href="/assets/js/44.90f92ea2.js"><link rel="prefetch" href="/assets/js/45.30b683fd.js"><link rel="prefetch" href="/assets/js/46.f57ccc19.js"><link rel="prefetch" href="/assets/js/47.7a82bd74.js"><link rel="prefetch" href="/assets/js/48.72503020.js"><link rel="prefetch" href="/assets/js/49.3a4ba077.js"><link rel="prefetch" href="/assets/js/50.0c3297f3.js"><link rel="prefetch" href="/assets/js/51.e9ba9363.js"><link rel="prefetch" href="/assets/js/52.473ee9ff.js"><link rel="prefetch" href="/assets/js/53.166d6e7a.js"><link rel="prefetch" href="/assets/js/54.78af3662.js"><link rel="prefetch" href="/assets/js/55.f0d54751.js"><link rel="prefetch" href="/assets/js/56.5de81531.js"><link rel="prefetch" href="/assets/js/57.6e18322f.js"><link rel="prefetch" href="/assets/js/58.1fccc879.js"><link rel="prefetch" href="/assets/js/59.773775e1.js"><link rel="prefetch" href="/assets/js/6.0c9cc532.js"><link rel="prefetch" href="/assets/js/60.0d665185.js"><link rel="prefetch" href="/assets/js/61.d9ae36dc.js"><link rel="prefetch" href="/assets/js/62.fb5e3b65.js"><link rel="prefetch" href="/assets/js/63.5ace8fda.js"><link rel="prefetch" href="/assets/js/64.d44fb0af.js"><link rel="prefetch" href="/assets/js/65.ed8fe56f.js"><link rel="prefetch" href="/assets/js/66.809078da.js"><link rel="prefetch" href="/assets/js/67.2489499e.js"><link rel="prefetch" href="/assets/js/68.e3ee952d.js"><link rel="prefetch" href="/assets/js/69.071411f8.js"><link rel="prefetch" href="/assets/js/7.8188415c.js"><link rel="prefetch" href="/assets/js/70.be8269cf.js"><link rel="prefetch" href="/assets/js/71.a320347a.js"><link rel="prefetch" href="/assets/js/72.f4fda48b.js"><link rel="prefetch" href="/assets/js/73.0f9f9284.js"><link rel="prefetch" href="/assets/js/74.b4028d07.js"><link rel="prefetch" href="/assets/js/76.d5b4df24.js"><link rel="prefetch" href="/assets/js/77.62b794e1.js"><link rel="prefetch" href="/assets/js/78.63e767ab.js"><link rel="prefetch" href="/assets/js/79.45056905.js"><link rel="prefetch" href="/assets/js/8.20d7cb0f.js"><link rel="prefetch" href="/assets/js/80.e06c5521.js"><link rel="prefetch" href="/assets/js/81.bc82bd01.js"><link rel="prefetch" href="/assets/js/82.4aeb6081.js"><link rel="prefetch" href="/assets/js/83.3ed6146f.js"><link rel="prefetch" href="/assets/js/84.f2aff9f4.js"><link rel="prefetch" href="/assets/js/85.2b8f4e50.js"><link rel="prefetch" href="/assets/js/86.27aea1da.js"><link rel="prefetch" href="/assets/js/87.7f5dc71e.js"><link rel="prefetch" href="/assets/js/88.9ca6511c.js"><link rel="prefetch" href="/assets/js/89.e8f54ad1.js"><link rel="prefetch" href="/assets/js/9.ee6c43f7.js"><link rel="prefetch" href="/assets/js/90.9abac718.js"><link rel="prefetch" href="/assets/js/91.9d8f5f36.js"><link rel="prefetch" href="/assets/js/92.2277b907.js"><link rel="prefetch" href="/assets/js/93.efca2f57.js"><link rel="prefetch" href="/assets/js/94.e9cc0386.js"><link rel="prefetch" href="/assets/js/95.fa3326f7.js"><link rel="prefetch" href="/assets/js/96.82bafc57.js"><link rel="prefetch" href="/assets/js/97.da22d13e.js"><link rel="prefetch" href="/assets/js/98.d745e5ec.js"><link rel="prefetch" href="/assets/js/99.79a6f693.js">
    <link rel="stylesheet" href="/assets/css/0.styles.37bfab3d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><div class="navbar"><div class="navbar-content"><div class="slogan">Valar Morghulis</div> <div class="links"><span class="link-item"><a href="/">首页</a></span> <span class="link-item"><a href="/category/iOS/">iOS</a></span> <span class="link-item"><a href="/category/other/">其他</a></span></div></div></div> <div class="content-header"><div class="post-title">Objective-C 中的+initialize 和+load</div> <div class="post-info">2015-04-28 • iOS</div></div> <div class="content content__default"><p>近几天花了一些时间了解了一下 Objective-C runtime 相关的东西，其中涉及到了<code>+load</code>方法，譬如 method swizzling 通常在 category 的<code>+load</code>方法中完成。之前对 initializer 和 load 的使用就比较疑惑，但一直没有详细去对比了解，以此为契机，集各方资源，分析一下吧！</p> <p>关于了解<code>+initialize</code>和<code>+load</code>，个人感觉参考官方文档《NSObject Class Reference》就够了。</p> <h2 id="initialize"><a href="#initialize" class="header-anchor">#</a> +initialize</h2> <p>关于<code>+initialize</code>方法，《<a href="https://developer.apple.com/reference/objectivec/nsobject/1418639-initialize?language=objc" target="_blank" rel="noopener noreferrer">NSObject Class Reference<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》的介绍如下：</p> <blockquote><p>Initializes the class before it receives its first message.</p></blockquote> <p>可以理解<code>+initialize</code>的作用是为了该 Class 在使用前创建合适的环境。</p> <p>关于其使用，<a href="https://developer.apple.com/reference/objectivec/nsobject/1418639-initialize?language=objc" target="_blank" rel="noopener noreferrer">文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的说明如下：</p> <blockquote><p>The runtime sends <code>initialize</code> to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.
 
The runtime sends the <code>initialize</code> message to classes in a thread-safe manner. That is, <code>initialize</code> is run by the first thread to send a message to a class, and any other thread that tries to send a message to that class will block until <code>initialize</code> completes.
 
The superclass implementation may be called multiple times if subclasses do not implement <code>initialize</code> — the runtime will call the inherited implementation — or if subclasses explicitly call <code>[super initialize]</code>.</p></blockquote> <p>这上面这段话，可以得出如下这么一些意思：</p> <ul><li><code>+initialize</code>方法是在 runtime 被调用的</li> <li>对于某个类型，其<code>+initialize</code>方法都会在该类型接受其他任何消息（类型方法）之前被调用，包括<code>+alloc</code></li> <li>如果父类和子类的<code>+initialize</code>方法都被调用，父类的调用一定在子类之前，这是系统自动完成的，子类<code>+initialize</code>中没必要显式调用<code>[super initialize]</code></li> <li>runtime 系统处理<code>+initialize</code>消息的方式是线程安全的，所以没必要在<code>+initialize</code>中为了保证线程安全而使用 lock、mutex 之类的线程安全工具</li> <li>某个类的<code>+initialize</code>的方法不一定只被调用一次，至少有两种情况会被调用多次：
<ul><li>子类显式调用<code>[super initialize]</code></li> <li>子类没有实现<code>+initialize</code>方法</li></ul></li></ul> <p>下面以示例演示某个类的<code>+initialize</code>被多次执行的现象。</p> <p>定义三个类：<code>Person</code>、<code>Student</code>、<code>Teacher</code>，<code>Student</code>和<code>Teacher</code>继承自<code>Person</code>，<code>Person</code>继承自<code>NSObject</code>。<code>Person</code>和<code>Student</code>都实现了<code>+initialize</code>方法，<code>Teacher</code>没有实现该方法，如下：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code><span class="token comment">// Person的+initialize方法的实现</span>
<span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>initialize <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;Person initialize&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
    
<span class="token comment">// Student的+initialize方法的实现</span>
<span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>initialize <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;Student initialize&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>执行效果如下：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>viewDidLoad <span class="token punctuation">{</span>
    Student <span class="token operator">*</span>aStudent <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Student alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
    Teacher <span class="token operator">*</span>aTeacher <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Teacher alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token punctuation">[</span><span class="token keyword">super</span> viewDidLoad<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
    
<span class="token comment">/* 输出：
Person initialize
Student initialize
Person initialize
*/</span>
</code></pre></div><p>可以看到，对于<code>Student</code>，在其<code>+initialize</code>方法被调用之前，其 super class（<code>Person</code>）的<code>+initialize</code>方法被率先调用；对于<code>Teacher</code>，没有定义<code>+initialize</code>方法，所以它会直接调用 super class（Person）的<code>+initialize</code>方法，这就导致了 Person 的<code>+initialize</code>方法被执行两次。</p> <p>有没有办法避免<code>Person</code>的<code>+initialize</code>方法被多次调用？当然可以：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code><span class="token comment">// Person的+initialize方法的实现</span>
<span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>initialize <span class="token punctuation">{</span>
    <span class="token keyword">static</span> BOOL b <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;Person initialize&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        b <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>也可以这样：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code><span class="token comment">// Person的+initialize方法的实现</span>
<span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>initialize <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">self</span> <span class="token operator">==</span> <span class="token punctuation">[</span>Person class<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;Person initialize&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>《NSObject Class Reference》中还对<code>+initialize</code>方法的使用做了一些警告：</p> <blockquote><p>Because initialize is called in a thread-safe manner and the order of initialize being called on different classes is not guaranteed, it’s important to do the minimum amount of work necessary in initialize methods. Specifically, any code that takes locks that might be required by other classes in their initialize methods is liable to lead to deadlocks. Therefore you should not rely on initialize for complex initialization, and should instead limit it to straightforward, class local initialization.</p></blockquote> <p>总结一下，就是这样：不要在<code>+initialize</code>中处理复杂的逻辑！</p> <p>那么<code>+initialize</code>可以做些什么事情呢？可以做一些简单的初始化工作，譬如对于某个继承自<code>UICollectionViewCell</code>的自定义类<code>PhotoViewCell</code>，<code>PhotoViewCell</code>的对象可能会有一些公用资源，譬如 label color，label font 等等，没必要在<code>-initXXOO</code>方法中创建这些完全一样的资源，此时就可以放在<code>PhotoViewCell</code>中的<code>+initialize</code>中完成，如下：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>initialize <span class="token punctuation">{</span>
    titleFont       <span class="token operator">=</span> <span class="token punctuation">[</span>UIFont systemFontOfSize<span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    titleHeight     <span class="token operator">=</span> <span class="token number">20.0f</span><span class="token punctuation">;</span>
    videoIcon       <span class="token operator">=</span> <span class="token punctuation">[</span>UIImage imageNamed<span class="token punctuation">:</span><span class="token string">@&quot;CTAssetsPickerVideo&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    titleColor      <span class="token operator">=</span> <span class="token punctuation">[</span>UIColor whiteColor<span class="token punctuation">]</span><span class="token punctuation">;</span>
    checkedIcon     <span class="token operator">=</span> <span class="token punctuation">[</span>UIImage imageNamed<span class="token punctuation">:</span><span class="token string">@&quot;CTAssetsPickerChecked&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    selectedColor   <span class="token operator">=</span> <span class="token punctuation">[</span>UIColor colorWithWhite<span class="token punctuation">:</span><span class="token number">1</span> alpha<span class="token punctuation">:</span><span class="token number">0.3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>+initialize</code>终究还是带来惊人的信息量，颇为失望。</p> <h2 id="load"><a href="#load" class="header-anchor">#</a> +load</h2> <p>关于<code>+load</code>方法，《NSObject Class Reference》的介绍如下：</p> <blockquote><p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</p></blockquote> <p>关于其使用，《NSObject Class Reference》的说明如下：</p> <blockquote><p>The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.</p></blockquote> <blockquote><p>The order of initialization is as follows:</p> <blockquote><ol><li>All initializers in any framework you link to.</li> <li>All +load methods in your image.</li> <li>All C++ static initializers and C/C++ <strong>attribute</strong>(constructor) functions in your image.</li> <li>All initializers in frameworks that link to you.</li></ol></blockquote></blockquote> <blockquote><p>In addition:</p></blockquote> <ul><li>A class’s +load method is called after all of its superclasses’ +load methods.</li> <li>A category +load method is called after the class’s own +load method.
In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</li></ul> <p>从这段文字可以读出如下信息：</p> <ul><li>在一个程序（main 函数）运行之前，所用到的库被加载到 runtime 之后，被添加到的 runtime 系统的各种类和 category 的<code>+load</code>方法就被调用；（关于这点很容易通过打印语句来验证）；</li> <li>如果父类和子类的<code>+load</code>方法都被调用，父类的调用一定在子类之前，这是系统自动完成的，子类<code>+load</code>中没必要显式调用<code>[super load];</code>；</li> <li>文档没有讲明<code>+load</code>的执行是否是线程安全的，但考虑到它是在 runtime 之前就调用，所以谈论它是否是线程安全没啥必要，根据我的理解，多线程在 runtime 才有谈论意义；</li> <li>若某个类由一个主类和多个 category 组成，则允许主类和 category 中各自有自己的<code>+load</code>方法，只是 category 中的<code>+load</code>的执行在主类的<code>+load</code>之后；</li></ul> <p>关于<code>+load</code>的使用场景，笔者知道的至少有一个，method swizzling 的处理一般都在 category 的<code>+load</code>中完成的，参考<a href="/post/unstanding-objective-c-runtime-part-4/">这里</a>。</p> <h2 id="本文参考"><a href="#本文参考" class="header-anchor">#</a> 本文参考</h2> <ul><li>《NSObject Class Reference》</li></ul></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.50bca889.js" defer></script><script src="/assets/js/5.081d1701.js" defer></script><script src="/assets/js/75.6d63415f.js" defer></script>
  </body>
</html>
