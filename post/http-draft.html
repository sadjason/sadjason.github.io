<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP 碎片信息 | 张不坏的博客</title>
    <meta name="description" content="Just For Fun">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.37bfab3d.css" as="style"><link rel="preload" href="/assets/js/app.50bca889.js" as="script"><link rel="preload" href="/assets/js/5.081d1701.js" as="script"><link rel="preload" href="/assets/js/71.a320347a.js" as="script"><link rel="preload" href="/assets/js/4.a7413ce2.js" as="script"><link rel="prefetch" href="/assets/js/10.7bb33f06.js"><link rel="prefetch" href="/assets/js/100.014ff06c.js"><link rel="prefetch" href="/assets/js/101.28f11de0.js"><link rel="prefetch" href="/assets/js/102.be9d2e87.js"><link rel="prefetch" href="/assets/js/103.a1210d81.js"><link rel="prefetch" href="/assets/js/104.7101a956.js"><link rel="prefetch" href="/assets/js/105.833e6f80.js"><link rel="prefetch" href="/assets/js/106.978e1fc0.js"><link rel="prefetch" href="/assets/js/107.5af47fd0.js"><link rel="prefetch" href="/assets/js/108.efc3ce89.js"><link rel="prefetch" href="/assets/js/109.a69d6b5a.js"><link rel="prefetch" href="/assets/js/11.2de4afc9.js"><link rel="prefetch" href="/assets/js/110.30984b63.js"><link rel="prefetch" href="/assets/js/12.bfc099bd.js"><link rel="prefetch" href="/assets/js/13.20253e0d.js"><link rel="prefetch" href="/assets/js/14.67131b1c.js"><link rel="prefetch" href="/assets/js/15.1af26cbd.js"><link rel="prefetch" href="/assets/js/16.4b261ee0.js"><link rel="prefetch" href="/assets/js/17.1216332f.js"><link rel="prefetch" href="/assets/js/18.c0159773.js"><link rel="prefetch" href="/assets/js/19.0f007f87.js"><link rel="prefetch" href="/assets/js/2.b4633a05.js"><link rel="prefetch" href="/assets/js/20.4b295001.js"><link rel="prefetch" href="/assets/js/21.0c46767c.js"><link rel="prefetch" href="/assets/js/22.a5e065ea.js"><link rel="prefetch" href="/assets/js/23.f43a6a7e.js"><link rel="prefetch" href="/assets/js/24.245f4f15.js"><link rel="prefetch" href="/assets/js/25.618f74a1.js"><link rel="prefetch" href="/assets/js/26.274a606b.js"><link rel="prefetch" href="/assets/js/27.c2d8fe18.js"><link rel="prefetch" href="/assets/js/28.5c522d2a.js"><link rel="prefetch" href="/assets/js/29.c90fdb1a.js"><link rel="prefetch" href="/assets/js/3.9babd8f1.js"><link rel="prefetch" href="/assets/js/30.1ccbdebc.js"><link rel="prefetch" href="/assets/js/31.acf3eca6.js"><link rel="prefetch" href="/assets/js/32.ccfdc859.js"><link rel="prefetch" href="/assets/js/33.9b262756.js"><link rel="prefetch" href="/assets/js/34.c59a4044.js"><link rel="prefetch" href="/assets/js/35.2b10fefb.js"><link rel="prefetch" href="/assets/js/36.2daeeb7b.js"><link rel="prefetch" href="/assets/js/37.d649866c.js"><link rel="prefetch" href="/assets/js/38.aba1ac95.js"><link rel="prefetch" href="/assets/js/39.58a95fd1.js"><link rel="prefetch" href="/assets/js/40.8ef4d374.js"><link rel="prefetch" href="/assets/js/41.5799de7a.js"><link rel="prefetch" href="/assets/js/42.b7ee7489.js"><link rel="prefetch" href="/assets/js/43.28a65d64.js"><link rel="prefetch" href="/assets/js/44.90f92ea2.js"><link rel="prefetch" href="/assets/js/45.30b683fd.js"><link rel="prefetch" href="/assets/js/46.f57ccc19.js"><link rel="prefetch" href="/assets/js/47.7a82bd74.js"><link rel="prefetch" href="/assets/js/48.72503020.js"><link rel="prefetch" href="/assets/js/49.3a4ba077.js"><link rel="prefetch" href="/assets/js/50.0c3297f3.js"><link rel="prefetch" href="/assets/js/51.e9ba9363.js"><link rel="prefetch" href="/assets/js/52.473ee9ff.js"><link rel="prefetch" href="/assets/js/53.166d6e7a.js"><link rel="prefetch" href="/assets/js/54.78af3662.js"><link rel="prefetch" href="/assets/js/55.f0d54751.js"><link rel="prefetch" href="/assets/js/56.5de81531.js"><link rel="prefetch" href="/assets/js/57.6e18322f.js"><link rel="prefetch" href="/assets/js/58.1fccc879.js"><link rel="prefetch" href="/assets/js/59.773775e1.js"><link rel="prefetch" href="/assets/js/6.0c9cc532.js"><link rel="prefetch" href="/assets/js/60.0d665185.js"><link rel="prefetch" href="/assets/js/61.d9ae36dc.js"><link rel="prefetch" href="/assets/js/62.fb5e3b65.js"><link rel="prefetch" href="/assets/js/63.5ace8fda.js"><link rel="prefetch" href="/assets/js/64.d44fb0af.js"><link rel="prefetch" href="/assets/js/65.ed8fe56f.js"><link rel="prefetch" href="/assets/js/66.809078da.js"><link rel="prefetch" href="/assets/js/67.2489499e.js"><link rel="prefetch" href="/assets/js/68.e3ee952d.js"><link rel="prefetch" href="/assets/js/69.071411f8.js"><link rel="prefetch" href="/assets/js/7.8188415c.js"><link rel="prefetch" href="/assets/js/70.be8269cf.js"><link rel="prefetch" href="/assets/js/72.f4fda48b.js"><link rel="prefetch" href="/assets/js/73.0f9f9284.js"><link rel="prefetch" href="/assets/js/74.b4028d07.js"><link rel="prefetch" href="/assets/js/75.6d63415f.js"><link rel="prefetch" href="/assets/js/76.d5b4df24.js"><link rel="prefetch" href="/assets/js/77.62b794e1.js"><link rel="prefetch" href="/assets/js/78.63e767ab.js"><link rel="prefetch" href="/assets/js/79.45056905.js"><link rel="prefetch" href="/assets/js/8.20d7cb0f.js"><link rel="prefetch" href="/assets/js/80.e06c5521.js"><link rel="prefetch" href="/assets/js/81.bc82bd01.js"><link rel="prefetch" href="/assets/js/82.4aeb6081.js"><link rel="prefetch" href="/assets/js/83.3ed6146f.js"><link rel="prefetch" href="/assets/js/84.f2aff9f4.js"><link rel="prefetch" href="/assets/js/85.2b8f4e50.js"><link rel="prefetch" href="/assets/js/86.27aea1da.js"><link rel="prefetch" href="/assets/js/87.7f5dc71e.js"><link rel="prefetch" href="/assets/js/88.9ca6511c.js"><link rel="prefetch" href="/assets/js/89.e8f54ad1.js"><link rel="prefetch" href="/assets/js/9.ee6c43f7.js"><link rel="prefetch" href="/assets/js/90.9abac718.js"><link rel="prefetch" href="/assets/js/91.9d8f5f36.js"><link rel="prefetch" href="/assets/js/92.2277b907.js"><link rel="prefetch" href="/assets/js/93.efca2f57.js"><link rel="prefetch" href="/assets/js/94.e9cc0386.js"><link rel="prefetch" href="/assets/js/95.fa3326f7.js"><link rel="prefetch" href="/assets/js/96.82bafc57.js"><link rel="prefetch" href="/assets/js/97.da22d13e.js"><link rel="prefetch" href="/assets/js/98.d745e5ec.js"><link rel="prefetch" href="/assets/js/99.79a6f693.js">
    <link rel="stylesheet" href="/assets/css/0.styles.37bfab3d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><div class="navbar"><div class="navbar-content"><div class="slogan">Valar Morghulis</div> <div class="links"><span class="link-item"><a href="/">首页</a></span> <span class="link-item"><a href="/category/iOS/">iOS</a></span> <span class="link-item"><a href="/category/other/">其他</a></span></div></div></div> <div class="content-header"><div class="post-title">HTTP 碎片信息</div> <div class="post-info">2017-02-19</div></div> <div class="content content__default"><p>曾认真阅读过《图解 HTTP》和《HTTP 权威指南》，本文是过程中的阅读笔记。</p> <h2 id="http-相关-rfc-文档"><a href="#http-相关-rfc-文档" class="header-anchor">#</a> HTTP 相关 RFC 文档</h2> <p>HTTP（HyperText Transfer Protocol）于 1990 年问世，下表是相关 RFC 及年份信息：</p> <table><thead><tr><th>HTTP</th> <th>RFC</th> <th>年份</th> <th>说明</th></tr></thead> <tbody><tr><td>HTTP 0.9</td> <td>无</td> <td>1990 年</td> <td>作为非正式标准被提出</td></tr> <tr><td>HTTP 1.0</td> <td><a href="https://tools.ietf.org/html/rfc1945" target="_blank" rel="noopener noreferrer">RFC1945<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></td> <td>1996 年 5 月</td> <td></td></tr> <tr><td>HTTP 1.1</td> <td><a href="https://www.ietf.org/rfc/rfc2068.txt" target="_blank" rel="noopener noreferrer">RFC2068<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="noopener noreferrer">RFC2616<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（修订版）</td> <td>1997 年 1 月</td> <td>目前主流</td></tr> <tr><td>HTTP 2.0</td> <td><a href="https://tools.ietf.org/html/rfc7540" target="_blank" rel="noopener noreferrer">RFC7540<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></td> <td>2015 年 5 月</td> <td>基于<a href="https://en.wikipedia.org/wiki/SPDY" target="_blank" rel="noopener noreferrer">SPDY<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></td></tr></tbody></table> <h2 id="uri"><a href="#uri" class="header-anchor">#</a> URI</h2> <p>URI 有两种：URL 和 URN，即 URL 和 URN 都是 URI 的子集。现在的 Web 世界中，几乎所有的 URI 都是 URN。但是 URL 有个毛病，若资源从一个位置移到另外一个位置，则意味着对应的 URL 失效了，URN 致力于解决这个问题。</p> <ul><li>URL，譬如<code>http://www.example.com/index.html</code></li> <li>URN，譬如<code>urn:ietf:rfc:2141</code></li></ul> <p>URL 的基本格式是：</p> <div class="language-textile extra-class"><pre class="language-textile"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scheme</span><span class="token punctuation">&gt;</span></span><span class="token phrase">://</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span><span class="token punctuation">&gt;</span></span><span class="token phrase">:</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">&gt;</span></span><span class="token phrase">@</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>host</span><span class="token punctuation">&gt;</span></span><span class="token phrase">:</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>port</span><span class="token punctuation">&gt;</span></span><span class="token phrase">/</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>path</span><span class="token punctuation">&gt;</span></span><span class="token phrase">;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>params</span><span class="token punctuation">&gt;</span></span><span class="token phrase">?</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>query</span><span class="token punctuation">&gt;</span></span><span class="token phrase">#</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fragment</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>可以看到，URL 包括很多组件，但是在实际应用中，几乎没有哪个 URL 包含了所有这些组件。最重要的组件有 3 个：scheme、host、path。简单说明：</p> <ul><li><code>@</code>将用户和密码组件与 URL 的其余部分隔开开来</li> <li>path 组件可以由很多个路径分段，譬如<code>/path/to/hell/</code>，每个分段可以有一个参数（param）组件</li> <li>query 的格式没有限制，但是一般是<code>item1=value1&amp;item2=value2</code>这种结构</li> <li>片段（fragment）组件表示一个资源内部的片段，当资源比较大时常会用到</li></ul> <p>一些常见 URL 的基本格式：</p> <div class="language-textile extra-class"><pre class="language-textile"><code><span class="token phrase">http://</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>host</span><span class="token punctuation">&gt;</span></span><span class="token phrase">:</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>port</span><span class="token punctuation">&gt;</span></span><span class="token phrase">/</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>path</span><span class="token punctuation">&gt;</span></span><span class="token phrase">?</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>query</span><span class="token punctuation">&gt;</span></span><span class="token phrase">#</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fragment</span><span class="token punctuation">&gt;</span></span>
<span class="token phrase">mailto:&lt;rfc<span class="token inline"><span class="token punctuation">-</span><span class="token deleted">822</span><span class="token punctuation">-</span></span>addr-spec&gt;
ftp://</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span><span class="token punctuation">&gt;</span></span><span class="token phrase">:</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">&gt;</span></span><span class="token phrase">@</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>host</span><span class="token punctuation">&gt;</span></span><span class="token phrase">:</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>port</span><span class="token punctuation">&gt;</span></span><span class="token phrase">/</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>path</span><span class="token punctuation">&gt;</span></span><span class="token phrase">;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>params</span><span class="token punctuation">&gt;</span></span>
<span class="token phrase">file://</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>host</span><span class="token punctuation">&gt;</span></span><span class="token phrase">/</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>path</span><span class="token punctuation">&gt;</span></span>
<span class="token phrase">telnet://</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span><span class="token punctuation">&gt;</span></span><span class="token phrase">:</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">&gt;</span></span><span class="token phrase">@</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>host</span><span class="token punctuation">&gt;</span></span><span class="token phrase">:</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>port</span><span class="token punctuation">&gt;</span></span><span class="token phrase">/
</span></code></pre></div><h2 id="http-消息格式"><a href="#http-消息格式" class="header-anchor">#</a> HTTP 消息格式</h2> <p>TCP 的数据单位被称为 TCP 报文（segment），HTTP 的数据单位被称为 HTTP 消息（message），下文简称 HTTP 消息为 message。
从方向或应答角度来看，message 有两种：请求消息（Request）、响应消息（Response）。请求消息和响应消息都由 1 个开始行（start-line）、0 个或多个消息头（headers）、可有可无的消息主体（message-body）组成，如下：</p> <div class="language-textile extra-class"><pre class="language-textile"><code><span class="token phrase">generic-message =
    start-line                 ; 开始行
    *(message-header CRLF)     ; 消息头
    CRLF
    [message-body]             ; 消息主体
     
;  其中CRLF表示“结束符”
;  *表示“0个或多个“”
;  []表示“可有可无”
</span></code></pre></div><p>下面将围绕开始行、消息头、消息主体这几个概念进行最粗浅的概述。</p> <h3 id="开始行（start-line）"><a href="#开始行（start-line）" class="header-anchor">#</a> 开始行（Start-Line）</h3> <p>开始行是什么样的格式？这可不一定，因为对于不同的消息类型（请求消息和响应消息），开始行的格式是不同的：</p> <ul><li>对于请求消息，start-line 是 Request-Line（请求行），请求行的格式</li> <li>对于响应消息，start-line 是 Status-Line（状态行），状态行的格式</li></ul> <h3 id="消息头（headers）"><a href="#消息头（headers）" class="header-anchor">#</a> 消息头（Headers）</h3> <p>根据作用域来分，消息头分为：常用头（general-header）、请求头（request-header）、响应头（response-header）、实体头（entity-header）。无论如何，它们的格式总是这样：</p> <div class="language-textile extra-class"><pre class="language-textile"><code><span class="token phrase">message<span class="token inline"><span class="token punctuation">-</span><span class="token deleted">header = field</span><span class="token punctuation">-</span></span>name &quot;:&quot; [field-value]
</span></code></pre></div><p>其中<code>field-name</code>对大小写不敏感。首部内容非常丰富，估计得专门开辟一篇博客来记录。</p> <p><code>field-value</code>对大小写敏感吗？似乎没有确切的说法，参考：</p> <ul><li><a href="http://stackoverflow.com/questions/5258977/are-http-headers-case-sensitive" target="_blank" rel="noopener noreferrer">Are HTTP headers case-sensitive?<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://stackoverflow.com/questions/10953635/are-the-http-connection-header-values-case-sensitive" target="_blank" rel="noopener noreferrer">Are the HTTP Connection header values case sensitive?<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="消息主体（message-body）"><a href="#消息主体（message-body）" class="header-anchor">#</a> 消息主体（Message-Body）</h3> <p>RFC2616 中讲：</p> <blockquote><p>The message-body (if any) of an HTTP message is used to carry the entity-body associated with the request or response.</p></blockquote> <p>如下：</p> <div class="language-textile extra-class"><pre class="language-textile"><code><span class="token phrase">message<span class="token inline"><span class="token punctuation">-</span><span class="token deleted">body = entity</span><span class="token punctuation">-</span></span>body | &lt;entity<span class="token inline"><span class="token punctuation">-</span><span class="token deleted">body encoded as per Transfer</span><span class="token punctuation">-</span></span>Encoding&gt;
</span></code></pre></div><h2 id="消息主体-v-s-实体主体"><a href="#消息主体-v-s-实体主体" class="header-anchor">#</a> 消息主体 v.s 实体主体</h2> <p>消息主体（message-body）和实体主体（entity-body）是非常容易混淆的两个概念：</p> <ul><li>entity-body 可以被理解为客户端想让服务端看到的内容</li> <li>message-body 指的是服务端接收到的（来自于客户端）实际内容</li></ul> <p>通常，消息主体等于实体主体，但是，当在传输过程中进行编码时，entity-body 就不再等于 message-body 了，此时，根据我的理解，message-body 等于传输编码后的 entity-body。</p> <h2 id="安全方法和幂等方法"><a href="#安全方法和幂等方法" class="header-anchor">#</a> 安全方法和幂等方法</h2> <p>请求消息有若干种方法，常见划分种类有两种：安全方法（Safe Methods）和幂等方法（Idempotent Mehtods）。</p> <p>要理解安全方法，先介绍一个概念：副作用，副作用指当你发送完一个请求以后，网站上的资源状态没有发生修改，即认为这个请求是无副作用的。比如注册用户这个请求是有副作用的，获取用户详情可以认为是无副作用的。</p> <p>对于幂等方法，幂等是说一个请求原封不动的发送 N 次和 M 次（N 不等于 M，N 和 M 都大于 1）服务器上资源的状态最终是一致的。比如发贴是非幂等的，重放 10 次发贴请求会创建 10 个帖子。但修改帖子内容是幂等的，一个修改请求重放无论多少次，帖子最终状态都是一致的。</p> <p>请求消息的方法众多，有些的方法只是读取服务器的资源，有的方法可能会修改服务器的资源。GET 和 HEAD 属于前者，它们只是获取资源，这些方法被称为安全方法；POST、PUT、DELETE 属于后者，它们可能使服务器的资源发生变化，这些方法被称为幂等方法。</p> <p>P.S: 根据我的理解，所谓的安全方法和幂等方法只是一种臆想，不是绝对的。举个例子，服务器有某篇文章，现在浏览器通过 GET 方法获取这篇文章，当然，客户端并没有修改这篇文章，但是，服务器可能做了这样的处理：将这篇文章的浏览次数+1；客观来讲，这个 GET 方法还是修改了服务器的资源；所以，知道安全方法和幂等方法这两个概念就好，不必当真。</p> <p>P.P.S: 这只是我的理解，可能是错的...</p> <h2 id="持久连接"><a href="#持久连接" class="header-anchor">#</a> 持久连接</h2> <p>客户端发起一个请求，服务端给出响应，这个一来一回的过程被称为 <em>一个 HTTP 事务</em> 。在非持久连接中，每个 HTTP 事务处理结束之后，TCP 连接会被关闭。</p> <p>而从 1.1 版本开始，HTTP 默认开启持久连接。简单来说，在事务处理结束之后仍然保持在打开状态的 TCP 链接被称为持久连接。</p> <p>HTTP/1.1 和 HTTP/1.0 实现持久连接的方式不一样，因此得分开讨论。</p> <h3 id="http-1-0-的持久连接"><a href="#http-1-0-的持久连接" class="header-anchor">#</a> HTTP/1.0 的持久连接</h3> <p>在 HTTP/1.1 之前版本中，HTTP 默认都是非持久连接，某些实现支持了持久连接，若想维持持久连接，client 需要在 request 中携带<code>Connection: Keep-Alive</code>首部，同样，sever 需要在 response 中也携带<code>Connection: Keep-Alive</code>首部。
使用 HTTP/1.0 的 Keep-Alive，有一些限制和需要澄清的地方：</p> <ul><li>如果 response 中没有<code>Connection: Keep-Alive</code>首部，意味着 server 会在之后关闭连接</li> <li><code>Connection: Keep-Alive</code>首部必须随所有希望保持持久连接的报文一起发送，如果某个 request 没有发送该首部，则服务器会在那条请求之后关闭连接</li> <li>只有在无需检测到连接的关闭即可确定 entity-body 长度的情况下，才能将连接保持在持久状态，也就是说
<ul><li>必须有正确的 Content-Length 来标明 entity-body 的长度</li> <li>有 multipart 媒体类型，或者用分块传输编码的方式进行了编码</li></ul></li> <li>《HTTP 权威指南》还有一些说明...</li></ul> <h3 id="http-1-1-的持久连接"><a href="#http-1-1-的持久连接" class="header-anchor">#</a> HTTP/1.1 的持久连接</h3> <p>在 HTTP/1.1 版本中，持久连接在默认情况下是激活的，无需开启。除非特别指明，否则 HTTP/1.1 假定所有连接都是持久的。要在事务处理结束之后将连接关闭，HTTP/1.1 应用程序必须向报文显式添加<code>Connection: close</code>首部。</p> <p>问题：<code>Connection: close</code>首部是在 request 中，还是在 response 中呢？答案是：Client 和 server 都可以在报文中携带该首部。</p> <p>HTTP/1.1 持久连接的使用，也有一些限制和需要澄清的地方：</p> <ul><li>发送了<code>Connection: close</code>请求首部后，client 就无法在那条连接上发送更多的请求了</li> <li>如果 client 不想在连接上发送其他请求，就应该在最后一条请求中发送一个<code>Connection: close</code>首部</li> <li>只有当连接上所有的报文都有正确的、自定义报文长度时，连接才能持久保持，也就是说，entity-body 长度和 Content-Length 一致，或者用分块传输编码方式编码</li> <li>一个 client 对任何 server 或者 proxy，只能维持两条持久连接，以防 server 过载</li></ul> <h3 id="keep-alive-首部"><a href="#keep-alive-首部" class="header-anchor">#</a> Keep-Alive 首部</h3> <p>HTTP/1.0 定义了 Keep-Alive 首部（在 HTTP/1.1 中不复存在），可以用来调节持久连接的行为，譬如：</p> <div class="language-textile extra-class"><pre class="language-textile"><code><span class="token phrase">Keep-Alive: timeout=10, max=500
</span></code></pre></div><p>说明如下：</p> <ul><li>参数 timeout 是在 response 首部里发送的，它估计了 server 持久连接保持活跃的时间，这并不是一个承诺值</li> <li>参数 max 也是在 response 首部里发送的，它估计了 server 还希望为多少个事务保持此连接的活跃状态，这依然不是一个承诺值</li></ul> <p>P.S: 注意区分 Keep-Alive 首部和上文的<code>Connection: Keep-Alive</code>首部，后者中的<code>Keep-Alive</code>是一个 field value，前者是一个 field name。</p> <p>P.S: 显然，Keep-Alive 首部只有在提供<code>Connection: Keep-Alive</code>的情况下才有意义。</p> <p>根据我的理解，Keep-Alive 首部在 HTTP/1.1 中没有使用的必要。</p> <h2 id="cookie"><a href="#cookie" class="header-anchor">#</a> Cookie</h2> <p>Cookie 用于管理服务器和客户端之间的状态，它并没有被纳入到 HTTP/1.1 的 RFC2616 中，但其应用非常广泛。这一部分旨在整理 Cookie 相关知识，并尝试搞清楚它在移动客户端中的应用。</p> <h3 id="cookie-相关协议"><a href="#cookie-相关协议" class="header-anchor">#</a> Cookie 相关协议</h3> <p>Cookie 最开始由网景公司于 1994 年为其浏览器开发，并制定了相关的规则标准，目前最为普及的 Cookie 方式也只是在此基础上建立的。后来陆陆续续又产生了一些 RFC：</p> <table><thead><tr><th style="text-align:left;">RFC</th> <th style="text-align:left;">说明</th></tr></thead> <tbody><tr><td style="text-align:left;"><a href="https://www.ietf.org/rfc/rfc2109.txt" target="_blank" rel="noopener noreferrer">RFC2109<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></td> <td style="text-align:left;">差不多淡出人们视线了</td></tr> <tr><td style="text-align:left;"><a href="https://www.ietf.org/rfc/rfc2965.txt" target="_blank" rel="noopener noreferrer">RFC2965<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></td> <td style="text-align:left;">诞生于 IE 和 Netscape 浏览器大战的年代，定义了新的 Set-Cookie2 和 Cookie2，事实上，几乎没怎么被使用</td></tr> <tr><td style="text-align:left;"><a href="https://www.ietf.org/rfc/rfc6265.txt" target="_blank" rel="noopener noreferrer">RFC6265<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></td> <td style="text-align:left;">将网景公司制定的标准作为业界事实标准，重新定义 Cookie 标准后的产物</td></tr></tbody></table> <p>目前使用的最广泛的 Cookie 标准不是上述 RFC 中的任何一个...</p> <h3 id="相关首部"><a href="#相关首部" class="header-anchor">#</a> 相关首部</h3> <p>为 cookie 服务的常用首部字段有两个：</p> <ul><li>Set-Cookie，由 response 携带，指示 client 存储 cookie 到本地</li> <li>Cookie，由 request 携带，将本地 cookie 传给 server</li></ul> <p>P.S: 这两个首部没有在 HTTP/1.1 中定义。</p> <p><strong>Set-Cookie 首部</strong></p> <p>Set-Cookie 字段包括好些属性，如下是说明：</p> <table><thead><tr><th style="text-align:left;">属性</th> <th style="text-align:left;">说明</th> <th style="text-align:left;">版本</th> <th style="text-align:left;">举例</th></tr></thead> <tbody><tr><td style="text-align:left;">Expires</td> <td style="text-align:left;">到期时间，若不指定，则浏览器关闭时即删除</td> <td style="text-align:left;">网景、RFC6265</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">Domain</td> <td style="text-align:left;">cookie 适用的域名，若不指定，则默认为创建 cookie 的服务器的域名</td> <td style="text-align:left;">网景、RFC2965、RFC6265</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">Path</td> <td style="text-align:left;">cookie 适用的 path</td> <td style="text-align:left;">网景、RFC2965、RFC6265</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">Secure</td> <td style="text-align:left;">指示客户端仅当在 HTTPS 请求时才发送 Cookie</td> <td style="text-align:left;">网景、RFC2965、RFC6265</td> <td style="text-align:left;"><code>Set-Cookie: id=42; secure</code>意味着，告诉客户端只对 HTTPS 请求发送 cookie</td></tr> <tr><td style="text-align:left;">HttpOnly</td> <td style="text-align:left;">加以限制，使得 cookie 不能被 JavaScript 脚本访问</td> <td style="text-align:left;">RFC6265</td> <td style="text-align:left;">防止跨站脚本攻击（Cross-site scripting，XSS）</td></tr> <tr><td style="text-align:left;">Version</td> <td style="text-align:left;">必选，Set-Cookies2 使用</td> <td style="text-align:left;">RFC2965</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">Comment</td> <td style="text-align:left;">说明 server 将如何使用这个 cookie</td> <td style="text-align:left;">RFC2965</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">CommentURL</td> <td style="text-align:left;">更加详细说明 server 如何使用这个 cookie 的 url</td> <td style="text-align:left;">RFC2965</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">Discard</td> <td style="text-align:left;">如果提供了这个属性，客户端在程序终止时，需删除 cookie</td> <td style="text-align:left;">RFC2965</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">Max-Age</td> <td style="text-align:left;">和 Expires 作用类似</td> <td style="text-align:left;">RFC2965、RFC6265</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">Port</td> <td style="text-align:left;">cookie 适用的端口</td> <td style="text-align:left;">RFC2965</td> <td style="text-align:left;"></td></tr></tbody></table> <p>前五个属性是目前使用最广泛的。</p> <p>《HTTP 权威指南》将 cookie 笼统分为了两种类型：会话 cookie、持久 cookie。前者是一种临时 cookie，应用程序退出时，会话 cookie 就被删除了。持久 cookie 的生存时间更长一些，它们存储在硬盘上，应用程序退出时，仍然会保留它们。简单来说，当设置了 Discard，或者没有设置 Expires 或 Max-Age，就意味着这个 cookie 是一个会话 cookie。</p> <p><strong>Cookie 首部</strong></p> <p>Cookie 首部比较简单，用于将本地 cookie 传给 server，没啥好说的。</p> <h3 id="ios-与-cookie"><a href="#ios-与-cookie" class="header-anchor">#</a> iOS 与 Cookie</h3> <p>作为 iOS 开发者，我比较关心 iOS 中与 Cookie 相关的资源。iOS 里有两个与 HTTP cookie 相关的类型：</p> <ul><li><code>NSHTTPCookie</code>，用于封装 cookie，它的属性覆盖了上文表格中<code>Set-Cookie</code>的每一个属性</li> <li><code>NSHTTPCookieStorage</code>，单例类，提供了管理所有<code>NSHTTPCookie</code>对象的接口，在 OS X 里，cookie 是在所有程序中共享的，而在 iOS 中，cookie 只当当前应用中有效</li></ul> <h2 id="实体"><a href="#实体" class="header-anchor">#</a> 实体</h2> <p>实体（entity）包括实体首部（entity-header）和实体主体（entity-body）：</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/entity-body@2x.png" srcset="/image/entity-body@2x.png 2x" data-v-339c7bd5></div> <p>实体首部和实体主体之间被一个空白行（CRLF）分隔。</p> <p>P.S: CR（0d，\r）LF（0a，\n）。</p> <h3 id="划定报文结束"><a href="#划定报文结束" class="header-anchor">#</a> 划定报文结束</h3> <p>HTTP 1.1 与之前版本，划定报文结束的逻辑处理时不一样的。</p> <p>早期版本（1.1 之前版本），采用关闭连接的办法来划定报文的结束。即便这样，如果没有 Content-Length 首部，client 无法区分到底是报文结束时正常的连接关闭，还是报文传输中由于 server 出差错而导致的关闭，因此 Content-Length 还是非常必要的。</p> <p>对于 1.1 版本，由于 HTTP 默认为持久连接，无法再根据 TCP 报文来判断 body 传输完毕...</p> <h3 id="实体首部字段"><a href="#实体首部字段" class="header-anchor">#</a> 实体首部字段</h3> <p>实体首部还蛮多，如下表：</p> <table><thead><tr><th>首部</th> <th>说明</th> <th>例子</th> <th>报文类型</th></tr></thead> <tbody><tr><td>Allow</td> <td>通知 client 所支持的 request 方法类型（GET、POST）</td> <td>Allow: GET, HEAD</td> <td>Response</td></tr> <tr><td>Content-Type</td> <td>实体中所承载对象的类型</td> <td></td> <td>Response</td></tr> <tr><td>Content-Length</td> <td>如果有压缩，该值记录的是压缩后的大小（单位是字节），而不是原始大小；除非使用分块编码，否则该字段是带有实体的报文必须要使用的。</td> <td></td> <td>Response</td></tr> <tr><td>Content-Language</td> <td>与所传送对象最相匹配的人类语言</td> <td>Content-Language: zh-CN</td> <td>Response</td></tr> <tr><td>Content-Encoding</td> <td>通知 client 对 entity-body 所使用的内容编码方式，主要有 4 种：gzip、compress、deflate、identity（没有编码）</td> <td>Content-Encoding: gzip</td> <td>Response</td></tr> <tr><td>Content-Location</td> <td>给出与 entity-body 相对应的 URI，表明该 entity-body 取自何处</td> <td>Content-Location: http://www.example.com</td> <td>Response</td></tr> <tr><td>Content-MD5</td> <td>对 entity-body 的校验和，客户端会对接收的 entity-body 执行相同的 MD5 算法，然后与该字段值进行比较</td> <td></td> <td>Response</td></tr> <tr><td>Content-Range</td> <td>如果这是个部分 entity，该首部说明它是整体的哪个部分</td> <td></td> <td>Response</td></tr> <tr><td>Expires</td> <td>指定资源失效的时间</td> <td></td> <td>Response</td></tr> <tr><td>Last-Modified</td> <td>指定资源最终被修改的时间</td> <td></td> <td>Response</td></tr></tbody></table> <h2 id="内容编码"><a href="#内容编码" class="header-anchor">#</a> 内容编码</h2> <p>内容编码（Content Encoding）通常用于对实体内容进行压缩编码，目的是优化传输，例如用 gzip 压缩文本文件，能大幅减小体积。内容编码通常是选择性的，例如 jpg/ png 这类文件一般不开启，因为图片格式已经是高度压缩过的，再压一遍没什么效果不说还浪费 CPU。</p> <p>关于它，没啥好说的...</p> <h2 id="传输编码"><a href="#传输编码" class="header-anchor">#</a> 传输编码</h2> <p>曾一度弄不清楚内容编码和传输编码的区别，《图解 HTTP》这本书似乎也没讲清楚这个问题。再次翻看《HTTP 权威指南》才恍惚搞懂是怎么回事儿。</p> <p>除了《HTTP 权威指南》，博客<a href="https://imququ.com/post/transfer-encoding-header-in-http.html" target="_blank" rel="noopener noreferrer">HTTP 协议中的 Transfer-Encoding<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>也很清晰解释了何为传输编码，参考它们就好了，本文就不再对这个概念进行赘述。</p> <h3 id="传输编码相关首部"><a href="#传输编码相关首部" class="header-anchor">#</a> 传输编码相关首部</h3> <p>与传输编码相关的首部有两个：</p> <p><strong>Transfer-Encoding</strong></p> <p>该首部用于指定传输编码的编码方式，在 1.1 版本之前，HTTP 支持多种传输编码方式，但在 1.1 版本中，只支持一种传输编码方式 -- 分块传输编码，即<code>Transfer-Encoding</code>只能指定首部值<code>chunked</code>，即<code>Transfer-Encoding: chunked</code>。</p> <p>该首部一般在 server 发给的 client 的 response 报文中出现，告诉 client 已经对 body 进行了分块传输编码。</p> <p><strong>TE</strong></p> <p>Server 怎么知道它发送的分块编码报文是否能被 client 接受呢？<code>TE</code>首部正是用于解决这个问题，它用在 request 报文中，告知 server 可以使用哪些传输编码（当然，一般只有值<code>chunked</code>），譬如<code>TE: chunked</code>。</p> <p>P.S: <code>TE</code>首部还可以挂上<code>trailers</code>参数，下文会提到。</p> <h3 id="传输编码的作用"><a href="#传输编码的作用" class="header-anchor">#</a> 传输编码的作用</h3> <p>传输编码的意义有哪些呢？《HTTP 权威指南》总结了两点：</p> <ul><li>处理未知尺寸的报文。这是本文阐述的重点，详见下文的分块传输编码部分</li> <li>提高安全性，可以用传输编码把报文扰乱，然后在共享网络上传输；不过，由于 SSL/TLS 这种传输层安全体系的流行，很少要靠传输编码来处理安全性事务了</li></ul> <p>对于第二点 <em>提高安全性</em> ，我还不咋理解，如何通过传输编码提高安全性？暂且搁下吧，若有需要，以后再补充...</p> <h3 id="分块编码"><a href="#分块编码" class="header-anchor">#</a> 分块编码</h3> <p>对于分块编码，《HTTP 权威指南》的描述是：分块编码把报文分割为若干个大小已知的块。</p> <p>我刚开始以为分块编码是把一个 HTTP 报文拆分为多个报文，后来发现完全理解错了。</p> <h3 id="分块编码与持久连接"><a href="#分块编码与持久连接" class="header-anchor">#</a> 分块编码与持久连接</h3> <p>如上文所述，刚开始，我以为分块编码是把一个 HTTP 报文拆分为多个报文，若果真如此，那么持久连接显然是分块编码的先决条件...</p> <p>在非持久连接中，client 无需知道它正在读取的 body 的长度，只需读到 server 关闭连接为止，Content-Length 于 client 而言没那么必要。但一旦 HTTP 支持持久连接后，就不能再以连接关闭作为 body 读取完毕的哨兵事件了，因此非常依赖 server 提供的 Content-Length 首部。</p> <p>有时候，server 提供 Content-Length 是一件非常吃力的事情，借用<a href="https://imququ.com/post/transfer-encoding-header-in-http.html" target="_blank" rel="noopener noreferrer">HTTP 协议中的 Transfer-Encoding<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的举例说明：</p> <blockquote><p>例如实体来自于网络文件，或者由动态语言生成。这时候要想准确获取长度，只能开一个足够大的 buffer，等内容全部生成好再计算。但这样做一方面需要更大的内存开销，另一方面也会让客户端等更久。</p></blockquote> <p>分块编码就是为了解决这种困难而生的。它允许 server 把 body 逐块发送，说明每个 block 的大小即可。因为 body 是动态创建的，server 可以缓冲它的一部分，发送 block 及相应的 size 说明，然后在 body 发送完之前重复这个过程，最后，server 用大小为 0 的 block 作为 body 结束的信号，这样就可以继续保持连接，为下一个 response 做准备了。</p> <p>再次说明，这些过程仍然是在一个 message 上进行的，并没有将 message 拆分为多个。</p> <h3 id="分块编码报文的基本结构"><a href="#分块编码报文的基本结构" class="header-anchor">#</a> 分块编码报文的基本结构</h3> <p>分块编码报文的基本结构非常简单，和普通的 HTTP 报文差距仅在于 body 部分。body 部分由各个 block 组成，某个 block 包含一个长度值和该 block 的数据，长度值和 block 数据使用 CRLF 分隔开，长度值是十六进制形式，block 数据大小以字节计。最后一个 block 有些特别，它的长度值为 0，无数据部分，表示 body 结束。如下图所示：</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/transfor-encoding-trunk@2x.png" srcset="/image/transfor-encoding-trunk@2x.png 2x" data-v-339c7bd5></div> <h3 id="分块报文的拖挂"><a href="#分块报文的拖挂" class="header-anchor">#</a> 分块报文的拖挂</h3> <p>如上图所示，在最后一个 block 后面还有一个拖挂（trailer），这个名字挺怪的；我的理解，server 可以在分块报文的末尾加上可选元数据，数据格式 HTTP 不作要求。</p> <p>上图的拖挂是<code>Content-MD5</code>首部，只是因为<code>Content-MD5</code>只有在 body 全部生成完了才能计算，所以把它放在 trailer 里是合适的选择。</p> <p>对于 client 来说，它可以对 trailer 不做任何处理；对于 server 而言，它如何知道 client 是否会处理 trailer 呢？如果不处理，硬塞一个 trailer 岂不浪费？HTTP 的 TE 首部解决了这个问题，TE 首部除了告诉 server 它接受的传输编码方式之外，它还可以指定 trailers 属性，以告诉 server 它可以处理分块报文中携带的拖挂，譬如：<code>TE: trailers</code>。</p> <h2 id="q-a"><a href="#q-a" class="header-anchor">#</a> Q &amp; A</h2> <p>这部分以 Q &amp; A 的形式补充对 HTTP 基本概念的理解。</p> <h3 id="如何在-http-消息中指定-url"><a href="#如何在-http-消息中指定-url" class="header-anchor">#</a> 如何在 HTTP 消息中指定 URL</h3> <p>HTTP 基于 URL 定位网络资源，有多种方式指定 URL。</p> <p>请求行（Request-Line）的格式如下：</p> <div class="language-textile extra-class"><pre class="language-textile"><code><span class="token phrase">Request<span class="token inline"><span class="token punctuation">-</span><span class="token deleted">Line = Method SP Request</span><span class="token punctuation">-</span></span>URL SP HTTP-Version CRLF
;
; SP表示“分隔符”
; CRLF表示“结束符”
</span></code></pre></div><p>显然，可以在 Request-Line 中指定 URL，譬如这样：</p> <div class="language-textile extra-class"><pre class="language-textile"><code><span class="token phrase">; 请求行
GET http://example.com/index.html HTTP/1.1
</span></code></pre></div><p>也可以这样：</p> <div class="language-textile extra-class"><pre class="language-textile"><code><span class="token phrase">; 请求行
GET /index.html HTTP/1.1
; 首部字段Host中写明网络域名或IP地址
Host: example.com
</span></code></pre></div><h3 id="get-请求可以携带消息主体吗"><a href="#get-请求可以携带消息主体吗" class="header-anchor">#</a> GET 请求可以携带消息主体吗</h3> <p>据我所知，RFC 文档没有明确表明 GET 请求不能携带 message-body，综合各种说法，我的判断是：有些 server 不处理 GET 的 message-body 信息，有些 server 会处理。总之，与具体的实现有关。</p> <p>参考：</p> <ul><li><a href="http://stackoverflow.com/questions/978061/http-get-with-request-body" target="_blank" rel="noopener noreferrer">http://stackoverflow.com/questions/978061/http-get-with-request-body<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://stackoverflow.com/questions/5216567/is-this-statement-correct-http-get-method-always-has-no-message-body" target="_blank" rel="noopener noreferrer">http://stackoverflow.com/questions/5216567/is-this-statement-correct-http-get-method-always-has-no-message-body<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="client-可以发送分块编码的报文给-server-吗"><a href="#client-可以发送分块编码的报文给-server-吗" class="header-anchor">#</a> Client 可以发送分块编码的报文给 server 吗</h3> <p>Client 也可以发送分块的数据给 server。只是，client 事先不知道 server 是否接受分块编码（这是因为 server 不会在给 client 响应中发送 TE 首部），所以 server 必须做好 server 用 411 Length Required（需要 Content-Length 首部）响应来拒绝分块请求的准备。</p></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.50bca889.js" defer></script><script src="/assets/js/5.081d1701.js" defer></script><script src="/assets/js/71.a320347a.js" defer></script><script src="/assets/js/4.a7413ce2.js" defer></script>
  </body>
</html>
