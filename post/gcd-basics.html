<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>GCD 基础知识 | 张不坏的博客</title>
    <meta name="description" content="Just For Fun">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.37bfab3d.css" as="style"><link rel="preload" href="/assets/js/app.50bca889.js" as="script"><link rel="preload" href="/assets/js/5.081d1701.js" as="script"><link rel="preload" href="/assets/js/66.809078da.js" as="script"><link rel="prefetch" href="/assets/js/10.7bb33f06.js"><link rel="prefetch" href="/assets/js/100.014ff06c.js"><link rel="prefetch" href="/assets/js/101.28f11de0.js"><link rel="prefetch" href="/assets/js/102.be9d2e87.js"><link rel="prefetch" href="/assets/js/103.a1210d81.js"><link rel="prefetch" href="/assets/js/104.7101a956.js"><link rel="prefetch" href="/assets/js/105.833e6f80.js"><link rel="prefetch" href="/assets/js/106.978e1fc0.js"><link rel="prefetch" href="/assets/js/107.5af47fd0.js"><link rel="prefetch" href="/assets/js/108.efc3ce89.js"><link rel="prefetch" href="/assets/js/109.a69d6b5a.js"><link rel="prefetch" href="/assets/js/11.2de4afc9.js"><link rel="prefetch" href="/assets/js/110.30984b63.js"><link rel="prefetch" href="/assets/js/12.bfc099bd.js"><link rel="prefetch" href="/assets/js/13.20253e0d.js"><link rel="prefetch" href="/assets/js/14.67131b1c.js"><link rel="prefetch" href="/assets/js/15.1af26cbd.js"><link rel="prefetch" href="/assets/js/16.4b261ee0.js"><link rel="prefetch" href="/assets/js/17.1216332f.js"><link rel="prefetch" href="/assets/js/18.c0159773.js"><link rel="prefetch" href="/assets/js/19.0f007f87.js"><link rel="prefetch" href="/assets/js/2.b4633a05.js"><link rel="prefetch" href="/assets/js/20.4b295001.js"><link rel="prefetch" href="/assets/js/21.0c46767c.js"><link rel="prefetch" href="/assets/js/22.a5e065ea.js"><link rel="prefetch" href="/assets/js/23.f43a6a7e.js"><link rel="prefetch" href="/assets/js/24.245f4f15.js"><link rel="prefetch" href="/assets/js/25.618f74a1.js"><link rel="prefetch" href="/assets/js/26.274a606b.js"><link rel="prefetch" href="/assets/js/27.c2d8fe18.js"><link rel="prefetch" href="/assets/js/28.5c522d2a.js"><link rel="prefetch" href="/assets/js/29.c90fdb1a.js"><link rel="prefetch" href="/assets/js/3.9babd8f1.js"><link rel="prefetch" href="/assets/js/30.1ccbdebc.js"><link rel="prefetch" href="/assets/js/31.acf3eca6.js"><link rel="prefetch" href="/assets/js/32.ccfdc859.js"><link rel="prefetch" href="/assets/js/33.9b262756.js"><link rel="prefetch" href="/assets/js/34.c59a4044.js"><link rel="prefetch" href="/assets/js/35.2b10fefb.js"><link rel="prefetch" href="/assets/js/36.2daeeb7b.js"><link rel="prefetch" href="/assets/js/37.d649866c.js"><link rel="prefetch" href="/assets/js/38.aba1ac95.js"><link rel="prefetch" href="/assets/js/39.58a95fd1.js"><link rel="prefetch" href="/assets/js/4.a7413ce2.js"><link rel="prefetch" href="/assets/js/40.8ef4d374.js"><link rel="prefetch" href="/assets/js/41.5799de7a.js"><link rel="prefetch" href="/assets/js/42.b7ee7489.js"><link rel="prefetch" href="/assets/js/43.28a65d64.js"><link rel="prefetch" href="/assets/js/44.90f92ea2.js"><link rel="prefetch" href="/assets/js/45.30b683fd.js"><link rel="prefetch" href="/assets/js/46.f57ccc19.js"><link rel="prefetch" href="/assets/js/47.7a82bd74.js"><link rel="prefetch" href="/assets/js/48.72503020.js"><link rel="prefetch" href="/assets/js/49.3a4ba077.js"><link rel="prefetch" href="/assets/js/50.0c3297f3.js"><link rel="prefetch" href="/assets/js/51.e9ba9363.js"><link rel="prefetch" href="/assets/js/52.473ee9ff.js"><link rel="prefetch" href="/assets/js/53.166d6e7a.js"><link rel="prefetch" href="/assets/js/54.78af3662.js"><link rel="prefetch" href="/assets/js/55.f0d54751.js"><link rel="prefetch" href="/assets/js/56.5de81531.js"><link rel="prefetch" href="/assets/js/57.6e18322f.js"><link rel="prefetch" href="/assets/js/58.1fccc879.js"><link rel="prefetch" href="/assets/js/59.773775e1.js"><link rel="prefetch" href="/assets/js/6.0c9cc532.js"><link rel="prefetch" href="/assets/js/60.0d665185.js"><link rel="prefetch" href="/assets/js/61.d9ae36dc.js"><link rel="prefetch" href="/assets/js/62.fb5e3b65.js"><link rel="prefetch" href="/assets/js/63.5ace8fda.js"><link rel="prefetch" href="/assets/js/64.d44fb0af.js"><link rel="prefetch" href="/assets/js/65.ed8fe56f.js"><link rel="prefetch" href="/assets/js/67.2489499e.js"><link rel="prefetch" href="/assets/js/68.e3ee952d.js"><link rel="prefetch" href="/assets/js/69.071411f8.js"><link rel="prefetch" href="/assets/js/7.8188415c.js"><link rel="prefetch" href="/assets/js/70.be8269cf.js"><link rel="prefetch" href="/assets/js/71.a320347a.js"><link rel="prefetch" href="/assets/js/72.f4fda48b.js"><link rel="prefetch" href="/assets/js/73.0f9f9284.js"><link rel="prefetch" href="/assets/js/74.b4028d07.js"><link rel="prefetch" href="/assets/js/75.6d63415f.js"><link rel="prefetch" href="/assets/js/76.d5b4df24.js"><link rel="prefetch" href="/assets/js/77.62b794e1.js"><link rel="prefetch" href="/assets/js/78.63e767ab.js"><link rel="prefetch" href="/assets/js/79.45056905.js"><link rel="prefetch" href="/assets/js/8.20d7cb0f.js"><link rel="prefetch" href="/assets/js/80.e06c5521.js"><link rel="prefetch" href="/assets/js/81.bc82bd01.js"><link rel="prefetch" href="/assets/js/82.4aeb6081.js"><link rel="prefetch" href="/assets/js/83.3ed6146f.js"><link rel="prefetch" href="/assets/js/84.f2aff9f4.js"><link rel="prefetch" href="/assets/js/85.2b8f4e50.js"><link rel="prefetch" href="/assets/js/86.27aea1da.js"><link rel="prefetch" href="/assets/js/87.7f5dc71e.js"><link rel="prefetch" href="/assets/js/88.9ca6511c.js"><link rel="prefetch" href="/assets/js/89.e8f54ad1.js"><link rel="prefetch" href="/assets/js/9.ee6c43f7.js"><link rel="prefetch" href="/assets/js/90.9abac718.js"><link rel="prefetch" href="/assets/js/91.9d8f5f36.js"><link rel="prefetch" href="/assets/js/92.2277b907.js"><link rel="prefetch" href="/assets/js/93.efca2f57.js"><link rel="prefetch" href="/assets/js/94.e9cc0386.js"><link rel="prefetch" href="/assets/js/95.fa3326f7.js"><link rel="prefetch" href="/assets/js/96.82bafc57.js"><link rel="prefetch" href="/assets/js/97.da22d13e.js"><link rel="prefetch" href="/assets/js/98.d745e5ec.js"><link rel="prefetch" href="/assets/js/99.79a6f693.js">
    <link rel="stylesheet" href="/assets/css/0.styles.37bfab3d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><div class="navbar"><div class="navbar-content"><div class="slogan">Valar Morghulis</div> <div class="links"><span class="link-item"><a href="/">首页</a></span> <span class="link-item"><a href="/category/iOS/">iOS</a></span> <span class="link-item"><a href="/category/other/">其他</a></span></div></div></div> <div class="content-header"><div class="post-title">GCD 基础知识</div> <div class="post-info">2015-01-26 • iOS</div></div> <div class="content content__default"><p>本文罗列一下 GCD 基础知识。</p> <h2 id="并行和并发"><a href="#并行和并发" class="header-anchor">#</a> 并行和并发</h2> <p>在英文世界里，<em>并行</em> 和 <em>并发</em> 的区别比较清晰，<em>并行</em> 对应 <em>parallelism</em>，<em>并发</em> 对应 <em>concurrency</em>；但在中文世界里二者仅一字之差，两个概念非常容易弄混淆。</p> <p>各种资料对 <em>并行</em> 和 <em>并发</em> 有各种各样的解释和比喻。我比较喜欢的一种，是播客节目<a href="http://ipn.li/kernelpanic/13" target="_blank" rel="noopener noreferrer">内核恐慌<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中的主播 Rio 的描述，大概意思是：</p> <blockquote><p><em>并发</em> 和 <em>并行</em> 是一种计算模型，使得计算机能够在同一时间处理多个任务；并发表示逻辑概念上的同时，并行表示物理概念上的同时。</p></blockquote> <p>简单来说，若说两个任务 A 和 B 并发执行，则表示任务 A 和任务 B 在同一时间段里被执行（更多的可能是二者交替执行）；若说任务 A 和 B 并行执行，则表示任务 A 和任务 B 在同时被执行（这要求计算机有多个运算器）。</p> <p>一句话：并行要求并发，但并发并不能保证并行。</p> <p>P.S: 关于并发和并行，<a href="https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1" target="_blank" rel="noopener noreferrer">Grand Central Dispatch In-Depth: Part 1/2<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中有更详细生动的图文解释。</p> <h2 id="dispatch-queue-介绍"><a href="#dispatch-queue-介绍" class="header-anchor">#</a> Dispatch Queue 介绍</h2> <p>Dispatch Queue 是 GCD 处理异步任务和并发任务的关键载体，简而言之，在 GCD 中，将 task 放入某个 Dispatch Queue 中，然后等待系统去处理之。</p> <p>Dispatch queue 是 object-like structure，也就是说 Dispatch queue 在 Objective-C 中不是类结构，而是类似于类结构。dispatch queue 对 task 的管理都遵循 FIFO。GCD 提供了一些公共的 dispatch queue，但是用户也可以自定义一些 dispatch queue；iOS 对 dispatch queue 做了归类，分为三类：</p> <ul><li>Serial Dispatch Queue</li> <li>Concurrent Dispatch Queue</li> <li>Main Dispatch Queue</li></ul> <h3 id="serial-dispatch-queue"><a href="#serial-dispatch-queue" class="header-anchor">#</a> Serial Dispatch Queue</h3> <p>顾名思义，serial dispatch queue 中的 block 按照先进先出（FIFO）的顺序去执行，实际上为单线程执行。即每次从 queue 中取出一个 task 进行处理；用户可以根据需要创建任意多的 serial dispatch queue，serial dispatch queue 彼此之间是并发的；</p> <p>创建 serial dispatch queue 使用<code>dispatch_queue_create</code>方法，指定其第二个参数为<code>DISPATCH_QUEUE_SERIAL</code>（即<code>NULL</code>）即可：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code>dispatch_queue_t queue <span class="token operator">=</span> <span class="token function">dispatch_queue_create</span><span class="token punctuation">(</span><span class="token string">&quot;com.example.MySerialQueue&quot;</span><span class="token punctuation">,</span> DISPATCH_QUEUE_SERIAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注意：如果不算“Main Dispatch Queue”，系统中不存在所谓的 global serial dispatch queue。</p> <p>P.S: main dispatch queue 其实也算 serial dispatch queue，后文有述。</p> <h3 id="concurrent-dispatch-queue"><a href="#concurrent-dispatch-queue" class="header-anchor">#</a> Concurrent Dispatch Queue</h3> <p>相对于 Serial Dispatch Queue，Concurrent Dispatch Queue 一次性并发执行一个或者多个 task；和 Serial Dispatch Queue 不同，系统提供了四个 global concurrent queue，使用<code>dispatch_get_global_queue</code>函数就可以获取这些 global concurrent queue。</p> <p>和 Serial Dispatch Queue 一样，用户也可以根据需要自己定义 concurrent queue；创建 concurrent dispatch queue 也使用<code>dispatch_queue_create</code>方法，所不同的是需要指定其第二个参数为<code>DISPATCH_QUEUE_CONCURRENT</code>：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code>dispatch_queue_t queue <span class="token operator">=</span> <span class="token function">dispatch_queue_create</span><span class="token punctuation">(</span><span class="token string">&quot;com.example.MyConcurrentQueue&quot;</span><span class="token punctuation">,</span> DISPATCH_QUEUE_CONCURRENT<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>P.S: 根据我的理解，对于 concurrent queue，类似于其他语言里的线程池，其管理的 task 可能在多个不同 thread 上执行，至于 dispatch queue 管理多少个 thread 是未知的，这要视系统资源而定，用户无需为此烦扰。</p> <h3 id="main-dispatch-queue"><a href="#main-dispatch-queue" class="header-anchor">#</a> Main Dispatch Queue</h3> <p>关于 Main Dispatch Queue，《Concurrency Programming Guide》（Apple 官方文档）的描述如下：</p> <blockquote><p>The main dispatch queue is a globally available serial queue that executes tasks on the application’s main thread.</p></blockquote> <p>根据我的理解，application 的主要任务（譬如 UI 管理之类的）都在 main dispatch queue 中完成；根据文档的描述，main dispatch queue 中的 task 都在一个 thread 中运行，即 application’s main thread（thread 1）。</p> <p>所以，如果想要更新 UI，则必须在 main dispatch queue 中处理，获取 main dispatch queue 也很容易，调用<code>dispatch_get_main_queue()</code>函数即可。</p> <h3 id="关于-dispatch-queues-的一些误解"><a href="#关于-dispatch-queues-的一些误解" class="header-anchor">#</a> 关于 Dispatch Queues 的一些误解</h3> <p>在学习 GCD 过程中，我一路上有许多关于 dispatch 的错误理解，如下是总结：</p> <ul><li>不存在所谓的 <em>同步队列</em> 和 <em>异步队列</em></li></ul> <p>同步或异步描述的是 task 与其上下文之间的关系，所以，我觉得 <em>同步队列</em> 和 <em>异步队列</em> 对于 Objective-C 的 GCD 而言是不靠谱的概念。</p> <p>P.S: 补充！虽然没有 <em>同步队列</em> 和 <em>异步队列</em> 的说法，但是有 <em>同步串行队列</em> 和 <em>同步并发队列</em> 的概念。</p> <ul><li>Serial Dispatch Queue 上的 tasks 并非只在同一个 thread 上执行</li></ul> <p>吾尝以为 serial queue 上的 tasks 都是在同一个 thread 上运行，后来明白了不是这样的，对于那些同步请求的任务，譬如使用 dispatch_sync 函数添加到 serial dispatch queue 中的任务，其运行的 task 往往与所在的上下文是同一个 thread；对于那些异步请求的任务，譬如使用 dispatch_async 函数添加到 serial dispatch queue 中的任务，其运行的 task 往往是另一个的 thread。举例说明：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>viewDidLoad <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token keyword">super</span> viewDidLoad<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    dispatch_queue_t aSerialQueue <span class="token operator">=</span> <span class="token function">dispatch_queue_create</span><span class="token punctuation">(</span><span class="token string">&quot;haha&quot;</span><span class="token punctuation">,</span> DISPATCH_QUEUE_SERIAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">dispatch_sync</span><span class="token punctuation">(</span>aSerialQueue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
        <span class="token comment">// block 1</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;current 1: %@&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">dispatch_async</span><span class="token punctuation">(</span>aSerialQueue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
        <span class="token comment">// block 2</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;current 2: %@&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
    
<span class="token comment">//</span>
<span class="token comment">// 执行结果：</span>
<span class="token comment">// current 1: &lt;NSThread: 0x7f8f397152f0&gt;{number = 1, name = main}</span>
<span class="token comment">// current 2: &lt;NSThread: 0x7f8f39464db0&gt;{number = 2, name = (null)}</span>
</code></pre></div><p>block 1 和 block 2 都由同一个 serial dispatch queue 管理，但它们的执行线程显然不同，前者的执行线程是 thread 1，后者的执行线程是 thread 2。</p> <ul><li>dispatch queue 和 thread 并不存在一对一或者一对多的关系</li></ul> <p>通过设置断点等测试手段可以知道可能多个 dispatch queue 共用一个 thread，也可能一个 dispatch queue 中的 tasks 在多个不同 threads 上执行。</p> <p>总之，根据我的理解，thread 和 dispatch queue 之间没有从属关系。</p> <h2 id="dispatch-sync-和-dispatch-async"><a href="#dispatch-sync-和-dispatch-async" class="header-anchor">#</a> dispatch_sync 和 dispatch_async</h2> <p>在 GCD 中，<code>dispatch_sync</code>和<code>dispatch_async</code>是两个函数，前者用于派发同步任务，后者用于派发异步任务，二者使用格式如下：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code><span class="token comment">// dispatch task synchronously</span>
<span class="token function">dispatch_sync</span><span class="token punctuation">(</span>someQueue1<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token comment">// do something 1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// do something 2</span>
</code></pre></div><div class="language-objectivec extra-class"><pre class="language-objectivec"><code><span class="token comment">// dispatch task asynchronously</span>
<span class="token function">dispatch_async</span><span class="token punctuation">(</span>someQueue2<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token comment">// do something 3</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// do something 4</span>
</code></pre></div><p><code>do something 2</code>一定会在<code>do something 1</code>完成之后执行，即所谓的<strong>同步</strong>。当执行到<code>dispatch_sync(...)</code>时，其上下文被阻塞，直到<code>dispatch_sync</code>派发的 block 被执行完毕。</p> <p>根据我的理解：<strong>dispatch_sync 派发的 block 的执行线程和 dispatch_sync 上下文线程是同一个线程</strong>。</p> <p>P.S: 这个说法还没有找到权威的、直接明了的佐证。</p> <p>而<code>do something 4</code>会立即执行，而不会等到<code>do something 3</code>执行完，即所谓<strong>异步</strong>。当执行到<code>dispatch_async(...)</code>时，其上下文不被阻塞，继续运行。</p> <p>根据我的理解：<code>do something 3</code>和<code>do something 4</code>的执行线程往往不是同一个，即<strong>dispatch_async 派发的 block 的执行线程和 dispatch_async 上下文线程不是同一个线程</strong>。</p> <p>来看一个示例，如下有一段代码：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code><span class="token comment">// 1. create a serial dispatch queue</span>
dispatch_queue_t serial_queue<span class="token operator">=</span>
<span class="token function">dispatch_queue_create</span><span class="token punctuation">(</span><span class="token string">&quot;com.zhangbuhuai.test&quot;</span><span class="token punctuation">,</span> DISPATCH_QUEUE_SERIAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Thread 1</span>
    
<span class="token comment">// 2. add tasks to serial dispatch queue</span>
<span class="token comment">// 1) add a task synchronously</span>
<span class="token function">dispatch_sync</span><span class="token punctuation">(</span>serial_queue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 休眠3秒</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;task 1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// Thread 1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2) add a task synchronously too</span>
<span class="token function">dispatch_sync</span><span class="token punctuation">(</span>serial_queue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;task 2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// Thread 1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 3) add a task asynchronously</span>
<span class="token function">dispatch_async</span><span class="token punctuation">(</span>serial_queue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;task 3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// Thread x  (x != 1)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 4) add a task asynchronously too</span>
<span class="token function">dispatch_async</span><span class="token punctuation">(</span>serial_queue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;task 4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// Thread x  (x != 1)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;test end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// Thread 1</span>
</code></pre></div><p>假设创建<code>serial_queue</code>所在的上下文的执行线程为 Thread 1，则测试结果是：<code>NSLog(@&quot;task 1&quot;)</code>和<code>NSLog(@&quot;task 2&quot;)</code>也都在 Thread 1 中执行，而<code>NSLog(@&quot;task 3&quot;)</code>和<code>NSLog(@&quot;task 4&quot;)</code>在别的 Thread 中执行。</p> <p>执行结果：</p> <div class="language-textile extra-class"><pre class="language-textile"><code><span class="token phrase">task 1
task 2
test end
task 3
task 4
</span></code></pre></div><p>结果说明，对于 serial dispatch queue 中的 tasks，无论是同步派发还是异步派发，其执行顺序都遵循 FIFO；同样，这个示例也可以直观阐述<code>dispatch_sync</code>和<code>dispatch_async</code>的不同效果。</p> <p><strong>dispatch_sync 和 dispatch_async 的使用时机</strong></p> <p>在大多数时候，<code>dispatch_sync</code>和<code>dispatch_async</code>的使用时机非常清晰的：</p> <ul><li>如果派发的 task 耗时长，不想让上下文线程被阻塞，就用<code>dispatch_async</code></li> <li>如果要处理的代码比较短，想要实现代码保护（线程安全），选用<code>dispatch_sync</code></li></ul> <p>P.S: 关于<code>dispatch_sync</code>与线程同步（代码保护）之间的关系，<s>以后补充</s>。</p> <p>但有些时候，使用<code>dispatch_sync</code>或者<code>dispatch_async</code>都可以的情况下（譬如实现 setter），就不是那么好选择了。</p> <p>在《Effective Objective-C 2.0》Item 41（中文版 P169）中看到非常重要的一句话：</p> <blockquote><p>...，因为在执行异步派发时，需要拷贝块。</p></blockquote> <p>我对这句话的理解是：</p> <ul><li>执行同步派发（<code>dispatch_sync</code>）时，是不需要拷贝 block 的，这是因为<code>dispatch_sync</code>中所派发的 task 往往和当前上下文所处同一个 Thread</li> <li>执行异步派发（<code>dispatch_async</code>）时，需要拷贝 block，这是因为<code>dispatch_async</code>中所派发的 task 往往和当前上下文不同于一个 Thread</li></ul> <p>所以，当选择<code>dispatch_sync</code>或者<code>dispatch_async</code>都可以的情况下，站在效率的角度，如果拷贝 block 的时间成本过高，则使用<code>dispatch_sync</code>；如果拷贝 block 的时间成本远低于执行 block 的时间成本，则使用<code>dispatch_async</code>。</p> <p>如上所引用的「...，因为在执行异步派发时，需要拷贝块」这句话，在某种程度上佐证了上文提到的两个说法：</p> <ul><li><code>dispatch_sync</code>派发的 block 的执行线程和<code>dispatch_sync</code>上下文线程是同一个线程；</li> <li><code>dispatch_async</code>派发的 block 的执行线程和<code>dispatch_async</code>上下文线程不是同一个线程；</li></ul> <p>----------------------如下是补充内容----------------------</p> <h2 id="使用串行同步队列保护代码"><a href="#使用串行同步队列保护代码" class="header-anchor">#</a> 使用串行同步队列保护代码</h2> <p>先来看一段代码：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code><span class="token operator">-</span> <span class="token punctuation">(</span>NSURLSessionDataTask <span class="token operator">*</span><span class="token punctuation">)</span>dataTaskWithRequest<span class="token punctuation">:</span><span class="token punctuation">(</span>NSURLRequest <span class="token operator">*</span><span class="token punctuation">)</span>request
                            completionHandler<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token punctuation">)</span><span class="token punctuation">(</span>NSURLResponse <span class="token operator">*</span>response<span class="token punctuation">,</span> id responseObject<span class="token punctuation">,</span> NSError <span class="token operator">*</span>error<span class="token punctuation">)</span><span class="token punctuation">)</span>completionHandler
<span class="token punctuation">{</span>
    __block NSURLSessionDataTask <span class="token operator">*</span>dataTask <span class="token operator">=</span> nil<span class="token punctuation">;</span>
    <span class="token function">dispatch_sync</span><span class="token punctuation">(</span><span class="token function">url_session_manager_creation_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>  <span class="token comment">// mark 1</span>
        dataTask <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">self</span><span class="token punctuation">.</span>session dataTaskWithRequest<span class="token punctuation">:</span>request<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token punctuation">[</span><span class="token keyword">self</span> addDelegateForDataTask<span class="token punctuation">:</span>dataTask completionHandler<span class="token punctuation">:</span>completionHandler<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// mark 2</span>
    
    <span class="token keyword">return</span> dataTask<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码是在 AFNetworking 框架的<code>AFURLSessionManager.m</code>中定义的，用于创建 Data Task（<code>NSURLSessionDataTask</code>实例），这短短几行代码的逻辑是：</p> <ol><li><code>mark 1</code>以同步派发的方式提交任务 – 创建一个<code>NSURLSessionDataTask</code>实例；</li> <li><code>mark 2</code>处被阻塞；</li> <li><code>NSURLSessionDataTask</code>实例创建完成，继续执行<code>mark 2</code>及后续代码；</li></ol> <p>曾经对这几行代码比较疑惑：为什么使用<code>dispatch_sync</code>派发任务呢？</p> <p>现在是能够理解了，上述<code>url_session_manager_creation_queue()</code>函数返回的其实是一个 serial dispatch queue，这种组合（<code>dispatch_sync</code>+串行队列）即所谓的<strong>串行同步队列</strong>。串行同步队列常被用来保护临界资源，确保临界资源的线程安全，作用类似于同步锁，估摸着<code>dataTaskWithRequest:</code>并不是一个线程安全方法。</p> <h2 id="使用-dispatch-sync-的注意事项"><a href="#使用-dispatch-sync-的注意事项" class="header-anchor">#</a> 使用 dispatch_sync 的注意事项</h2> <p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html" target="_blank" rel="noopener noreferrer">Concurrency Programming Guide<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>有包括关于使用<code>dispatch_sync</code>的提示：</p> <blockquote><p>Important: You should never call the dispatch_sync or dispatch_sync_f function from a task that is executing in the same queue that you are planning to pass to the function. This is particularly important for serial queues, which are guaranteed to deadlock, but should also be avoided for concurrent queues.</p></blockquote> <p>简单来说，在<code>dispatch_sync</code>嵌套使用时要注意：不能在一个嵌套中使用同一个 serial dispatch queue，因为会发生死锁；</p> <p>假设有如下这么一段代码要执行：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>test <span class="token punctuation">{</span>
    dispatch_queue_t aSerialDispatchQueue <span class="token operator">=</span>
    <span class="token function">dispatch_queue_create</span><span class="token punctuation">(</span><span class="token string">&quot;I.am.an.iOS.developer&quot;</span><span class="token punctuation">,</span> DISPATCH_QUEUE_SERIAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
       
    <span class="token function">dispatch_sync</span><span class="token punctuation">(</span>aSerialDispatchQueue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
        <span class="token comment">// block 1</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;Good Night, Benjamin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">dispatch_sync</span><span class="token punctuation">(</span>aSerialDispatchQueue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
            <span class="token comment">// block 2</span>
            <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;Good Night, Daisy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>自己试着执行以下就会发现：「<code>Good Night, Daisy</code>」这一句永远都无法被打印出来，原因很简单，程序产生了死锁。为什么会产生死锁呢？</p> <p>可以想象<code>aSerialDispatchQueue</code>在底层实现中有一把锁，这把锁确保 serial dispatch queue 中只有一个 block 被执行，当执行到<code>block 1</code>代码时，这把锁为<code>block 1</code>所持有，当<code>block 1</code>执行完了，会释放之；然而<code>block 1</code>同步派发了一个任务<code>block 2</code>，同步派发意味着<code>block 1</code>会被阻塞，直到<code>block 2</code>被执行完成；但是这里产生了矛盾，<code>block 2</code>顺利执行的前提是<code>aSerialDispatchQueue</code>的这把锁被<code>block 1</code>释放，但是<code>block 1</code>释放这把锁的前提是<code>block 1</code>执行完成...这就是典型的 dead lock。</p> <p>这一段代码还好，比较容易避免，但是如果对 GCD 理解不深，更多的时候容易写出如下代码：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>viewDidLoad <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token keyword">super</span> viewDidLoad<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 巴拉巴拉，做了很多事情</span>
    
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;Good Night, Benjamin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dispatch_sync</span><span class="token punctuation">(</span><span class="token function">dispatch_get_main_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
        <span class="token comment">// refresh UI</span>
    
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;Good Night, Daisy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码的问题其实和上一段代码类似，只不过这里的 serial dispatch queue 恰好是 main queue。</p> <p>上述的死锁问题主要针对<strong>同步串行队列</strong>，对于<strong>同步并发队列</strong>，根据我的理解应该不存在这个 deadlock 问题，但是《Concurrency Programming Guide》明确说了：</p> <blockquote><p>...This is particularly important for serial queues, which are guaranteed to deadlock, but should also be avoided for concurrent queues.</p></blockquote> <p>P.S: 目前还不理解这个说辞。</p> <h2 id="本文参考"><a href="#本文参考" class="header-anchor">#</a> 本文参考</h2> <ul><li><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="noopener noreferrer">Concurrency Programming Guide<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://book.douban.com/subject/21370593/" target="_blank" rel="noopener noreferrer">Effective Objective-C 2.0<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.50bca889.js" defer></script><script src="/assets/js/5.081d1701.js" defer></script><script src="/assets/js/66.809078da.js" defer></script>
  </body>
</html>
