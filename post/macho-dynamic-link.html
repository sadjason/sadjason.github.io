<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Mach-O 与动态链接 | 张不坏的博客</title>
    <meta name="description" content="Just For Fun">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.37bfab3d.css" as="style"><link rel="preload" href="/assets/js/app.50bca889.js" as="script"><link rel="preload" href="/assets/js/5.081d1701.js" as="script"><link rel="preload" href="/assets/js/77.62b794e1.js" as="script"><link rel="preload" href="/assets/js/4.a7413ce2.js" as="script"><link rel="prefetch" href="/assets/js/10.7bb33f06.js"><link rel="prefetch" href="/assets/js/100.014ff06c.js"><link rel="prefetch" href="/assets/js/101.28f11de0.js"><link rel="prefetch" href="/assets/js/102.be9d2e87.js"><link rel="prefetch" href="/assets/js/103.a1210d81.js"><link rel="prefetch" href="/assets/js/104.7101a956.js"><link rel="prefetch" href="/assets/js/105.833e6f80.js"><link rel="prefetch" href="/assets/js/106.978e1fc0.js"><link rel="prefetch" href="/assets/js/107.5af47fd0.js"><link rel="prefetch" href="/assets/js/108.efc3ce89.js"><link rel="prefetch" href="/assets/js/109.a69d6b5a.js"><link rel="prefetch" href="/assets/js/11.2de4afc9.js"><link rel="prefetch" href="/assets/js/110.30984b63.js"><link rel="prefetch" href="/assets/js/12.bfc099bd.js"><link rel="prefetch" href="/assets/js/13.20253e0d.js"><link rel="prefetch" href="/assets/js/14.67131b1c.js"><link rel="prefetch" href="/assets/js/15.1af26cbd.js"><link rel="prefetch" href="/assets/js/16.4b261ee0.js"><link rel="prefetch" href="/assets/js/17.1216332f.js"><link rel="prefetch" href="/assets/js/18.c0159773.js"><link rel="prefetch" href="/assets/js/19.0f007f87.js"><link rel="prefetch" href="/assets/js/2.b4633a05.js"><link rel="prefetch" href="/assets/js/20.4b295001.js"><link rel="prefetch" href="/assets/js/21.0c46767c.js"><link rel="prefetch" href="/assets/js/22.a5e065ea.js"><link rel="prefetch" href="/assets/js/23.f43a6a7e.js"><link rel="prefetch" href="/assets/js/24.245f4f15.js"><link rel="prefetch" href="/assets/js/25.618f74a1.js"><link rel="prefetch" href="/assets/js/26.274a606b.js"><link rel="prefetch" href="/assets/js/27.c2d8fe18.js"><link rel="prefetch" href="/assets/js/28.5c522d2a.js"><link rel="prefetch" href="/assets/js/29.c90fdb1a.js"><link rel="prefetch" href="/assets/js/3.9babd8f1.js"><link rel="prefetch" href="/assets/js/30.1ccbdebc.js"><link rel="prefetch" href="/assets/js/31.acf3eca6.js"><link rel="prefetch" href="/assets/js/32.ccfdc859.js"><link rel="prefetch" href="/assets/js/33.9b262756.js"><link rel="prefetch" href="/assets/js/34.c59a4044.js"><link rel="prefetch" href="/assets/js/35.2b10fefb.js"><link rel="prefetch" href="/assets/js/36.2daeeb7b.js"><link rel="prefetch" href="/assets/js/37.d649866c.js"><link rel="prefetch" href="/assets/js/38.aba1ac95.js"><link rel="prefetch" href="/assets/js/39.58a95fd1.js"><link rel="prefetch" href="/assets/js/40.8ef4d374.js"><link rel="prefetch" href="/assets/js/41.5799de7a.js"><link rel="prefetch" href="/assets/js/42.b7ee7489.js"><link rel="prefetch" href="/assets/js/43.28a65d64.js"><link rel="prefetch" href="/assets/js/44.90f92ea2.js"><link rel="prefetch" href="/assets/js/45.30b683fd.js"><link rel="prefetch" href="/assets/js/46.f57ccc19.js"><link rel="prefetch" href="/assets/js/47.7a82bd74.js"><link rel="prefetch" href="/assets/js/48.72503020.js"><link rel="prefetch" href="/assets/js/49.3a4ba077.js"><link rel="prefetch" href="/assets/js/50.0c3297f3.js"><link rel="prefetch" href="/assets/js/51.e9ba9363.js"><link rel="prefetch" href="/assets/js/52.473ee9ff.js"><link rel="prefetch" href="/assets/js/53.166d6e7a.js"><link rel="prefetch" href="/assets/js/54.78af3662.js"><link rel="prefetch" href="/assets/js/55.f0d54751.js"><link rel="prefetch" href="/assets/js/56.5de81531.js"><link rel="prefetch" href="/assets/js/57.6e18322f.js"><link rel="prefetch" href="/assets/js/58.1fccc879.js"><link rel="prefetch" href="/assets/js/59.773775e1.js"><link rel="prefetch" href="/assets/js/6.0c9cc532.js"><link rel="prefetch" href="/assets/js/60.0d665185.js"><link rel="prefetch" href="/assets/js/61.d9ae36dc.js"><link rel="prefetch" href="/assets/js/62.fb5e3b65.js"><link rel="prefetch" href="/assets/js/63.5ace8fda.js"><link rel="prefetch" href="/assets/js/64.d44fb0af.js"><link rel="prefetch" href="/assets/js/65.ed8fe56f.js"><link rel="prefetch" href="/assets/js/66.809078da.js"><link rel="prefetch" href="/assets/js/67.2489499e.js"><link rel="prefetch" href="/assets/js/68.e3ee952d.js"><link rel="prefetch" href="/assets/js/69.071411f8.js"><link rel="prefetch" href="/assets/js/7.8188415c.js"><link rel="prefetch" href="/assets/js/70.be8269cf.js"><link rel="prefetch" href="/assets/js/71.a320347a.js"><link rel="prefetch" href="/assets/js/72.f4fda48b.js"><link rel="prefetch" href="/assets/js/73.0f9f9284.js"><link rel="prefetch" href="/assets/js/74.b4028d07.js"><link rel="prefetch" href="/assets/js/75.6d63415f.js"><link rel="prefetch" href="/assets/js/76.d5b4df24.js"><link rel="prefetch" href="/assets/js/78.63e767ab.js"><link rel="prefetch" href="/assets/js/79.45056905.js"><link rel="prefetch" href="/assets/js/8.20d7cb0f.js"><link rel="prefetch" href="/assets/js/80.e06c5521.js"><link rel="prefetch" href="/assets/js/81.bc82bd01.js"><link rel="prefetch" href="/assets/js/82.4aeb6081.js"><link rel="prefetch" href="/assets/js/83.3ed6146f.js"><link rel="prefetch" href="/assets/js/84.f2aff9f4.js"><link rel="prefetch" href="/assets/js/85.2b8f4e50.js"><link rel="prefetch" href="/assets/js/86.27aea1da.js"><link rel="prefetch" href="/assets/js/87.7f5dc71e.js"><link rel="prefetch" href="/assets/js/88.9ca6511c.js"><link rel="prefetch" href="/assets/js/89.e8f54ad1.js"><link rel="prefetch" href="/assets/js/9.ee6c43f7.js"><link rel="prefetch" href="/assets/js/90.9abac718.js"><link rel="prefetch" href="/assets/js/91.9d8f5f36.js"><link rel="prefetch" href="/assets/js/92.2277b907.js"><link rel="prefetch" href="/assets/js/93.efca2f57.js"><link rel="prefetch" href="/assets/js/94.e9cc0386.js"><link rel="prefetch" href="/assets/js/95.fa3326f7.js"><link rel="prefetch" href="/assets/js/96.82bafc57.js"><link rel="prefetch" href="/assets/js/97.da22d13e.js"><link rel="prefetch" href="/assets/js/98.d745e5ec.js"><link rel="prefetch" href="/assets/js/99.79a6f693.js">
    <link rel="stylesheet" href="/assets/css/0.styles.37bfab3d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><div class="navbar"><div class="navbar-content"><div class="slogan">Valar Morghulis</div> <div class="links"><span class="link-item"><a href="/">首页</a></span> <span class="link-item"><a href="/category/iOS/">iOS</a></span> <span class="link-item"><a href="/category/other/">其他</a></span></div></div></div> <div class="content-header"><div class="post-title">Mach-O 与动态链接</div> <div class="post-info">2018-10-17</div></div> <div class="content content__default"><p></p><div class="table-of-contents"><ul><li><a href="#写在前面">写在前面</a><ul><li><a href="#rip-relative-寻址">RIP-relative 寻址</a></li><li><a href="#间接寻址">间接寻址</a></li><li><a href="#几个基本概念">几个基本概念</a></li><li><a href="#引子">引子</a></li></ul></li><li><a href="#结构分析">结构分析</a><ul><li><a href="#indirect-symbol-table">Indirect Symbol Table</a></li><li><a href="#text-里的外部符号">__text 里的外部符号</a></li><li><a href="#section-data-got">section(_DATA _got)</a></li><li><a href="#section-text-stubs">section(_TEXT _stubs)</a></li><li><a href="#section-data-la-symbol-ptr">section(_DATA lasymbol_ptr)</a></li><li><a href="#section-text-stub-helper">section(_TEXT stubhelper)</a></li><li><a href="#section-data-nl-symbol-ptr">section(_DATA nlsymbol_ptr)</a></li><li><a href="#dyld-stub-binder">dyldstubbinder</a></li><li><a href="#lazy-binding-分析">Lazy Binding 分析</a></li></ul></li><li><a href="#写在后面">写在后面</a></li><li><a href="#更多阅读">更多阅读</a></li></ul></div><p></p> <h1 id="写在前面"><a href="#写在前面" class="header-anchor">#</a> 写在前面</h1> <p><a href="/post/macho-structure.html">Mach-O 简单分析</a>描述了 Mach-O 文件的基本结构；<a href="/post/macho-static-link.html">Mach-O 与静态链接
</a>概述了符号，分析了符号表（symbol table），这两篇算是本文的前置知识，本文旨在分析动态链接相关内容。</p> <p>关于动态链接，《深入理解计算机系统》和《程序员的自我修养》有着非常棒的分析，但这两本书都是站在 Linux 生态 ELF (Executable and Linkable Format) 的视角分析问题；本文借鉴这两本书，站在 Mach-O 的角度梳理我学习到的内容。</p> <p>原本想在本文中将动态链接的方方面面的内容都装进去，慢慢发现这不是一个好主意。相较于静态链接，动态链接相关内容复杂得多，也更有意思一些，可以从各个视角去研究窥探；换句话说，随便挑一个切入点进行展开，都能完成一篇博客。</p> <p>本文和<a href="/post/macho-static-link.html">Mach-O 与静态链接</a>类似，只是站在 Mach-O 视角，结合笔者自己的理解，将 Mach-O 本身与动态链接相关的结构给串起来，以期望对动态链接有一个基本的理解，重点仍然放在 Mach-O 文件本身上，基本上不涉及 xnu 和 dyld 的源码分析。</p> <blockquote><p>分析 xnu 和 dyld 能帮助更全面准确地理解动态链接，但这不是本文的任务。</p></blockquote> <h2 id="rip-relative-寻址"><a href="#rip-relative-寻址" class="header-anchor">#</a> RIP-relative 寻址</h2> <p>本文所在环境的系统架构是 x86-64，很多指令的寻址方式是 RIP-relative 寻址。虽然笔者汇编不甚熟悉，但是为了后续分析和阅读方便，还是得花些笔墨整理一下 RIP-relative 寻址相关内容。</p> <blockquote><p>RIP 的全拼是：Relative Instruction Pointer</p></blockquote> <p>按照笔者的粗浅理解，基于 RIP 计算目标地址时，目标地址等于当前指令的下一条指令所在地址加上偏移量。简单来说，若看到如下二进制的反汇编内容：</p> <div class="language-asm6502 extra-class"><pre class="language-asm6502"><code><span class="token decimalnumber string">0000000000001</span>fcd  jmpq  <span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">2</span>d(%rip)
<span class="token decimalnumber string">0000000000001</span>fd<span class="token decimalnumber string">3</span>  <span class="token opcode property">nop</span>
</code></pre></div><p>则第一行代码 jmpq 的跳转目标地址是：0x1fd3 + 0x2d = 0x2000。</p> <p>关于RIP-relative 的更加内容可参考：</p> <ul><li><a href="https://blog.csdn.net/yeshahayes/article/details/51930610" target="_blank" rel="noopener noreferrer">64位下的相对指令地址<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://xem.github.io/minix86/manual/intel-x86-and-64-manual-vol2/o_b5573232dd8f1481-72.html" target="_blank" rel="noopener noreferrer">Intel x86-64 Manual Vol2<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="间接寻址"><a href="#间接寻址" class="header-anchor">#</a> 间接寻址</h2> <p>除了 RIP-relative 寻址，也得提一下间接寻址。间接寻址是相对于直接寻址而言的，即目标地址并不是计算得到的地址值，而是该地址值存储的数据。</p> <p>简单来说，如果看到如下二进制的反汇编内容：</p> <div class="language-asm6502 extra-class"><pre class="language-asm6502"><code><span class="token decimalnumber string">0000000000001</span>fcd  jmpq  *<span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">2</span>d(%rip)
<span class="token decimalnumber string">0000000000001</span>fd<span class="token decimalnumber string">3</span>  <span class="token opcode property">nop</span>
</code></pre></div><blockquote><p>对于间接寻址，反汇编代码中，地址值前有一个<code>*</code></p></blockquote> <p>则第一行代码 jmpq 的跳转目标地址是 0x2000 (0x1fd3 + 0x2d) 里存储的内容，并非 0x2000 本身。</p> <h2 id="几个基本概念"><a href="#几个基本概念" class="header-anchor">#</a> 几个基本概念</h2> <p>在展开分析之前，先罗列本文高频出现的一些概念：</p> <ul><li>镜像：xnu、dyld 都将 Mach-O 文件看作镜像（image），本文所指的镜像即 Mach-O 文件</li> <li>目标文件：即只编译未链接的可重定位文件</li> <li>dylib：动态链接库，在 ELF 生态中，常被称作「共享对象」，或者「共享文件」，本文称作 dylib，或者 dylibs</li> <li>dyld：dyld 是 Apple 生态操作系统（macOS、iOS）的动态链接器，本文直接使用 dyld 指代 Mach-O 的动态链接器</li></ul> <h2 id="引子"><a href="#引子" class="header-anchor">#</a> 引子</h2> <p>静态链接比较简单，原理上也容易理解，实践上却存在很多问题，典型问题有两点：</p> <ol><li>极大浪费磁盘和内存空间</li> <li>给程序的更新、部署和发布带来很多麻烦</li></ol> <p>稍微描述一下第二点。比如程序 Program1 所使用的 Lib.o 是由一个第三方厂商提供的，当该厂商更新了 Lib.o 的时候，那么 Program1 的开发者就要拿到最新版的 Lib.o，然后将其与 Program1.o 链接后，将新的 Program1 整个发布给用户。即一旦程序有任何模块的更新，整个程序就得重新链接、发布给用户。</p> <p>动态链接是对这两个问题的解决方案。所谓动态链接，简单地讲，就是不对那些组成程序的目标文件进行链接，等到程序要运行时才进行链接。也就是说，把链接这个过程推迟到运行时再进行，这就是动态链接（Dynamic Linking）的基本思想。</p> <p>动态链接的背景和基本思想理解起来蛮容易的，但实践中需要处理不少问题。本文以一个具体的 case 引出 Mach-O 动态链接中值得我们关心的问题。</p> <p>首先，有一个文件 say.c：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">char</span> <span class="token operator">*</span>kHelloPrefix <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>prefix<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s, %s\n&quot;</span><span class="token punctuation">,</span> prefix<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该模块很简单，定义了两个符号：常量字符串<code>kHelloPrefix</code>，以及函数<code>say</code>。使用 gcc 把<code>say.c</code>编译成 dylib：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ gcc -fPIC -shared say.c -o libsay.dylib
<span class="token comment"># 生成 libsay.dylib</span>
</code></pre></div><p>再定义一个使用 say 模块的 main.c：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>prefix<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">char</span> <span class="token operator">*</span>kHelloPrefix<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">say</span><span class="token punctuation">(</span>kHelloPrefix<span class="token punctuation">,</span> <span class="token string">&quot;Jack&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>把 main.c 编译成可重定位中间文件（只编译不链接）：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ gcc -c main.c -o main.o
<span class="token comment"># 生成可重定位中间文件：main.o</span>
</code></pre></div><p>此时的 main.o 是不可执行的，需要使用链接器 ld 将 sayHello 链接进来：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ ld main.o -macosx_version_min <span class="token number">10.14</span> -o main.out -lSystem -L. -lsay
<span class="token comment"># -macosx_version_min 用于指定最小系统版本，这是必须的</span>
<span class="token comment"># -lSystem 用于链接 libSystem.dylib</span>
<span class="token comment"># -lsay 用于链接 libsay.dylib</span>
<span class="token comment"># -L. 用于新增动态链接库搜索目录</span>
<span class="token comment"># 生成可执行文件：main.out</span>
</code></pre></div><p>这样就生成了可执行文件 main.out，执行该文件，打印「Hello, Jack」。此时若使用<code>xcrun dyldinfo -dylibs</code>查看 main.out 的依赖库，会发现有两个依赖库：</p> <div class="language-sh extra-class"><div class="highlight-lines"><br><br><div class="highlighted"> </div><div class="highlighted"> </div><br></div><pre class="language-sh"><code>$ xcrun dyldinfo -dylibs main.out
attributes     dependent dylibs
                /usr/lib/libSystem.B.dylib
                libsay.dylib
</code></pre></div><p>这两个动态库的依赖在 Mach-O 文件中对应两条 type 为<code>LC_LOAD_DYLIB</code>的 load commands，使用<code>otool -l</code>查看如下：</p> <div class="language-raw extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br></div><pre class="language-text"><code>Load command 12
          cmd LC_LOAD_DYLIB
      cmdsize 56
         name /usr/lib/libSystem.B.dylib (offset 24)
   time stamp 2 Thu Jan  1 08:00:02 1970
      current version 1252.200.5
compatibility version 1.0.0

Load command 13
          cmd LC_LOAD_DYLIB
      cmdsize 40
         name libsay.dylib (offset 24)
   time stamp 2 Thu Jan  1 08:00:02 1970
      current version 0.0.0
</code></pre></div><blockquote><p><code>LC_LOAD_DYLIB</code>命令的顺序和 ld 的链接顺序一致。</p></blockquote> <p><code>LC_LOAD_DYLIB</code>命令参数描述了 dylib 的基本信息，结构比较简单：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">dylib</span> <span class="token punctuation">{</span>
    <span class="token keyword">union</span> lc_str  name<span class="token punctuation">;</span>             <span class="token comment">// dylib 的 path</span>
    uint32_t timestamp<span class="token punctuation">;</span>             <span class="token comment">// dylib 构建的时间戳</span>
    uint32_t current_version<span class="token punctuation">;</span>       <span class="token comment">// dylib 的版本</span>
    uint32_t compatibility_version<span class="token punctuation">;</span> <span class="token comment">// dylib 的兼容版本</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>无论是静态链接，还是动态链接，符号都是最重要的分析对象；来看看 main.out 的符号表（symbol table）：</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/dynamic-main-symtab.png" srcset="/image/dynamic-main-symtab.png 2x" data-v-339c7bd5></div> <p>可以看到，symbol table 中有三个未绑定的外部符号：<code>_kHelloPrefix</code>、<code>_say</code>、<code>dyld_stub_binder</code>；本文接下来对 Mach-O 文件结构的分析将围绕这 3 个符号进行展开。</p> <h1 id="结构分析"><a href="#结构分析" class="header-anchor">#</a> 结构分析</h1> <p>先将 Mach-O 中与动态链接相关的结构给罗列出来：</p> <ul><li>Section
<ul><li>__TEXT __stubs</li> <li>__TEXT __stub_helper</li> <li>__DATA __nl_symbol_ptr</li> <li>__DATA __got</li> <li>__DATA __la_symbol_ptr</li></ul></li> <li>Load Command
<ul><li>LC_LOAD_DYLIB</li> <li>LC_SYMTAB</li> <li>LC_DYSYMTAB</li></ul></li> <li>Symbol Table</li> <li>Indirect Symbol Table</li> <li>Dynamic Loader Info
<ul><li>Binding Info</li> <li>Lazy Binding Info</li></ul></li></ul> <p>涉及若干个 sections、load commands，以及 indirect symbol table、dynamic loader info 等。其中<code>LC_LOAD_DYLIB</code>这个命令上文已经提到，它描述了镜像依赖的 dylibs。<code>LC_SYMTAB</code>定义的符号表（symbol table）是镜像所用到的符号（包括内部符号和外部符号）的集合，<a href="/post/macho-static-link.html#symbol-table">Mach-O 与静态链接</a>对该命令和符号表有详细描述，本文不再赘述。</p> <h2 id="indirect-symbol-table"><a href="#indirect-symbol-table" class="header-anchor">#</a> Indirect Symbol Table</h2> <p>每一个可执行的镜像文件，都有一个 symbol table，由<code>LC_SYMTAB</code>命令定义，包含了镜像所用到的所有符号信息。那么 indirect symbol table 是一个什么东西呢？本质上，indirect symbol table 是 index 数组，即每个条目的内容是一个 index 值，该 index 值（从 0 开始）指向到 symbol table 中的条目。Indirect symbol table 由<code>LC_DYSYMTAB</code>定义，后者的参数类型是一个<code>dysymtab_command</code>结构体，详见<a href="https://opensource.apple.com/source/xnu/xnu-4903.221.2/EXTERNAL_HEADERS/mach-o/loader.h.auto.html" target="_blank" rel="noopener noreferrer">dysymtab_command<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，该结构体内容非常丰富，目前我们只需要关注<code>indirectsymoff</code>和<code>nindirectsyms</code>这两个字段：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">dysymtab_command</span> <span class="token punctuation">{</span>
    uint32_t cmd<span class="token punctuation">;</span>           <span class="token comment">/* LC_DYSYMTAB */</span>
    uint32_t cmdsize<span class="token punctuation">;</span>       <span class="token comment">/* sizeof(struct dysymtab_command) */</span>

    <span class="token comment">// ...</span>

    uint32_t indirectsymoff<span class="token punctuation">;</span> <span class="token comment">/* file offset to the indirect symbol table */</span>
    uint32_t nindirectsyms<span class="token punctuation">;</span>  <span class="token comment">/* number of indirect symbol table entries */</span>

    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><code>indirectsymoff</code>和<code>nindirectsyms</code>这两个字段定义了 indirect symbol table 的位置信息，每一个条目是一个 4 bytes 的 index 值。</p> <p>Indirect symbol table 的结构还是蛮容易理解的，但其存在的意义是啥？先别急，后面会讲到，总之它是为<code>__stubs</code>、<code>__got</code>等 section 服务的。</p> <p>上文 main.out 的 indirect symbol table 可使用<code>otool -I main.out</code>查看，一共包括 5 个条目：</p> <div class="language-raw extra-class"><pre class="language-text"><code>Indirect symbols for (__TEXT,__stubs) 1 entries
  address            index
  0x0000000000001fbe     3

Indirect symbols for (__DATA,__nl_symbol_ptr) 2 entries
  address            index
  0x0000000000002000     4

0x0000000000002008 ABSOLUTE

Indirect symbols for (__DATA,__got) 1 entries
  address            index
  0x0000000000002010     2

Indirect symbols for (__DATA,__la_symbol_ptr) 1 entries
  address            index
  0x0000000000002018     3
</code></pre></div><blockquote><p>第三个条目的 index 值有些奇怪，还没搞清楚...</p></blockquote> <h2 id="text-里的外部符号"><a href="#text-里的外部符号" class="header-anchor">#</a> __text 里的外部符号</h2> <p>回到上文提到的 main.out，使用<code>otool -tv main.out</code>命令查看 main.out 代码段的反汇编内容下：</p> <div class="language-raw extra-class"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted"> </div><br><br><div class="highlighted"> </div><br><br><br><br><br></div><pre class="language-text"><code>_main:
0000000000001f90  pushq %rbp
0000000000001f91  movq  %rsp, %rbp
0000000000001f94  subq  $0x10, %rsp
0000000000001f98  leaq  0x3f(%rip), %rsi
0000000000001f9f  movq  0x6a(%rip), %rax
0000000000001fa6  movl  $0x0, -0x4(%rbp)
0000000000001fad  movq  (%rax), %rdi
0000000000001fb0  callq 0x1fbe
0000000000001fb5  xorl  %eax, %eax
0000000000001fb7  addq  $0x10, %rsp
0000000000001fbb  popq  %rbp
0000000000001fbc  retq
</code></pre></div><p>上述是 main 函数的反汇编代码，注意第 6 行和第 9 行，这两行的指令分别引用了<code>_kHelloPrefix</code>和<code>_say</code>符号；这两个符号未绑定，如果是静态链接，这俩处的地址值是 0；但此处是动态链接，符号目标地址值分别指向的是偏移 0x6a 和 0x09，本文所在环境，采用的 PC 近址寻址，所以<code>_kHelloPrefix</code>和<code>_say</code>的目标地址分别是：</p> <div class="language-raw extra-class"><pre class="language-text"><code>_kHelloPrefix 的目标虚拟地址 = 0x1fa6（第 7 行指令的虚拟地址） + 0x6a = 0x2010
_say 的目标虚拟地址 = 0x1fb5（第 10 行指令虚拟地址） + 0x09 = 0x1fbe
</code></pre></div><p><code>0x2010</code>和<code>0x1fbe</code>分别对应 main.out 中的哪个结构呢？答案是 section(__DATA __got) 和 section(__TEXT __stubs)，使用<code>otool -s</code>命令可以查看这两个 section 的地址和内容：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ otool main.out -s __DATA __got
main.out:
Contents of <span class="token punctuation">(</span>__DATA,__got<span class="token punctuation">)</span> section
0000000000002010  00 00 00 00 00 00 00 00

$ otool main.out -s __TEXT __stubs
main.out:
Contents of <span class="token punctuation">(</span>__TEXT,__stubs<span class="token punctuation">)</span> section
0000000000001fbe  ff <span class="token number">25</span> <span class="token number">54</span> 00 00 00
</code></pre></div><p>Mach-O 的代码段对 dylib 外部符号的引用地址，要么指向到<code>__got</code>，要么指向到<code>__stubs</code>。什么时候指向到前者，什么时候指向到后者呢？</p> <p>站在逻辑的角度，符号有两种：数据型和函数型；前者的值指向到全局变量/常量，后者的值指向到函数。在动态链接的概念里，对这两种符号的绑定称为：non-lazy binding、lazy binding。对于前者，在程序运行前（加载时）就会被绑定；对于后者，在符号被第一次使用时（运行时）绑定。</p> <h2 id="section-data-got"><a href="#section-data-got" class="header-anchor">#</a> section(__DATA __got)</h2> <p>对于程序段<code>__text</code>里的代码，对数据型符号的引用，指向到了<code>__got</code>；可以把<code>__got</code>看作是一个表，每个条目是一个地址值。</p> <p>在符号绑定（binding）前，<code>__got</code>里所有条目的内容都是 0，当镜像被加载时，dyld 会对<code>__got</code>每个条目所对应的符号进行重定位，将其真正的地址填入，作为条目的内容。换句话说，<code>__got</code>各个条目的具体值，在加载期会被 dyld 重写，这也是为啥这个 section 被分配在 __DATA segment 的原因。</p> <p>问题来了，dyld 是如何知道<code>__got</code>中各个条目对应的符号信息（譬如符号名字、目标库等）呢？<a href="/post/macho-structure.html">Mach-O 简单分析</a>已经提到过，每个 segment 由<code>LC_SEGMENT</code>命令定义，该命令后的参数描述了 segment 包含的 section 信息，是谓 section header，对应结构体（x86_64架构）是<a href="https://opensource.apple.com/source/xnu/xnu-4903.221.2/EXTERNAL_HEADERS/mach-o/loader.h.auto.html" target="_blank" rel="noopener noreferrer">section_64<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">section_64</span> <span class="token punctuation">{</span> <span class="token comment">/* for 64-bit architectures */</span>
    <span class="token keyword">char</span>      sectname<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* name of this section */</span>
    <span class="token keyword">char</span>      segname<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">/* segment this section goes in */</span>
    <span class="token comment">// ...</span>
    uint32_t  reserved1<span class="token punctuation">;</span>       <span class="token comment">/* reserved (for offset or index) */</span>
    uint32_t  reserved2<span class="token punctuation">;</span>       <span class="token comment">/* reserved (for count or sizeof) */</span>
    uint32_t  reserved3<span class="token punctuation">;</span>       <span class="token comment">/* reserved */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>对于<code>__got</code>、<code>__stubs</code>、<code>__nl_symbol_ptr</code>、<code>__la_symbol_ptr</code>这几个 section，其<code>reserved1</code>描述了该 list 中条目在 indirect symbol table 中的偏移量。</p> <p>举个栗子，本文的 main.out 中的<code>__got</code>的 section header 的<code>reserved1</code>字段值为 3，它有一个条目，那么该条目对应的符号在 symbol table 中的 index，等于 indirect symbol table 中第 3+1 个条目的值；有点绕口，用伪代码表示，main.out 的<code>__got</code>的第一个条目对应的符号是：</p> <div class="language-c extra-class"><pre class="language-c"><code>__got<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>symbol <span class="token operator">=</span> symbolTable<span class="token punctuation">[</span>indirectSymbolTable<span class="token punctuation">[</span>__got<span class="token punctuation">.</span>sectionHeader<span class="token punctuation">.</span>reserved1<span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token comment">// -&gt; __got.sectionHeader.reserved1 == 3</span>
<span class="token comment">// -&gt; indirectSymbolTable[3] == 2</span>
<span class="token comment">// -&gt; symbolTable[2] = Symbol(_kHelloPrefix)</span>
<span class="token comment">// -&gt; __got[0]-&gt;symbol = Symbol(_kHelloPrefix)</span>
</code></pre></div><p>算是把<code>__got</code>讲清楚了，总之一句话，<code>__got</code>为 dyld 服务，用来存放 non-lazy 符号的最终地址值。</p> <p>现在该说说<code>__stub</code>。</p> <h2 id="section-text-stubs"><a href="#section-text-stubs" class="header-anchor">#</a> section(__TEXT __stubs)</h2> <p>对于程序段<code>__text</code>里的代码，对函数型符号的引用，指向到了<code>__stubs</code>。和<code>__got</code>一样，<code>__stubs</code>也是一个表，每个表项是一小段<code>jmp</code>代码，称为「符号桩」。和<code>__got</code>不同的是，<code>__stubs</code>存在于 __TEXT segment 中，所以其中的条目内容是不可更改的。</p> <p>查看<code>__stubs</code>里的反汇编内容：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ otool -v main.out -s __TEXT __stubs
main.out:
Contents of <span class="token punctuation">(</span>__TEXT,__stubs<span class="token punctuation">)</span> section
0000000000001fbe  jmpq  *0x54<span class="token punctuation">(</span>%rip<span class="token punctuation">)</span>
</code></pre></div><p>来看看<code>jmp</code>指令跳到哪里去，这里使用的间接寻址，真正的地址值存在 0x0000000000002018 中。</p> <blockquote><p>0x0000000000000x2018 = 0x0000000000001fbe + 0x54</p></blockquote> <p><code>0x2018</code>是哪个部分？答案是 section(__DATA __la_symbol_ptr)...</p> <h2 id="section-data-la-symbol-ptr"><a href="#section-data-la-symbol-ptr" class="header-anchor">#</a> section(__DATA __la_symbol_ptr)</h2> <p>使用<code>otool -s</code>查看<code>__la_symbol_ptr</code>的内容：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ otool main.out -s __DATA __la_symbol_ptr
main.out:
Contents of <span class="token punctuation">(</span>__DATA,__la_symbol_ptr<span class="token punctuation">)</span> section
0000000000002018  d4 1f 00 00 00 00 00 00
</code></pre></div><p><code>__la_symbol_ptr</code>的内容是 0x1FD4（小端），所以<code>__stubs</code>第一个 stub 的 jump 目标地址是 0x1FD4。该地址坐落于 section(__TEXT __stub_helper)。</p> <h2 id="section-text-stub-helper"><a href="#section-text-stub-helper" class="header-anchor">#</a> section(__TEXT __stub_helper)</h2> <p>看看<code>__stub_helper</code>里的内容：</p> <div class="language-sh extra-class"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted"> </div><br><div class="highlighted"> </div><br><br></div><pre class="language-sh"><code>$ otool -v main.out -s __TEXT __stub_helper
main.out:
Contents of <span class="token punctuation">(</span>__TEXT,__stub_helper<span class="token punctuation">)</span> section
0000000000001fc4  leaq  0x3d<span class="token punctuation">(</span>%rip<span class="token punctuation">)</span>, %r11
0000000000001fcb  pushq %r11
0000000000001fcd  jmpq  *0x2d<span class="token punctuation">(</span>%rip<span class="token punctuation">)</span>
0000000000001fd3  nop
0000000000001fd4  pushq <span class="token variable">$0x0</span>
0000000000001fd9  jmp 0x1fc4
</code></pre></div><p><code>__stubs</code>第一个 stub 的 jump 目标地址在第 8 行；这几条汇编代码比较简单，可以看出，代码最终会跳到第 6 行；之后该何处何从？</p> <p>不难计算，第 6 行跳转目标地址是 0x2000 (0x1fd3 + 0x2d)存储的内容，0x2000 在哪里呢？0x2000 坐落于 section(__DATA __nl_symbol_ptr)。</p> <h2 id="section-data-nl-symbol-ptr"><a href="#section-data-nl-symbol-ptr" class="header-anchor">#</a> section(__DATA __nl_symbol_ptr)</h2> <p>按惯例，查看<code>__nl_symbol_ptr</code>里的内容：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ otool main.out -s __DATA __nl_symbol_ptr
main.out:
Contents of <span class="token punctuation">(</span>__DATA,__nl_symbol_ptr<span class="token punctuation">)</span> section
0000000000002000  00 00 00 00 00 00 00 00
0000000000002008  00 00 00 00 00 00 00 00
</code></pre></div><p>啥是<code>__nl_symbol_ptr</code>？和<code>__got</code>类似，<code>__nl_symbol_ptr</code>也是用来存储 non-lazy symbol 绑定后的地址。只是<code>__got</code>是为<code>__text</code>代码段中的符号服务的，而<code>__nl_symbol_ptr</code>不是。</p> <p>如上，<code>__nl_symbol_ptr</code>的第一个条目的符号是<code>dyld_stub_binder</code>。</p> <blockquote><p><code>dyld_stub_binder</code>是一个函数，为啥它被当做一个 non-lazy symbol 处理，这是因为它是所有 lazy binding 的基础，所以有些特殊。</p></blockquote> <h2 id="dyld-stub-binder"><a href="#dyld-stub-binder" class="header-anchor">#</a> dyld_stub_binder</h2> <p><code>dyld_stub_binder</code>也是一个函数，定义于<a href="https://opensource.apple.com/source/dyld/dyld-635.2/src/dyld_stub_binder.s.auto.html" target="_blank" rel="noopener noreferrer">dyld_stub_binder.S<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，由 dyld 提供。</p> <p>Lazy binding symbol 的绑定工作正是由 dyld_stub_binder 触发，通过调用<code>dyld::fastBindLazySymbol</code>来完成。</p> <h2 id="lazy-binding-分析"><a href="#lazy-binding-分析" class="header-anchor">#</a> Lazy Binding 分析</h2> <p>上文结合 main.out 实例，对 Mach-O 与动态链接相关的结构做了比较全面的分析。Non-lazy binding 比较容易理解，这里稍微对如上内容进行整合，整体对 lazy binding 基本逻辑进行概述。</p> <p>对于<code>__text</code>代码段里需要被 lazy binding 的符号引用（如上文 main.out 里的<code>_say</code>），访问它时总会跳转到 stub 中，该 stub 的本质是一个 jmp 指令，该 stub 的跳转目标地址坐落于<code>__la_symbol_ptr</code>。</p> <p>首次访问<code>_say</code>时：</p> <ol><li><code>_say</code>对应的<code>__la_symbol_ptr</code>条目内容指向到<code>__stub_helper</code></li> <li><code>__stub_helper</code>里的代码逻辑，通过各种辗转最终调用<code>dyld_stub_binder</code>函数</li> <li><code>dyld_stub_binder</code>函数通过调用 dyld 内部的函数找到<code>_say</code>符号的真实地址</li> <li><code>dyld_stub_binder</code>将地址写入<code>__la_symbol_ptr</code>条目</li> <li><code>dyld_stub_binder</code>跳转到<code>_say</code>符号的真实地址</li></ol> <p>之后再次访问<code>_say</code>时，stub 里的 jmp 指令直接跳转符号的真实地址，因为该地址已经被写到<code>__la_symbol_ptr</code>条目中。</p> <h1 id="写在后面"><a href="#写在后面" class="header-anchor">#</a> 写在后面</h1> <p>分析到这里，有种神清气爽的感觉，是那种费了老半天劲儿爬到高处欣赏风景的感觉。理解这些与动态链接有关的内容后，再去分析其他比较底层的东西，或许就有眉目了。</p> <p>此处做一个小结：</p> <ol><li>本文并未对<code>Dynamic Loader Info</code>内容进行展开，其中涉及 Bind 相关的各种 opcode。原因有俩，其一，笔者对它们的了解并不深刻；其二，至少目前来看，了解它们的意义不大。</li> <li>笔者看了许多其他博客，发现很少有谈到<code>__got</code>这个 section 的，本文所提到的<code>__got</code>的作用，在他们的博客中，都被冠到<code>__nl_symbol_ptr</code>中；猜测的原因是编译器的处理姿势不一样了；不过这也不是很重要了，真正重要的是会自己分析，毕竟无论是<code>__got</code>，还是<code>__nl_symbol_ptr</code>，只是一个名字而已。</li></ol> <p>关于 Mach-O 的动态链接，还有很多值得分析的问题，之后的博客或许会有补充，包括但不限于：</p> <ul><li>dyld 是如何工作的？</li> <li>如何理解 fishhook？</li> <li>Objective-C 与动态链接碰撞出了什么样的火花？</li></ul> <h1 id="更多阅读"><a href="#更多阅读" class="header-anchor">#</a> 更多阅读</h1> <ul><li>《深入理解计算机系统》</li> <li>《程序员的自我修养》</li> <li><a href="https://adrummond.net/posts/macho" target="_blank" rel="noopener noreferrer">Inside a Hello World executable on OS X<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://satanwoo.github.io/2017/06/13/Macho-1/" target="_blank" rel="noopener noreferrer">深入剖析Macho(1)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.50bca889.js" defer></script><script src="/assets/js/5.081d1701.js" defer></script><script src="/assets/js/77.62b794e1.js" defer></script><script src="/assets/js/4.a7413ce2.js" defer></script>
  </body>
</html>
