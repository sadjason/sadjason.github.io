<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>理解 ES6 的对象模型 | 张不坏的博客</title>
    <meta name="description" content="Just For Fun">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.37bfab3d.css" as="style"><link rel="preload" href="/assets/js/app.50bca889.js" as="script"><link rel="preload" href="/assets/js/5.081d1701.js" as="script"><link rel="preload" href="/assets/js/62.fb5e3b65.js" as="script"><link rel="prefetch" href="/assets/js/10.7bb33f06.js"><link rel="prefetch" href="/assets/js/100.014ff06c.js"><link rel="prefetch" href="/assets/js/101.28f11de0.js"><link rel="prefetch" href="/assets/js/102.be9d2e87.js"><link rel="prefetch" href="/assets/js/103.a1210d81.js"><link rel="prefetch" href="/assets/js/104.7101a956.js"><link rel="prefetch" href="/assets/js/105.833e6f80.js"><link rel="prefetch" href="/assets/js/106.978e1fc0.js"><link rel="prefetch" href="/assets/js/107.5af47fd0.js"><link rel="prefetch" href="/assets/js/108.efc3ce89.js"><link rel="prefetch" href="/assets/js/109.a69d6b5a.js"><link rel="prefetch" href="/assets/js/11.2de4afc9.js"><link rel="prefetch" href="/assets/js/110.30984b63.js"><link rel="prefetch" href="/assets/js/12.bfc099bd.js"><link rel="prefetch" href="/assets/js/13.20253e0d.js"><link rel="prefetch" href="/assets/js/14.67131b1c.js"><link rel="prefetch" href="/assets/js/15.1af26cbd.js"><link rel="prefetch" href="/assets/js/16.4b261ee0.js"><link rel="prefetch" href="/assets/js/17.1216332f.js"><link rel="prefetch" href="/assets/js/18.c0159773.js"><link rel="prefetch" href="/assets/js/19.0f007f87.js"><link rel="prefetch" href="/assets/js/2.b4633a05.js"><link rel="prefetch" href="/assets/js/20.4b295001.js"><link rel="prefetch" href="/assets/js/21.0c46767c.js"><link rel="prefetch" href="/assets/js/22.a5e065ea.js"><link rel="prefetch" href="/assets/js/23.f43a6a7e.js"><link rel="prefetch" href="/assets/js/24.245f4f15.js"><link rel="prefetch" href="/assets/js/25.618f74a1.js"><link rel="prefetch" href="/assets/js/26.274a606b.js"><link rel="prefetch" href="/assets/js/27.c2d8fe18.js"><link rel="prefetch" href="/assets/js/28.5c522d2a.js"><link rel="prefetch" href="/assets/js/29.c90fdb1a.js"><link rel="prefetch" href="/assets/js/3.9babd8f1.js"><link rel="prefetch" href="/assets/js/30.1ccbdebc.js"><link rel="prefetch" href="/assets/js/31.acf3eca6.js"><link rel="prefetch" href="/assets/js/32.ccfdc859.js"><link rel="prefetch" href="/assets/js/33.9b262756.js"><link rel="prefetch" href="/assets/js/34.c59a4044.js"><link rel="prefetch" href="/assets/js/35.2b10fefb.js"><link rel="prefetch" href="/assets/js/36.2daeeb7b.js"><link rel="prefetch" href="/assets/js/37.d649866c.js"><link rel="prefetch" href="/assets/js/38.aba1ac95.js"><link rel="prefetch" href="/assets/js/39.58a95fd1.js"><link rel="prefetch" href="/assets/js/4.a7413ce2.js"><link rel="prefetch" href="/assets/js/40.8ef4d374.js"><link rel="prefetch" href="/assets/js/41.5799de7a.js"><link rel="prefetch" href="/assets/js/42.b7ee7489.js"><link rel="prefetch" href="/assets/js/43.28a65d64.js"><link rel="prefetch" href="/assets/js/44.90f92ea2.js"><link rel="prefetch" href="/assets/js/45.30b683fd.js"><link rel="prefetch" href="/assets/js/46.f57ccc19.js"><link rel="prefetch" href="/assets/js/47.7a82bd74.js"><link rel="prefetch" href="/assets/js/48.72503020.js"><link rel="prefetch" href="/assets/js/49.3a4ba077.js"><link rel="prefetch" href="/assets/js/50.0c3297f3.js"><link rel="prefetch" href="/assets/js/51.e9ba9363.js"><link rel="prefetch" href="/assets/js/52.473ee9ff.js"><link rel="prefetch" href="/assets/js/53.166d6e7a.js"><link rel="prefetch" href="/assets/js/54.78af3662.js"><link rel="prefetch" href="/assets/js/55.f0d54751.js"><link rel="prefetch" href="/assets/js/56.5de81531.js"><link rel="prefetch" href="/assets/js/57.6e18322f.js"><link rel="prefetch" href="/assets/js/58.1fccc879.js"><link rel="prefetch" href="/assets/js/59.773775e1.js"><link rel="prefetch" href="/assets/js/6.0c9cc532.js"><link rel="prefetch" href="/assets/js/60.0d665185.js"><link rel="prefetch" href="/assets/js/61.d9ae36dc.js"><link rel="prefetch" href="/assets/js/63.5ace8fda.js"><link rel="prefetch" href="/assets/js/64.d44fb0af.js"><link rel="prefetch" href="/assets/js/65.ed8fe56f.js"><link rel="prefetch" href="/assets/js/66.809078da.js"><link rel="prefetch" href="/assets/js/67.2489499e.js"><link rel="prefetch" href="/assets/js/68.e3ee952d.js"><link rel="prefetch" href="/assets/js/69.071411f8.js"><link rel="prefetch" href="/assets/js/7.8188415c.js"><link rel="prefetch" href="/assets/js/70.be8269cf.js"><link rel="prefetch" href="/assets/js/71.a320347a.js"><link rel="prefetch" href="/assets/js/72.f4fda48b.js"><link rel="prefetch" href="/assets/js/73.0f9f9284.js"><link rel="prefetch" href="/assets/js/74.b4028d07.js"><link rel="prefetch" href="/assets/js/75.6d63415f.js"><link rel="prefetch" href="/assets/js/76.d5b4df24.js"><link rel="prefetch" href="/assets/js/77.62b794e1.js"><link rel="prefetch" href="/assets/js/78.63e767ab.js"><link rel="prefetch" href="/assets/js/79.45056905.js"><link rel="prefetch" href="/assets/js/8.20d7cb0f.js"><link rel="prefetch" href="/assets/js/80.e06c5521.js"><link rel="prefetch" href="/assets/js/81.bc82bd01.js"><link rel="prefetch" href="/assets/js/82.4aeb6081.js"><link rel="prefetch" href="/assets/js/83.3ed6146f.js"><link rel="prefetch" href="/assets/js/84.f2aff9f4.js"><link rel="prefetch" href="/assets/js/85.2b8f4e50.js"><link rel="prefetch" href="/assets/js/86.27aea1da.js"><link rel="prefetch" href="/assets/js/87.7f5dc71e.js"><link rel="prefetch" href="/assets/js/88.9ca6511c.js"><link rel="prefetch" href="/assets/js/89.e8f54ad1.js"><link rel="prefetch" href="/assets/js/9.ee6c43f7.js"><link rel="prefetch" href="/assets/js/90.9abac718.js"><link rel="prefetch" href="/assets/js/91.9d8f5f36.js"><link rel="prefetch" href="/assets/js/92.2277b907.js"><link rel="prefetch" href="/assets/js/93.efca2f57.js"><link rel="prefetch" href="/assets/js/94.e9cc0386.js"><link rel="prefetch" href="/assets/js/95.fa3326f7.js"><link rel="prefetch" href="/assets/js/96.82bafc57.js"><link rel="prefetch" href="/assets/js/97.da22d13e.js"><link rel="prefetch" href="/assets/js/98.d745e5ec.js"><link rel="prefetch" href="/assets/js/99.79a6f693.js">
    <link rel="stylesheet" href="/assets/css/0.styles.37bfab3d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><div class="navbar"><div class="navbar-content"><div class="slogan">Valar Morghulis</div> <div class="links"><span class="link-item"><a href="/">首页</a></span> <span class="link-item"><a href="/category/iOS/">iOS</a></span> <span class="link-item"><a href="/category/other/">其他</a></span></div></div></div> <div class="content-header"><div class="post-title">理解 ES6 的对象模型</div> <div class="post-info">2018-04-27</div></div> <div class="content content__default"><p>在 JS 开发过程中，发现对 ES6 的对象模型居然不是特别拧得清，于是花了些功夫进行相关知识梳理。本文参考资料包括：</p> <ul><li>《深入理解 ES6》</li> <li>《JavaScript 忍者秘籍》（第二版）</li> <li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener noreferrer">ECMAScript 6 入门<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h1 id="es5-的原型前置知识"><a href="#es5-的原型前置知识" class="header-anchor">#</a> ES5 的原型前置知识</h1> <p>从接口定义来看，原型这个概念大概是从 ES5 开始的；本部分阐述 ES5 原型相关的零散内容。先从接口说起，从 ES5 开始，新增了如下与原型相关的 API：</p> <ul><li>obj.constructor: 保存这用于创建当前对象的函数，详见<a href="https://www.ecma-international.org/ecma-262/5.1/#sec-4.3.4" target="_blank" rel="noopener noreferrer">https://www.ecma-international.org/ecma-262/5.1/#sec-4.3.4<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>protoObject.isPrototypeOf(obj): 用于测试一个对象是否存在于另一个对象的原型链上，详见<a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.2.4.6" target="_blank" rel="noopener noreferrer">https://www.ecma-international.org/ecma-262/5.1/#sec-15.2.4.6<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>Object.getPrototypeOf(obj): 获取 obj 的 prototype，详见<a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.2.3.2" target="_blank" rel="noopener noreferrer">https://www.ecma-international.org/ecma-262/5.1/#sec-15.2.3.2<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>Function.prototype: 属性存储了 Function 的原型对象，详见<a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.3.3.1" target="_blank" rel="noopener noreferrer">https://www.ecma-international.org/ecma-262/5.1/#sec-15.3.3.1<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="proto-属性"><a href="#proto-属性" class="header-anchor">#</a> <code>__proto__</code>属性</h2> <p>从 ES5 开始，每一个对象都有一个描述其原型的内部属性<code>[[Prototype]]</code>；对象该如何获取其原型信息呢？如上所述，可以通过<code>Object.getPrototypeOf(obj)</code>获取对象的原型；除此之外，大多数 ES5 的实现，都还可以通过<code>__proto__</code>获取对象原型；为了表述方便，文本后续都将使用<code>__proto__</code>表述对象的内部属性<code>[[Prototype]]</code>。</p> <p>对象的<code>__proto__</code>在其被构造时赋值指定，指向其构造函数的 prototype 属性。</p> <p>别忘了函数，在 JS 的世界里，函数也是一种对象，所以函数（Function 对象）也有内部属性<code>[[Prototype]]</code>，其获取方式和 Object 对象一样。</p> <h2 id="prototype-属性"><a href="#prototype-属性" class="header-anchor">#</a> prototype 属性</h2> <p>每一个函数（Function 对象）除了含有<code>__proto__</code>之外，还有一个普通对象所没有的<code>prototype</code>属性；当函数作为构造函数使用（使用<code>new</code>操作符）时，该<code>prototype</code>会成为新创建对象的<code>__proto__</code>值。</p> <p>上面这句话描述了普通对象的<code>__proto__</code>值的来源，那么函数的<code>__proto__</code>的值来源是哪里呢？答案是上文提到的 Function.prototype。</p> <h2 id="constructor-属性"><a href="#constructor-属性" class="header-anchor">#</a> constructor 属性</h2> <p>每一个 proto 对象都有一个 constructor 属性指向到所对应的 Function，即：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">P</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token operator">===</span> <span class="token constant">P</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
p<span class="token punctuation">.</span>constructor <span class="token operator">===</span> <span class="token class-name">P</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>上文提到的<code>obj.constructor</code>，就是从 prototype 那里继承过来的，如果对 obj 变更<code>__proto__</code>，其 constructor 也会跟着变。</p> <h2 id="函数的-proto-和-prototype"><a href="#函数的-proto-和-prototype" class="header-anchor">#</a> 函数的<code>__proto__</code>和 prototype</h2> <p>特别要注意，函数同时有<code>__proto__</code>和<code>prototype</code>，但二者是不同的，前者标明了函数的继承关系；后者主要是为所构建的对象服务。这二者是不同的，一定要理清。</p> <h1 id="es6-中的类知识"><a href="#es6-中的类知识" class="header-anchor">#</a> ES6 中的类知识</h1> <h2 id="class"><a href="#class" class="header-anchor">#</a> class</h2> <p><code>class</code>关键字是 ES6 引入的关键字，给定义类提供了新的方式：类声明。<code>class</code>是一个语法糖，底层用的仍然是老的原型那一套类定义姿势。如下罗列一些值得注意的点。</p> <p><strong>constructor 是唯一保留的方法</strong></p> <p>class 类声明中，除了 constructor 外没有其他保留的方法名，所以可以尽情添加方法。</p> <p><strong>类声明中的函数没有 prototype</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
p<span class="token punctuation">.</span>hello<span class="token punctuation">.</span>prototype <span class="token comment">// undefined</span>
</code></pre></div><h2 id="super"><a href="#super" class="header-anchor">#</a> super</h2> <p><code>super</code>这个关键字，既可以当函数使用，又可以当对象使用；在这两种情况下，它的使用方法完全不同。</p> <p>第一种情况，当函数使用，（仅）代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p> <p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p> <p>注意，使用 super 的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>另外一个需要特别注意的点是，super 仅能用于 class 定义或者 class 声明中，并且对应类必须继承自某个类；换句话说，<code>super</code>的上下环境必须有两个关键字：<code>class</code>和<code>extends</code>。</p> <blockquote><p>关于这个说法，是我个人总结的，没有权威背书。</p></blockquote> <h1 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h1> <p>结合实例回顾一下继承的基本要求，已知 Sup 和 Sub，如果 Sub 继承自 Sup，那么意味着：</p> <ul><li>Sup 的静态方法被 Sub 继承：可以通过设置<code>Sub.__proto__ = Sup</code>实现</li> <li>Sup 的实例方法能被 Sub 的实例继承：<code>Sub.prototype.__prop__ = Sup.prototype</code></li></ul> <p>当然，在 ES6 中，使用 extends 就可以了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Sup</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Sup</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Sub<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Sup<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Sub</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Sup</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><h1 id="实践问题"><a href="#实践问题" class="header-anchor">#</a> 实践问题</h1> <h2 id="判断-a-类是否是-b-类的子类"><a href="#判断-a-类是否是-b-类的子类" class="header-anchor">#</a> 判断 A 类是否是 B 类的子类</h2> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>ClassA<span class="token punctuation">)</span> <span class="token operator">===</span> ClassB
</code></pre></div><h2 id="获取某个类的父类"><a href="#获取某个类的父类" class="header-anchor">#</a> 获取某个类的父类</h2> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>ClassA<span class="token punctuation">)</span> <span class="token comment">// 获取ClassA的父类，注意，如果返回值是`Function.prototype`，则意味是ClassA是基类。</span>
</code></pre></div><blockquote><p>这种姿势还没找到权威背书。</p></blockquote> <h2 id="super-在类声明-类定义之外无法使用"><a href="#super-在类声明-类定义之外无法使用" class="header-anchor">#</a> Super 在类声明/类定义之外无法使用</h2> <p>曾尝试在<code>class</code>之外使用 super 关键字：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo A'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> <span class="token constant">A</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>在这个 case 中，尝试在 class 类表达式之外 override B 的 foo 实例方法，但是重写时调用父类的 foo 方法；然而在执行<code>(new B).foo()</code>时却报错：</p> <blockquote><p>SyntaxError: 'super' keyword unexpected here</p></blockquote> <p>网络上寻找答案，没有找到比较权威的说法，<a href="https://stackoverflow.com/questions/46806091/es6-use-super-out-of-class-definition" target="_blank" rel="noopener noreferrer">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的说法可能正确：</p> <blockquote><p><code>super</code> refers to ancestor of a class where the method was defined, it isn't dynamic. <code>super</code> is hard-coded to <code>Object.getPrototypeOf(X.prototype)</code>.</p></blockquote> <p>简单来说，<code>super</code>不像<code>this</code>关键字，后者具备动态性，在运行时指向到与方法调用绑定的对象，前者在编译时被硬编码成<code>Object.getPrototypeOf(X.prototype)</code>（X 是所处的类定义环境的类名）。</p> <p>如何解决这件事情呢？最直白的方案是直接找到目标方法，然后<code>call(this)</code>，如下是我能想到的几种姿势：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 姿势一：直接调用目标函数</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 姿势二：使用`Object.getPrototypeOf(B).prototype`访问`A.prototype`</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 姿势三：使用`Object.getPrototypeOf(B.prototype)`访问`A.prototype`</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 姿势四：使用`Object.getPrototypeOf(this.constructor.prototype)`访问`A.prototype`</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 姿势五：使用`Object.getPrototypeOf(this.constructor).prototype`访问`A.prototype`</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>简单从硬编码角度分析这几种姿势。</p> <p>第一种依赖最紧密，逻辑前提是 B 一定是直接继承自 A，如果在 A 和 B 中间插入一个中间类，则还得修改<code>B.prototype.foo</code>的实现逻辑。</p> <p>第二种和第三种其实是一回事儿，基于 B 省略掉了 A。</p> <p>第四种和第五种也是一回事儿，完全在实现逻辑中抛掉了 A、B，几乎是动态的。但是它有一个问题，如果 B 还有一个子类 C，就不妙了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 姿势四：使用`Object.getPrototypeOf(this.constructor.prototype)`访问`A.prototype`</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token constant">C</span> <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> <span class="token constant">B</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// RangeError: Maximum call stack size exceeded</span>
</code></pre></div><p>报错信息告诉我们，循环调用了，稍微沉下心来，不难分析。</p> <p>综上所述，我认为姿势四、五是错误的姿势；姿势一不完美，如果把继承链拉长一点，有坑；姿势二、三比较 ok，可能是真正正确的姿势。</p></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.50bca889.js" defer></script><script src="/assets/js/5.081d1701.js" defer></script><script src="/assets/js/62.fb5e3b65.js" defer></script>
  </body>
</html>
