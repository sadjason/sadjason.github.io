<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>NSProxy | 张不坏的博客</title>
    <meta name="description" content="Just For Fun">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.37bfab3d.css" as="style"><link rel="preload" href="/assets/js/app.50bca889.js" as="script"><link rel="preload" href="/assets/js/5.081d1701.js" as="script"><link rel="preload" href="/assets/js/90.9abac718.js" as="script"><link rel="prefetch" href="/assets/js/10.7bb33f06.js"><link rel="prefetch" href="/assets/js/100.014ff06c.js"><link rel="prefetch" href="/assets/js/101.28f11de0.js"><link rel="prefetch" href="/assets/js/102.be9d2e87.js"><link rel="prefetch" href="/assets/js/103.a1210d81.js"><link rel="prefetch" href="/assets/js/104.7101a956.js"><link rel="prefetch" href="/assets/js/105.833e6f80.js"><link rel="prefetch" href="/assets/js/106.978e1fc0.js"><link rel="prefetch" href="/assets/js/107.5af47fd0.js"><link rel="prefetch" href="/assets/js/108.efc3ce89.js"><link rel="prefetch" href="/assets/js/109.a69d6b5a.js"><link rel="prefetch" href="/assets/js/11.2de4afc9.js"><link rel="prefetch" href="/assets/js/110.30984b63.js"><link rel="prefetch" href="/assets/js/12.bfc099bd.js"><link rel="prefetch" href="/assets/js/13.20253e0d.js"><link rel="prefetch" href="/assets/js/14.67131b1c.js"><link rel="prefetch" href="/assets/js/15.1af26cbd.js"><link rel="prefetch" href="/assets/js/16.4b261ee0.js"><link rel="prefetch" href="/assets/js/17.1216332f.js"><link rel="prefetch" href="/assets/js/18.c0159773.js"><link rel="prefetch" href="/assets/js/19.0f007f87.js"><link rel="prefetch" href="/assets/js/2.b4633a05.js"><link rel="prefetch" href="/assets/js/20.4b295001.js"><link rel="prefetch" href="/assets/js/21.0c46767c.js"><link rel="prefetch" href="/assets/js/22.a5e065ea.js"><link rel="prefetch" href="/assets/js/23.f43a6a7e.js"><link rel="prefetch" href="/assets/js/24.245f4f15.js"><link rel="prefetch" href="/assets/js/25.618f74a1.js"><link rel="prefetch" href="/assets/js/26.274a606b.js"><link rel="prefetch" href="/assets/js/27.c2d8fe18.js"><link rel="prefetch" href="/assets/js/28.5c522d2a.js"><link rel="prefetch" href="/assets/js/29.c90fdb1a.js"><link rel="prefetch" href="/assets/js/3.9babd8f1.js"><link rel="prefetch" href="/assets/js/30.1ccbdebc.js"><link rel="prefetch" href="/assets/js/31.acf3eca6.js"><link rel="prefetch" href="/assets/js/32.ccfdc859.js"><link rel="prefetch" href="/assets/js/33.9b262756.js"><link rel="prefetch" href="/assets/js/34.c59a4044.js"><link rel="prefetch" href="/assets/js/35.2b10fefb.js"><link rel="prefetch" href="/assets/js/36.2daeeb7b.js"><link rel="prefetch" href="/assets/js/37.d649866c.js"><link rel="prefetch" href="/assets/js/38.aba1ac95.js"><link rel="prefetch" href="/assets/js/39.58a95fd1.js"><link rel="prefetch" href="/assets/js/4.a7413ce2.js"><link rel="prefetch" href="/assets/js/40.8ef4d374.js"><link rel="prefetch" href="/assets/js/41.5799de7a.js"><link rel="prefetch" href="/assets/js/42.b7ee7489.js"><link rel="prefetch" href="/assets/js/43.28a65d64.js"><link rel="prefetch" href="/assets/js/44.90f92ea2.js"><link rel="prefetch" href="/assets/js/45.30b683fd.js"><link rel="prefetch" href="/assets/js/46.f57ccc19.js"><link rel="prefetch" href="/assets/js/47.7a82bd74.js"><link rel="prefetch" href="/assets/js/48.72503020.js"><link rel="prefetch" href="/assets/js/49.3a4ba077.js"><link rel="prefetch" href="/assets/js/50.0c3297f3.js"><link rel="prefetch" href="/assets/js/51.e9ba9363.js"><link rel="prefetch" href="/assets/js/52.473ee9ff.js"><link rel="prefetch" href="/assets/js/53.166d6e7a.js"><link rel="prefetch" href="/assets/js/54.78af3662.js"><link rel="prefetch" href="/assets/js/55.f0d54751.js"><link rel="prefetch" href="/assets/js/56.5de81531.js"><link rel="prefetch" href="/assets/js/57.6e18322f.js"><link rel="prefetch" href="/assets/js/58.1fccc879.js"><link rel="prefetch" href="/assets/js/59.773775e1.js"><link rel="prefetch" href="/assets/js/6.0c9cc532.js"><link rel="prefetch" href="/assets/js/60.0d665185.js"><link rel="prefetch" href="/assets/js/61.d9ae36dc.js"><link rel="prefetch" href="/assets/js/62.fb5e3b65.js"><link rel="prefetch" href="/assets/js/63.5ace8fda.js"><link rel="prefetch" href="/assets/js/64.d44fb0af.js"><link rel="prefetch" href="/assets/js/65.ed8fe56f.js"><link rel="prefetch" href="/assets/js/66.809078da.js"><link rel="prefetch" href="/assets/js/67.2489499e.js"><link rel="prefetch" href="/assets/js/68.e3ee952d.js"><link rel="prefetch" href="/assets/js/69.071411f8.js"><link rel="prefetch" href="/assets/js/7.8188415c.js"><link rel="prefetch" href="/assets/js/70.be8269cf.js"><link rel="prefetch" href="/assets/js/71.a320347a.js"><link rel="prefetch" href="/assets/js/72.f4fda48b.js"><link rel="prefetch" href="/assets/js/73.0f9f9284.js"><link rel="prefetch" href="/assets/js/74.b4028d07.js"><link rel="prefetch" href="/assets/js/75.6d63415f.js"><link rel="prefetch" href="/assets/js/76.d5b4df24.js"><link rel="prefetch" href="/assets/js/77.62b794e1.js"><link rel="prefetch" href="/assets/js/78.63e767ab.js"><link rel="prefetch" href="/assets/js/79.45056905.js"><link rel="prefetch" href="/assets/js/8.20d7cb0f.js"><link rel="prefetch" href="/assets/js/80.e06c5521.js"><link rel="prefetch" href="/assets/js/81.bc82bd01.js"><link rel="prefetch" href="/assets/js/82.4aeb6081.js"><link rel="prefetch" href="/assets/js/83.3ed6146f.js"><link rel="prefetch" href="/assets/js/84.f2aff9f4.js"><link rel="prefetch" href="/assets/js/85.2b8f4e50.js"><link rel="prefetch" href="/assets/js/86.27aea1da.js"><link rel="prefetch" href="/assets/js/87.7f5dc71e.js"><link rel="prefetch" href="/assets/js/88.9ca6511c.js"><link rel="prefetch" href="/assets/js/89.e8f54ad1.js"><link rel="prefetch" href="/assets/js/9.ee6c43f7.js"><link rel="prefetch" href="/assets/js/91.9d8f5f36.js"><link rel="prefetch" href="/assets/js/92.2277b907.js"><link rel="prefetch" href="/assets/js/93.efca2f57.js"><link rel="prefetch" href="/assets/js/94.e9cc0386.js"><link rel="prefetch" href="/assets/js/95.fa3326f7.js"><link rel="prefetch" href="/assets/js/96.82bafc57.js"><link rel="prefetch" href="/assets/js/97.da22d13e.js"><link rel="prefetch" href="/assets/js/98.d745e5ec.js"><link rel="prefetch" href="/assets/js/99.79a6f693.js">
    <link rel="stylesheet" href="/assets/css/0.styles.37bfab3d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><div class="navbar"><div class="navbar-content"><div class="slogan">Valar Morghulis</div> <div class="links"><span class="link-item"><a href="/">首页</a></span> <span class="link-item"><a href="/category/iOS/">iOS</a></span> <span class="link-item"><a href="/category/other/">其他</a></span></div></div></div> <div class="content-header"><div class="post-title">NSProxy</div> <div class="post-info">2017-11-20 • iOS</div></div> <div class="content content__default"><p>吾尝以为<code>NSObject</code>是 Apple 的所有 Objective-C 引用类型的老祖宗，直到后来知道了<code>NSProxy</code>的存在...</p> <p><code>NSProxy</code>和<code>class NSObject</code>平级，彼此没有继承关系；唯一的相同点是它们都遵循<code>protocol NSObject</code>。尚未在开发中使用过<code>NSProxy</code>，最近琢磨需求开发的方案时注意到了这个类的存在，有不少疑问，譬如<code>NSproxy</code>存在的意义是什么？如何使用它呢？本文将疑惑记录下来，并尝试自我解惑。</p> <h3 id="nsproxy-简介"><a href="#nsproxy-简介" class="header-anchor">#</a> NSProxy 简介</h3> <p><code>NSProxy</code>是一个抽象类，它实现了<code>protocol NSObject</code>所要求的基本方法，譬如内省相关的<code>-isKindOfClass:</code>、派发消息相关的 performSelector 系列方法等；但是不能直接使用它创建对象。</p> <p>子类化<code>NSProxy</code>的要求也很简单，实现<code>-forwardInvocation:</code>和<code>-methodSignatureForSelector:</code>这两个方法即可；显然，这两个方法与消息转发相关，实现这两个方法的典型姿势是：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>forwardInvocation<span class="token punctuation">:</span><span class="token punctuation">(</span>NSInvocation <span class="token operator">*</span><span class="token punctuation">)</span>anInvocation <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>anInvocation invokeWithTarget<span class="token punctuation">:</span>_realObject<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// _realObject是自定义的实例变量</span>
<span class="token punctuation">}</span>

– <span class="token punctuation">(</span>NSMethodSignature <span class="token operator">*</span><span class="token punctuation">)</span>methodSignatureForSelector<span class="token punctuation">:</span><span class="token punctuation">(</span>SEL<span class="token punctuation">)</span>aSelector <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>_realObject methodSignatureForSelector<span class="token punctuation">:</span>aSelector<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>NSProxy</code>存在的意义是为它人做嫁衣，Apple 的<a href="https://developer.apple.com/documentation/foundation/nsproxy" target="_blank" rel="noopener noreferrer">说法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>是：</p> <blockquote><p>Typically, a message to a proxy is forwarded to the real object or causes the proxy to load (or transform itself into) the real object.</p></blockquote> <h3 id="nsproxy-的消息转发机制"><a href="#nsproxy-的消息转发机制" class="header-anchor">#</a> NSProxy 的消息转发机制</h3> <p>虽然<code>NSProxy</code>和<code>class NSObject</code>都定义了<code>-forwardInvocation:</code>和<code>-methodSignatureForSelector:</code>，但这两个方法并没有在<code>protocol NSObject</code>中声明；两者对这俩方法的调用逻辑更是完全不同。</p> <p>对于<code>class NSObject</code>而言，接收到消息后先去自身的方法列表里找匹配的 selector，如果找不到，会沿着继承体系去 superclass 的方法列表找；如果还找不到，先后会经过<code>+resolveInstanceMethod:</code>和<code>-forwardingTargetForSelector:</code>处理，处理失败后，才会到<code>-methodSignatureForSelector:</code>/<code>-forwardInvocation:</code>进行最后的挣扎。更详细的叙述，详见<a href="/post/message-forwarding/">NSObject 的消息转发机制</a>。</p> <p>但对于<code>NSProxy</code>，接收 unknown selector 后，直接回调<code>-methodSignatureForSelector:</code>/<code>-forwardInvocation:</code>，消息转发过程比<code>class NSObject</code>要简单得多。</p> <p>相对于<code>class NSObject</code>，<code>NSProxy</code>的另外一个非常重要的不同点也值得注意：<code>NSProxy</code>会将自省相关的 selector 直接 forward 到<code>-forwardInvocation:</code>回调中，这些自省方法包括：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code><span class="token operator">-</span> <span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>isKindOfClass<span class="token punctuation">:</span><span class="token punctuation">(</span>Class<span class="token punctuation">)</span>aClass<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>isMemberOfClass<span class="token punctuation">:</span><span class="token punctuation">(</span>Class<span class="token punctuation">)</span>aClass<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>conformsToProtocol<span class="token punctuation">:</span><span class="token punctuation">(</span>Protocol <span class="token operator">*</span><span class="token punctuation">)</span>aProtocol<span class="token punctuation">;</span>

<span class="token operator">-</span> <span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>respondsToSelector<span class="token punctuation">:</span><span class="token punctuation">(</span>SEL<span class="token punctuation">)</span>aSelector<span class="token punctuation">;</span>
</code></pre></div><p>简单来说，这 4 个 selector 的实际接收者 realObject，而不是<code>NSProxy</code>对象本身。但另一方面，<code>NSProxy</code>并没有将 performSelector 系列 selector 也 forward 到<code>-forwardInvocation:</code>，换句话说，<code>[proxy performSelector:someSelector]</code>的真正处理者仍然是 proxy 自身，只是后续会将 someSelector 给 forward 到<code>-forwardInvocation:</code>回调，然后经由 realObject 处理。</p> <p>P.S: 如上这个说法我并没有找到比较权威的官方直接说明，只是写 demo 验证了自己的判断。</p> <p>P.P.S: <code>NSProxy</code>自省方法的默认实现是将消息 forward 到 realObject，如果不想这样，该怎么办？简单，override 相关方法即可。只不过 override 时不要 super invoke。</p> <h3 id="init-和-isproxy"><a href="#init-和-isproxy" class="header-anchor">#</a> -init 和-isProxy</h3> <p>除了上述的<code>-methodSignatureForSelector:</code>和<code>-forwardInvocation:</code>，<code>NSProxy</code>另外两个方法也非常值得说一说。</p> <p>首先是<code>-init</code>。事实上，<code>NSProxy</code>没有定义这个方法，对于直接继承<code>NSProxy</code>的类，创建对象时不需要使用<code>[super init]</code>之类的调用进行初始化。为啥 Apple 不为<code>NSProxy</code>提供默认的构造器呢？我想这和它的定位有关吧，它是一个抽象类，不提供默认的<code>-init</code>反而能进一步阻止用户直接使用<code>NSProxy</code>创建对象。</p> <p>P.S: 从<code>class NSObject</code>的<a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/NSObject.mm" target="_blank" rel="noopener noreferrer">开源代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>来看，<code>class NSObject</code>的<code>-init</code>其实也没干啥事儿。</p> <p>另一个值得一提的方法是<code>-(BOOL)isProxy</code>，用户可以根据该方法的返回值判断对象是否继承自<code>NSObject</code>。</p> <p>P.S: 看起来这个方法很重要，但尚未搞清楚它的内涵意义，以后再补充吧！</p> <h3 id="使用-nsproxy-设计代理类"><a href="#使用-nsproxy-设计代理类" class="header-anchor">#</a> 使用 NSProxy 设计代理类</h3> <p>使用<code>NSProxy</code>设计简单的代理类非常合适。老司机老谭在其博客<a href="http://www.tanhao.me/code/160702.html/" target="_blank" rel="noopener noreferrer">使用 NSProxy 和 NSObject 设计代理类的差异<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中探讨过使用<code>NSProxy</code>设计代理类的优势，简单罗列如下：</p> <ul><li><code>NSProxy</code>会将自省相关方法直接 forward 到<code>forwardInvocation:</code>回调，如果基于<code>class NSObject</code>实现类似的效果，得另外写不少代码，比较麻烦。</li> <li><code>NSProxy</code>比<code>class NSObject</code>干净得多，后者各种 category（譬如<code>NSObject(NSKeyValueCoding)</code>）定义了诸多方法，这些方法的存在使得消息转发变得更麻烦，因为得区分<code>class NSObject</code>对象本身和其所指向的 realObject。</li></ul> <p>或许是我看到的东西太少，<code>NSProxy</code>的使用场景并不多，只是用于设计一些简单的代理，譬如常见的应用场景是解决<code>NSTimer</code>与其 target 之间的循环引用问题（参考<a href="http://blog.csdn.net/GGGHub/article/details/51374150" target="_blank" rel="noopener noreferrer">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）。复杂的代理逻辑，譬如 ReactiveCocoa 的<code>RACDelegateProxy</code>，大多基于<code>NSObject</code>实现，因为<code>NSObject</code>要强大得多，譬如支持 KVO、runtime，而上述罗列的<code>class NSObject</code>的不足，只要基本功扎实，心思缜密，理论上是可以绕过的，只不过要写大量的 override 逻辑。另外，我认为另一个重要的原因是<code>class NSObject</code>的相关实现是开源的，逻辑比较可控。而<code>NSProxy</code>属于 NSFoundation 的一部分，并没有开源。</p> <p>另外，著名的第三方库 libextobjc 基于<code>NSProxy</code>设计了一个非常有意思的类：<code>EXTNil</code>。该类基本上实现了神奇的<code>nil</code>指针功能：可以接收任何消息而不抛出<code>doesNotRecognizeSelector:</code>异常，但不进行任何处理。之所以说「基本上」，是因为还不彻底，向<code>EXTNil</code>发送的有效消息必须在工程全局范围内能找到有效 selector，否则仍然会抛出<code>doesNotRecognizeSelector:</code>异常。</p> <p><strong>本文参考</strong></p> <ul><li><a href="http://www.tanhao.me/code/160702.html/" target="_blank" rel="noopener noreferrer">使用 NSProxy 和 NSObject 设计代理类的差异<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.50bca889.js" defer></script><script src="/assets/js/5.081d1701.js" defer></script><script src="/assets/js/90.9abac718.js" defer></script>
  </body>
</html>
