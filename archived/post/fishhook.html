<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>分析 fishhook | 张不坏的博客</title>
    <meta name="description" content="Just For Fun">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.37bfab3d.css" as="style"><link rel="preload" href="/assets/js/app.50bca889.js" as="script"><link rel="preload" href="/assets/js/5.081d1701.js" as="script"><link rel="preload" href="/assets/js/65.ed8fe56f.js" as="script"><link rel="prefetch" href="/assets/js/10.7bb33f06.js"><link rel="prefetch" href="/assets/js/100.014ff06c.js"><link rel="prefetch" href="/assets/js/101.28f11de0.js"><link rel="prefetch" href="/assets/js/102.be9d2e87.js"><link rel="prefetch" href="/assets/js/103.a1210d81.js"><link rel="prefetch" href="/assets/js/104.7101a956.js"><link rel="prefetch" href="/assets/js/105.833e6f80.js"><link rel="prefetch" href="/assets/js/106.978e1fc0.js"><link rel="prefetch" href="/assets/js/107.5af47fd0.js"><link rel="prefetch" href="/assets/js/108.efc3ce89.js"><link rel="prefetch" href="/assets/js/109.a69d6b5a.js"><link rel="prefetch" href="/assets/js/11.2de4afc9.js"><link rel="prefetch" href="/assets/js/110.30984b63.js"><link rel="prefetch" href="/assets/js/12.bfc099bd.js"><link rel="prefetch" href="/assets/js/13.20253e0d.js"><link rel="prefetch" href="/assets/js/14.67131b1c.js"><link rel="prefetch" href="/assets/js/15.1af26cbd.js"><link rel="prefetch" href="/assets/js/16.4b261ee0.js"><link rel="prefetch" href="/assets/js/17.1216332f.js"><link rel="prefetch" href="/assets/js/18.c0159773.js"><link rel="prefetch" href="/assets/js/19.0f007f87.js"><link rel="prefetch" href="/assets/js/2.b4633a05.js"><link rel="prefetch" href="/assets/js/20.4b295001.js"><link rel="prefetch" href="/assets/js/21.0c46767c.js"><link rel="prefetch" href="/assets/js/22.a5e065ea.js"><link rel="prefetch" href="/assets/js/23.f43a6a7e.js"><link rel="prefetch" href="/assets/js/24.245f4f15.js"><link rel="prefetch" href="/assets/js/25.618f74a1.js"><link rel="prefetch" href="/assets/js/26.274a606b.js"><link rel="prefetch" href="/assets/js/27.c2d8fe18.js"><link rel="prefetch" href="/assets/js/28.5c522d2a.js"><link rel="prefetch" href="/assets/js/29.c90fdb1a.js"><link rel="prefetch" href="/assets/js/3.9babd8f1.js"><link rel="prefetch" href="/assets/js/30.1ccbdebc.js"><link rel="prefetch" href="/assets/js/31.acf3eca6.js"><link rel="prefetch" href="/assets/js/32.ccfdc859.js"><link rel="prefetch" href="/assets/js/33.9b262756.js"><link rel="prefetch" href="/assets/js/34.c59a4044.js"><link rel="prefetch" href="/assets/js/35.2b10fefb.js"><link rel="prefetch" href="/assets/js/36.2daeeb7b.js"><link rel="prefetch" href="/assets/js/37.d649866c.js"><link rel="prefetch" href="/assets/js/38.aba1ac95.js"><link rel="prefetch" href="/assets/js/39.58a95fd1.js"><link rel="prefetch" href="/assets/js/4.a7413ce2.js"><link rel="prefetch" href="/assets/js/40.8ef4d374.js"><link rel="prefetch" href="/assets/js/41.5799de7a.js"><link rel="prefetch" href="/assets/js/42.b7ee7489.js"><link rel="prefetch" href="/assets/js/43.28a65d64.js"><link rel="prefetch" href="/assets/js/44.90f92ea2.js"><link rel="prefetch" href="/assets/js/45.30b683fd.js"><link rel="prefetch" href="/assets/js/46.f57ccc19.js"><link rel="prefetch" href="/assets/js/47.7a82bd74.js"><link rel="prefetch" href="/assets/js/48.72503020.js"><link rel="prefetch" href="/assets/js/49.3a4ba077.js"><link rel="prefetch" href="/assets/js/50.0c3297f3.js"><link rel="prefetch" href="/assets/js/51.e9ba9363.js"><link rel="prefetch" href="/assets/js/52.473ee9ff.js"><link rel="prefetch" href="/assets/js/53.166d6e7a.js"><link rel="prefetch" href="/assets/js/54.78af3662.js"><link rel="prefetch" href="/assets/js/55.f0d54751.js"><link rel="prefetch" href="/assets/js/56.5de81531.js"><link rel="prefetch" href="/assets/js/57.6e18322f.js"><link rel="prefetch" href="/assets/js/58.1fccc879.js"><link rel="prefetch" href="/assets/js/59.773775e1.js"><link rel="prefetch" href="/assets/js/6.0c9cc532.js"><link rel="prefetch" href="/assets/js/60.0d665185.js"><link rel="prefetch" href="/assets/js/61.d9ae36dc.js"><link rel="prefetch" href="/assets/js/62.fb5e3b65.js"><link rel="prefetch" href="/assets/js/63.5ace8fda.js"><link rel="prefetch" href="/assets/js/64.d44fb0af.js"><link rel="prefetch" href="/assets/js/66.809078da.js"><link rel="prefetch" href="/assets/js/67.2489499e.js"><link rel="prefetch" href="/assets/js/68.e3ee952d.js"><link rel="prefetch" href="/assets/js/69.071411f8.js"><link rel="prefetch" href="/assets/js/7.8188415c.js"><link rel="prefetch" href="/assets/js/70.be8269cf.js"><link rel="prefetch" href="/assets/js/71.a320347a.js"><link rel="prefetch" href="/assets/js/72.f4fda48b.js"><link rel="prefetch" href="/assets/js/73.0f9f9284.js"><link rel="prefetch" href="/assets/js/74.b4028d07.js"><link rel="prefetch" href="/assets/js/75.6d63415f.js"><link rel="prefetch" href="/assets/js/76.d5b4df24.js"><link rel="prefetch" href="/assets/js/77.62b794e1.js"><link rel="prefetch" href="/assets/js/78.63e767ab.js"><link rel="prefetch" href="/assets/js/79.45056905.js"><link rel="prefetch" href="/assets/js/8.20d7cb0f.js"><link rel="prefetch" href="/assets/js/80.e06c5521.js"><link rel="prefetch" href="/assets/js/81.bc82bd01.js"><link rel="prefetch" href="/assets/js/82.4aeb6081.js"><link rel="prefetch" href="/assets/js/83.3ed6146f.js"><link rel="prefetch" href="/assets/js/84.f2aff9f4.js"><link rel="prefetch" href="/assets/js/85.2b8f4e50.js"><link rel="prefetch" href="/assets/js/86.27aea1da.js"><link rel="prefetch" href="/assets/js/87.7f5dc71e.js"><link rel="prefetch" href="/assets/js/88.9ca6511c.js"><link rel="prefetch" href="/assets/js/89.e8f54ad1.js"><link rel="prefetch" href="/assets/js/9.ee6c43f7.js"><link rel="prefetch" href="/assets/js/90.9abac718.js"><link rel="prefetch" href="/assets/js/91.9d8f5f36.js"><link rel="prefetch" href="/assets/js/92.2277b907.js"><link rel="prefetch" href="/assets/js/93.efca2f57.js"><link rel="prefetch" href="/assets/js/94.e9cc0386.js"><link rel="prefetch" href="/assets/js/95.fa3326f7.js"><link rel="prefetch" href="/assets/js/96.82bafc57.js"><link rel="prefetch" href="/assets/js/97.da22d13e.js"><link rel="prefetch" href="/assets/js/98.d745e5ec.js"><link rel="prefetch" href="/assets/js/99.79a6f693.js">
    <link rel="stylesheet" href="/assets/css/0.styles.37bfab3d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><div class="navbar"><div class="navbar-content"><div class="slogan">Valar Morghulis</div> <div class="links"><span class="link-item"><a href="/">首页</a></span> <span class="link-item"><a href="/category/iOS/">iOS</a></span> <span class="link-item"><a href="/category/other/">其他</a></span></div></div></div> <div class="content-header"><div class="post-title">分析 fishhook</div> <div class="post-info">2018-10-25</div></div> <div class="content content__default"><p><a href="/post/macho-dynamic-link.html">Mach-O 与动态链接</a>围绕 Mach-O 结构分析了符号的动态绑定逻辑；搞清楚了这个，再来分析 fishhook 就是一件非常容易的事情了，何况，其代码量不足 300 行。</p> <p>关于 fishhook，<a href="https://github.com/facebook/fishhook" target="_blank" rel="noopener noreferrer">官方资料<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>是这么介绍的：</p> <blockquote><p>fishhook is a very simple library that enables dynamically rebinding symbols in Mach-O binaries running on iOS in the simulator and on device.</p></blockquote> <p>简单来说，通过 fishhook，可以对动态链接的符号进行重新绑定。</p> <p>从 fishhook.h 的 API 上看，它定义了两个函数：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">rebind_symbols</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rebinding</span> rebindings<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> size_t rebindings_nel<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">rebind_symbols_image</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>header<span class="token punctuation">,</span>
                         intptr_t slide<span class="token punctuation">,</span>
                         <span class="token keyword">struct</span> <span class="token class-name">rebinding</span> rebindings<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                         size_t rebindings_nel<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这两个函数都用于符号重绑定，前者操作的对象是进程的所有镜像，后者操作的对象是某个指定的镜像；一般都只是使用前者。本文也只是对<code>rebind_symbols()</code>展开进一步描述，它有两参数，<code>rebindings</code>是一个<code>rebinding</code>数组，<code>rebindings_nel</code>描述数组的长度。fishhook 使用<code>rebinding</code>结构体描述要 rebind 的目标符号：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">rebinding</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>  <span class="token comment">// 目标符号名</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>replacement<span class="token punctuation">;</span> <span class="token comment">// 要替换的符号值（地址值）</span>
  <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>replaced<span class="token punctuation">;</span>   <span class="token comment">// 用来存放原来的符号值（地址值）</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>搞清楚了 API，使用就非常简单了。如下使用一个小 case 描述 fishhook 的使用姿势，这个 case 要做的事情是重定位<code>printf</code>函数的符号，让它指向到自定义函数，代码如下：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// main.c</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdarg.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&quot;fishhook.h&quot;</span></span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>original_printf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">god_printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    
    <span class="token function">original_printf</span><span class="token punctuation">(</span><span class="token string">&quot;I'm God\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    va_list arg<span class="token punctuation">;</span>
    <span class="token function">va_start</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> format<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token function">vprintf</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">va_end</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// rebind `printf` 符号，让它指向到自定义的 `god_printf` 函数</span>
    <span class="token keyword">struct</span> <span class="token class-name">rebinding</span> printf_rebinding <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">&quot;printf&quot;</span><span class="token punctuation">,</span> god_printf<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>original_printf <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">rebind_symbols</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rebinding</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>printf_rebinding<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 调用 `printf`，实际执行的逻辑是 `god_printf` 定义的逻辑</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;The answer to Life, the Universe and everything, is %d\n&quot;</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上述代码自定义了 print-like 函数<code>god_printf</code>，在该函数里，基于<code>vprintf</code>，自定义了 print 逻辑，在此之前，还调用<code>original_printf</code>打印了几个字符，<code>original_printf</code>存储的是原来的<code>printf</code>的地址；<code>main</code>函数所做的事情，不过是使用 fishhook 的<code>rebind_symbols()</code>函数对<code>printf</code>符号进行 rebind。</p> <p>跑一下程序：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ gcc main.c fishhook.c -o main.out
$ ./main.out
I'm God
The answer to Life, the Universe and everything, is <span class="token number">42</span>
</code></pre></div><blockquote><p>fishhook 官网对它的使用场景明确限定在 iOS 系统，但如上实践说明，macOS 端的 C 程序也是可以使用的。</p></blockquote> <p>正如所期待的那样，对<code>printf</code>的调用，实际上执行的是<code>god_printf()</code>。</p> <p>搞清楚了基本用法，是时候分析 fishhook.c 源码了。</p> <p>逐行分析解读 fishhook.c 源码的博客非常多，本文不做类似的事情；正如本文开头所述，如果弄清楚 Mach-O 的符号动态绑定逻辑，理解 fishhook.c 是一件非常容易的事情；换句话说，在分析 fishhook 之前，笔者认为应该先理清 Mach-O 的符号动态绑定逻辑。</p> <p><a href="https://github.com/facebook/fishhook/blob/master/README.md" target="_blank" rel="noopener noreferrer">fishhook/README<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>介绍了其实现原理。简单复述一下：Mach-O 访问其他 dylib 的符号是以间接的方式进行的，经过各种兜转，最终符号地址存在可读写的 __DATA segment 的某个 section 中，fishhook 的实现原理就是通过修改这些 section 内容，进而实现符号的 rebind。</p> <p>在分析 fishhook.c 源码之前，笔者关心如下几个问题：</p> <ul><li>fishhook 的 rebind 只对函数型符号有效，还是也可以作用于数据型符号？</li> <li>fishhook 是如何找到目标 section 的？
<blockquote><p>存储函数型动态链接符号地址值的 section 一般是<code>__la_symbol_ptr</code>（详见<a href="/post/macho-dynamic-link.html">Mahc-O 与动态链接</a>），fishhook 是如何找到它的呢？</p></blockquote></li> <li>fishhook 是如何匹配符号名的呢？
<blockquote><p>上文要处理的函数<code>printf()</code>，编译器处理后，其符号名通常变为了<code>_printf</code>，fishhook 是如何匹配的呢？</p></blockquote></li></ul> <p>fishhook.c 简短的源码中，执行 rebind 逻辑的核心函数有两个：<code>rebind_symbols_for_image</code>和<code>perform_rebinding_with_section</code>；前者负责找到目标 section，后者在 section 里根据符号进行真正的 rebind。</p> <p>先看<code>rebind_symbols_for_image</code>，截取部分代码如下：</p> <div class="language-c extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br></div><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rebind_symbols_for_image</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rebindings_entry</span> <span class="token operator">*</span>rebindings<span class="token punctuation">,</span>
                                     <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">mach_header</span> <span class="token operator">*</span>header<span class="token punctuation">,</span>
                                     intptr_t slide<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ...... */</span>
  cur <span class="token operator">=</span> <span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>header <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>mach_header_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>uint i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> header<span class="token operator">-&gt;</span>ncmds<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> cur <span class="token operator">+=</span> cur_seg_cmd<span class="token operator">-&gt;</span>cmdsize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cur_seg_cmd <span class="token operator">=</span> <span class="token punctuation">(</span>segment_command_t <span class="token operator">*</span><span class="token punctuation">)</span>cur<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur_seg_cmd<span class="token operator">-&gt;</span>cmd <span class="token operator">==</span> LC_SEGMENT_ARCH_DEPENDENT<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 过滤 segment，只在`__DATA`、`__DATA_CONST` segment 里寻找</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>cur_seg_cmd<span class="token operator">-&gt;</span>segname<span class="token punctuation">,</span> SEG_DATA<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
          <span class="token function">strcmp</span><span class="token punctuation">(</span>cur_seg_cmd<span class="token operator">-&gt;</span>segname<span class="token punctuation">,</span> SEG_DATA_CONST<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>uint j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> cur_seg_cmd<span class="token operator">-&gt;</span>nsects<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        section_t <span class="token operator">*</span>sect <span class="token operator">=</span> <span class="token punctuation">(</span>section_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>cur <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>segment_command_t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> j<span class="token punctuation">;</span>
        <span class="token comment">// 寻找目标 section，找到后，执行 `perform_rebinding_with_section()`</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sect<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> SECTION_TYPE<span class="token punctuation">)</span> <span class="token operator">==</span> S_LAZY_SYMBOL_POINTERS<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">perform_rebinding_with_section</span><span class="token punctuation">(</span>rebindings<span class="token punctuation">,</span> sect<span class="token punctuation">,</span> slide<span class="token punctuation">,</span> symtab<span class="token punctuation">,</span> strtab<span class="token punctuation">,</span> indirect_symtab<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sect<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> SECTION_TYPE<span class="token punctuation">)</span> <span class="token operator">==</span> S_NON_LAZY_SYMBOL_POINTERS<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">perform_rebinding_with_section</span><span class="token punctuation">(</span>rebindings<span class="token punctuation">,</span> sect<span class="token punctuation">,</span> slide<span class="token punctuation">,</span> symtab<span class="token punctuation">,</span> strtab<span class="token punctuation">,</span> indirect_symtab<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>聚焦寻找目标 section的逻辑，可以看到，fishhook 通过 section type 匹配来寻找目标 section，<a href="https://opensource.apple.com/source/xnu/xnu-4903.221.2/EXTERNAL_HEADERS/mach-o/loader.h.auto.html" target="_blank" rel="noopener noreferrer">mach-o/loader.h<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>定义的 section header（描述 section 结构，结构体为<code>section_64</code>或者<code>section</code>），其中有一个<code>flags</code>字段，该字段含有描述 section type 的信息，如下罗列了上文 main.out 的<code>__nl_symbol_ptr</code>、<code>__got</code>、<code>__la_symbol_ptr</code>的<code>flags</code>值信息：</p> <div class="language-raw extra-class"><pre class="language-text"><code>Section
  sectname __nl_symbol_ptr
   segname __DATA
     flags 0x00000006

Section
  sectname __got
   segname __DATA
     flags 0x00000006

Section
  sectname __la_symbol_ptr
   segname __DATA
     flags 0x00000007
</code></pre></div><p>0x06、0x07 分别对应的宏是<code>S_NON_LAZY_SYMBOL_POINTERS</code>、<code>S_LAZY_SYMBOL_POINTERS</code>，前者指该 section 用于存储 non-lazy 型符号地址信息，后者指该 section 用于存储 lazy 型符号地址信息。</p> <p>至此，可以得到两点重要信息。</p> <p>其一，fishhook 寻找<code>__la_symbol_ptr</code>等 section 的逻辑并不是通过 name 匹配，而是通过 section type 匹配。</p> <blockquote><p>在看代码之前，笔者还担心是通过 name 匹配，如果是这样，也太 low 了，万一编译器编译时将该 section 名做一下变更，岂不 gg 了？</p></blockquote> <p>其二，fishhook rebind 的对象不光是函数型符号，还包括数据型符号。</p> <p>如下 case 旨在验证第二点，先定义一个简单的文件 hello.c，该文件非常简单，只是定义了一个全局字符串：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// hello.c</span>
<span class="token keyword">char</span> <span class="token operator">*</span>kHello <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>接着把该文件编译成动态库：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ gcc -fpic -shared hello.c -o libhello.dylib
<span class="token comment"># 生成 libhello.dylib</span>
</code></pre></div><p>再写个 main.c，该模块依赖 libhello.dylib 的<code>kHello</code>，如下：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// main.c</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&quot;fishhook.h&quot;</span></span>

<span class="token keyword">extern</span> <span class="token keyword">char</span> <span class="token operator">*</span>kHello<span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>kGood <span class="token operator">=</span> <span class="token string">&quot;Good&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 将 `kHello` rebind 到 `kGood`</span>
    <span class="token keyword">struct</span> <span class="token class-name">rebinding</span> hello_rebinding <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">&quot;kHello&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>kGood<span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">rebind_symbols</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rebinding</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>hello_rebinding<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s, Jason\n&quot;</span><span class="token punctuation">,</span> kHello<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>执行<code>gcc main.c fishhook.c -o main.out -L. -lhello</code>生成 main.out，执行程序打印<code>Good, Jason</code>（而不是<code>Hello, Jason</code>），说明<code>kHello</code>符号被成功 rebind 了。</p> <p>最后，再看看<code>perform_rebinding_with_section</code>，聚焦于 symbol name 匹配逻辑：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">perform_rebinding_with_section</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>uint i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> section<span class="token operator">-&gt;</span>size <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>uint j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> cur<span class="token operator">-&gt;</span>rebindings_nel<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// symbol name 匹配</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>symbol_name_longer_than_1 <span class="token operator">&amp;&amp;</span> <span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>symbol_name<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cur<span class="token operator">-&gt;</span>rebindings<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          indirect_symbol_bindings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>rebindings<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>replacement<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>发现一个尴尬的事实是，fishhook 的 symbol 匹配也没能做到多么高级，仍然是字符串匹配，只是匹配前，它把符号真正的 name 的第一个字符给去掉了，所以上文匹配<code>printf</code>/<code>kHello</code>对应的符号时，符号名无需写成<code>_printf</code>/<code>_kHello</code>。</p> <blockquote><p>这种处理，我认为算是 fishhook 的一个小不足吧，毕竟它完全依赖于编译器对符号的取名姿势。但哪能找到更好的处理姿势呢？</p></blockquote> <h1 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h1> <p>结合上文的分析，站在使用的角度，对 fishhook 做个小结：</p> <ul><li>fishhook 能 rebind 的符号必须存在于动态库中，换句话说，它无法对本地符号进行 rebind</li> <li>fishhook 既能处理函数型符号，也能处理数据型符号（无论是全局变量还是全局常量）</li> <li>使用 fishhook 处理符号时，传参中的符号名并不是真正的符号名，譬如你想对<code>_printf</code>符号进行 rebind，传入<code>&quot;printf&quot;</code>即可</li></ul></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.50bca889.js" defer></script><script src="/assets/js/5.081d1701.js" defer></script><script src="/assets/js/65.ed8fe56f.js" defer></script>
  </body>
</html>
