<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>宏 | 张不坏的博客</title>
    <meta name="description" content="Just For Fun">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.37bfab3d.css" as="style"><link rel="preload" href="/assets/js/app.50bca889.js" as="script"><link rel="preload" href="/assets/js/5.081d1701.js" as="script"><link rel="preload" href="/assets/js/80.e06c5521.js" as="script"><link rel="prefetch" href="/assets/js/10.7bb33f06.js"><link rel="prefetch" href="/assets/js/100.014ff06c.js"><link rel="prefetch" href="/assets/js/101.28f11de0.js"><link rel="prefetch" href="/assets/js/102.be9d2e87.js"><link rel="prefetch" href="/assets/js/103.a1210d81.js"><link rel="prefetch" href="/assets/js/104.7101a956.js"><link rel="prefetch" href="/assets/js/105.833e6f80.js"><link rel="prefetch" href="/assets/js/106.978e1fc0.js"><link rel="prefetch" href="/assets/js/107.5af47fd0.js"><link rel="prefetch" href="/assets/js/108.efc3ce89.js"><link rel="prefetch" href="/assets/js/109.a69d6b5a.js"><link rel="prefetch" href="/assets/js/11.2de4afc9.js"><link rel="prefetch" href="/assets/js/110.30984b63.js"><link rel="prefetch" href="/assets/js/12.bfc099bd.js"><link rel="prefetch" href="/assets/js/13.20253e0d.js"><link rel="prefetch" href="/assets/js/14.67131b1c.js"><link rel="prefetch" href="/assets/js/15.1af26cbd.js"><link rel="prefetch" href="/assets/js/16.4b261ee0.js"><link rel="prefetch" href="/assets/js/17.1216332f.js"><link rel="prefetch" href="/assets/js/18.c0159773.js"><link rel="prefetch" href="/assets/js/19.0f007f87.js"><link rel="prefetch" href="/assets/js/2.b4633a05.js"><link rel="prefetch" href="/assets/js/20.4b295001.js"><link rel="prefetch" href="/assets/js/21.0c46767c.js"><link rel="prefetch" href="/assets/js/22.a5e065ea.js"><link rel="prefetch" href="/assets/js/23.f43a6a7e.js"><link rel="prefetch" href="/assets/js/24.245f4f15.js"><link rel="prefetch" href="/assets/js/25.618f74a1.js"><link rel="prefetch" href="/assets/js/26.274a606b.js"><link rel="prefetch" href="/assets/js/27.c2d8fe18.js"><link rel="prefetch" href="/assets/js/28.5c522d2a.js"><link rel="prefetch" href="/assets/js/29.c90fdb1a.js"><link rel="prefetch" href="/assets/js/3.9babd8f1.js"><link rel="prefetch" href="/assets/js/30.1ccbdebc.js"><link rel="prefetch" href="/assets/js/31.acf3eca6.js"><link rel="prefetch" href="/assets/js/32.ccfdc859.js"><link rel="prefetch" href="/assets/js/33.9b262756.js"><link rel="prefetch" href="/assets/js/34.c59a4044.js"><link rel="prefetch" href="/assets/js/35.2b10fefb.js"><link rel="prefetch" href="/assets/js/36.2daeeb7b.js"><link rel="prefetch" href="/assets/js/37.d649866c.js"><link rel="prefetch" href="/assets/js/38.aba1ac95.js"><link rel="prefetch" href="/assets/js/39.58a95fd1.js"><link rel="prefetch" href="/assets/js/4.a7413ce2.js"><link rel="prefetch" href="/assets/js/40.8ef4d374.js"><link rel="prefetch" href="/assets/js/41.5799de7a.js"><link rel="prefetch" href="/assets/js/42.b7ee7489.js"><link rel="prefetch" href="/assets/js/43.28a65d64.js"><link rel="prefetch" href="/assets/js/44.90f92ea2.js"><link rel="prefetch" href="/assets/js/45.30b683fd.js"><link rel="prefetch" href="/assets/js/46.f57ccc19.js"><link rel="prefetch" href="/assets/js/47.7a82bd74.js"><link rel="prefetch" href="/assets/js/48.72503020.js"><link rel="prefetch" href="/assets/js/49.3a4ba077.js"><link rel="prefetch" href="/assets/js/50.0c3297f3.js"><link rel="prefetch" href="/assets/js/51.e9ba9363.js"><link rel="prefetch" href="/assets/js/52.473ee9ff.js"><link rel="prefetch" href="/assets/js/53.166d6e7a.js"><link rel="prefetch" href="/assets/js/54.78af3662.js"><link rel="prefetch" href="/assets/js/55.f0d54751.js"><link rel="prefetch" href="/assets/js/56.5de81531.js"><link rel="prefetch" href="/assets/js/57.6e18322f.js"><link rel="prefetch" href="/assets/js/58.1fccc879.js"><link rel="prefetch" href="/assets/js/59.773775e1.js"><link rel="prefetch" href="/assets/js/6.0c9cc532.js"><link rel="prefetch" href="/assets/js/60.0d665185.js"><link rel="prefetch" href="/assets/js/61.d9ae36dc.js"><link rel="prefetch" href="/assets/js/62.fb5e3b65.js"><link rel="prefetch" href="/assets/js/63.5ace8fda.js"><link rel="prefetch" href="/assets/js/64.d44fb0af.js"><link rel="prefetch" href="/assets/js/65.ed8fe56f.js"><link rel="prefetch" href="/assets/js/66.809078da.js"><link rel="prefetch" href="/assets/js/67.2489499e.js"><link rel="prefetch" href="/assets/js/68.e3ee952d.js"><link rel="prefetch" href="/assets/js/69.071411f8.js"><link rel="prefetch" href="/assets/js/7.8188415c.js"><link rel="prefetch" href="/assets/js/70.be8269cf.js"><link rel="prefetch" href="/assets/js/71.a320347a.js"><link rel="prefetch" href="/assets/js/72.f4fda48b.js"><link rel="prefetch" href="/assets/js/73.0f9f9284.js"><link rel="prefetch" href="/assets/js/74.b4028d07.js"><link rel="prefetch" href="/assets/js/75.6d63415f.js"><link rel="prefetch" href="/assets/js/76.d5b4df24.js"><link rel="prefetch" href="/assets/js/77.62b794e1.js"><link rel="prefetch" href="/assets/js/78.63e767ab.js"><link rel="prefetch" href="/assets/js/79.45056905.js"><link rel="prefetch" href="/assets/js/8.20d7cb0f.js"><link rel="prefetch" href="/assets/js/81.bc82bd01.js"><link rel="prefetch" href="/assets/js/82.4aeb6081.js"><link rel="prefetch" href="/assets/js/83.3ed6146f.js"><link rel="prefetch" href="/assets/js/84.f2aff9f4.js"><link rel="prefetch" href="/assets/js/85.2b8f4e50.js"><link rel="prefetch" href="/assets/js/86.27aea1da.js"><link rel="prefetch" href="/assets/js/87.7f5dc71e.js"><link rel="prefetch" href="/assets/js/88.9ca6511c.js"><link rel="prefetch" href="/assets/js/89.e8f54ad1.js"><link rel="prefetch" href="/assets/js/9.ee6c43f7.js"><link rel="prefetch" href="/assets/js/90.9abac718.js"><link rel="prefetch" href="/assets/js/91.9d8f5f36.js"><link rel="prefetch" href="/assets/js/92.2277b907.js"><link rel="prefetch" href="/assets/js/93.efca2f57.js"><link rel="prefetch" href="/assets/js/94.e9cc0386.js"><link rel="prefetch" href="/assets/js/95.fa3326f7.js"><link rel="prefetch" href="/assets/js/96.82bafc57.js"><link rel="prefetch" href="/assets/js/97.da22d13e.js"><link rel="prefetch" href="/assets/js/98.d745e5ec.js"><link rel="prefetch" href="/assets/js/99.79a6f693.js">
    <link rel="stylesheet" href="/assets/css/0.styles.37bfab3d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><div class="navbar"><div class="navbar-content"><div class="slogan">Valar Morghulis</div> <div class="links"><span class="link-item"><a href="/">首页</a></span> <span class="link-item"><a href="/category/iOS/">iOS</a></span> <span class="link-item"><a href="/category/other/">其他</a></span></div></div></div> <div class="content-header"><div class="post-title">宏</div> <div class="post-info">2016-10-08</div></div> <div class="content content__default"><p>我深度使用宏的机会并不是很多，闲来无事，以打发时间的心态，了解了一些相关知识，记录于本文。主要包括如下几个方面的内容：</p> <ul><li>宏的基本介绍</li> <li>常见的坑</li> <li>宏的实际应用</li> <li>宏的命名</li></ul> <h2 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h2> <p>这一部分内容基本上参考自：https://gcc.gnu.org/onlinedocs/cpp/Macros.html。</p> <h3 id="object-like-macro-function-like-macro（对象宏和函数宏）"><a href="#object-like-macro-function-like-macro（对象宏和函数宏）" class="header-anchor">#</a> Object-like-Macro &amp;&amp; Function-like Macro（对象宏和函数宏）</h3> <p>C 中的宏分为两类，对象宏(object-like macro)和函数宏(function-like macro)：</p> <ul><li>对象宏常用于定义常量，譬如<code>#define PI 3.14</code></li> <li>函数宏的行为类似于函数，譬如<code>#define pf() printf()</code></li></ul> <h3 id="stringification（字符串化）-–-操作符"><a href="#stringification（字符串化）-–-操作符" class="header-anchor">#</a> Stringification（字符串化） – #操作符</h3> <p>有时候，我们希望将某个宏参数（针对函数宏）转化为字符串常量，此时需要用到<code>#</code>操作符，譬如：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">define</span> WARN_IF(EXP) \
    do { if (EXP) \
    fprintf (stderr, &quot;Warning: &quot; #EXP &quot;\n&quot;); } \
    while (0)</span>
WARN_IF <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ==&gt; do { if (x == 0) fprintf (stderr, &quot;Warning: &quot; &quot;x == 0&quot; &quot;\n&quot;); } while (0);</span>
</code></pre></div><p>P.S: 宏处理器会对连续的字符串进行拼接？譬如<code>&quot;1&quot;&quot;2&quot;&quot;3&quot;</code>-&gt;<code>&quot;123&quot;</code>。</p> <h3 id="concatenation（级联）-–-操作符"><a href="#concatenation（级联）-–-操作符" class="header-anchor">#</a> Concatenation（级联） – ##操作符</h3> <p><code>##</code>操作符能够帮助把两个标识符给连起来，譬如有如下一个结构体：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">command</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>function<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>现在我们需要构建这么一个数组：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">command</span> commands<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span> <span class="token string">&quot;quit&quot;</span><span class="token punctuation">,</span> quit_command <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> <span class="token string">&quot;help&quot;</span><span class="token punctuation">,</span> help_command <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>除了直接定义之外，我们还可以使用<code>##</code>构成的宏进行处理：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">define</span> COMMAND(name)  { #name, name ## _command }</span>
<span class="token keyword">struct</span> <span class="token class-name">command</span> commands<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>
<span class="token punctuation">{</span>
    <span class="token function">COMMAND</span><span class="token punctuation">(</span>quit<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">COMMAND</span><span class="token punctuation">(</span>help<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="variadic-macros（可变参数的宏）"><a href="#variadic-macros（可变参数的宏）" class="header-anchor">#</a> Variadic Macros（可变参数的宏）</h3> <p>可以声明参数可变的函数宏，譬如：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">define</span> eprintf(...) fprintf (stderr, __VA_ARGS__)</span>
</code></pre></div><p>When the macro is invoked, all the tokens in its argument list after the last named argument (this macro has none), including any commas, become the variable argument. This sequence of tokens replaces the identifier <code>__VA_ARGS__</code> in the macro body wherever it appears.</p> <p>除了上面这种，还可以使用其他姿势定义参数可变的函数宏：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">define</span> eprintf(args...) fprintf (stderr, args)</span>
<span class="token macro property">#<span class="token directive keyword">define</span> eprintf(format, ...) fprintf (stderr, format, __VA_ARGS__)</span>
<span class="token macro property">#<span class="token directive keyword">define</span> eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)</span>
<span class="token macro property">#<span class="token directive keyword">define</span> eprintf(format, args...) fprintf (stderr, format , ##args)</span>
</code></pre></div><h3 id="predefined-macros（预定义宏）"><a href="#predefined-macros（预定义宏）" class="header-anchor">#</a> Predefined Macros（预定义宏）</h3> <p>编译器提供了一些预定义宏，可以分为 3 种：</p> <ul><li><a href="https://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html#Standard-Predefined-Macros" target="_blank" rel="noopener noreferrer">Standard Predefined Macros<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros" target="_blank" rel="noopener noreferrer">Common Predefined Macros<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://gcc.gnu.org/onlinedocs/cpp/System-specific-Predefined-Macros.html#System-specific-Predefined-Macros" target="_blank" rel="noopener noreferrer">System-specific Predefined Macros<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="undefining-and-redefining-macros（取消和重置宏定义）"><a href="#undefining-and-redefining-macros（取消和重置宏定义）" class="header-anchor">#</a> Undefining and Redefining Macros（取消和重置宏定义）</h3> <p>定义宏使用<code>#define</code>关键字，取消宏定义使用<code>#undef</code>，测试时常会用到。</p> <h2 id="一些坑"><a href="#一些坑" class="header-anchor">#</a> 一些坑</h2> <p>宏的最大诟病在于它存在很多坑，并且不太容易发现。</p> <h3 id="操作符优先级问题"><a href="#操作符优先级问题" class="header-anchor">#</a> 操作符优先级问题</h3> <p>这个坑是入门级别的坑，比较常见，不多说了，详见<a href="https://gcc.gnu.org/onlinedocs/cpp/Operator-Precedence-Problems.html" target="_blank" rel="noopener noreferrer">Operator Precedence Problems<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h3 id="分号吞噬"><a href="#分号吞噬" class="header-anchor">#</a> 分号吞噬</h3> <p>经常会为一段逻辑定义一个宏，这段逻辑往往包含多条语句，譬如：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">define</span> DLog(format, ...) {                                                                 \
                             fprintf(stderr, &quot;[%s-%d: %s]&quot;, __FILE__, __LINE__, __func__);  \
                             fprintf(stderr, format&quot;\n&quot;, ##__VA_ARGS__);                    \
                         }</span>
</code></pre></div><p>正常情况下，执行这段代码是没有问题的，譬如：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">DLog</span><span class="token punctuation">(</span><span class="token string">&quot;他说：我和%s谈笑风声&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;美国的华莱士&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// mark</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码有两个问题：其一是把<code>mark</code>处的分号去掉，其实也是没问题的，但是我们希望能从编译合法性的层面强制用户加上分号；其二是在如下场景使用会存在问题：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span>
        <span class="token function">DLog</span><span class="token punctuation">(</span><span class="token string">&quot;他说：我和%s谈笑风声&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;美国的华莱士&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">DLog</span><span class="token punctuation">(</span><span class="token string">&quot;他说：你比%s跑得还快&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;西方记者&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码无法通过编译，因为展开是这样的：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span>__stderrp<span class="token punctuation">,</span> <span class="token string">&quot;[%s-%d: %s]&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;print.c&quot;</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span>__stderrp<span class="token punctuation">,</span> <span class="token string">&quot;他说：我和%s谈笑风声&quot;</span><span class="token string">&quot;\n&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;美国的华莱士&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span>__stderrp<span class="token punctuation">,</span> <span class="token string">&quot;[%s-%d: %s]&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;print.c&quot;</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span>__stderrp<span class="token punctuation">,</span> <span class="token string">&quot;他说：你比%s跑得还快&quot;</span><span class="token string">&quot;\n&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;西方记者&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>do-while</code>语句可以解决这两个问题：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">define</span> DLog(format, args...)                                           \
    do {                                                                \
        fprintf(stderr, &quot;[%s-%d: %s]&quot;, __FILE__, __LINE__, __func__);   \
        fprintf(stderr, format&quot;\n&quot;, ##args);                            \
    } while (0)</span>
</code></pre></div><p>P.S: 我认为在花括号外面加上<code>()</code>也可以解决这两个问题，这有什么其他的弊端吗？</p> <p>单纯从吞分号的作用来看，<code>({ /* do stuff */ })</code>和<code>do { /* do stuff */ } while(0)</code>效果相同，但是后者还有一个好处：可以处理 break 语句。函数宏中的<code>break</code>类似于函数中的<code>return</code>。如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">define</span> DEBUG 0</span>

<span class="token macro property">#<span class="token directive keyword">define</span> DLog(format, ...)                                               \
do {                                                                    \
    if (!DEBUG)  {                                                      \
        break;                                                          \
    }                                                                   \
    fprintf(stderr, &quot;[%s-%d: %s]&quot;, __FILE__, __LINE__, __func__);       \
    fprintf(stderr, format&quot;\n&quot;, ##__VA_ARGS__);                         \
} while(0)</span>
</code></pre></div><h3 id="副作用重复问题"><a href="#副作用重复问题" class="header-anchor">#</a> 副作用重复问题</h3> <p>定义一个宏，作用是返回两个参数中的较小者。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">define</span> MIN(X, Y) (((X) &gt; (Y)) ? (Y) : (X))</span>
</code></pre></div><p>似乎没什么问题，该保护的都保护了，但当我们这样使用时就有问题：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span><span class="token operator">++</span>a<span class="token punctuation">,</span> <span class="token operator">--</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不难分析毛病所在，问题是：如何避免呢？即如何确保<code>MIN(X, Y)</code>中的<code>X</code>或<code>Y</code>为表达式时，该表达式只被调用一次呢？即副作用只产生一次呢？
解决方法是使用<code>typeof</code>操作符：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">define</span> MIN(X, Y)               \
    ({                          \
        typeof(X) _x = (X); \
        typeof(Y) _y = (Y); \
        _x &gt; _y ? _y : _x;       \
    })</span>
</code></pre></div><p>P.S: 关于 typeof 的副作用说明，详见本文末尾的的补充说明。</p> <h2 id="宏的实际应用"><a href="#宏的实际应用" class="header-anchor">#</a> 宏的实际应用</h2> <p>iOS 平台下，与宏相关的第三方资源，最著名莫过于<a href="https://github.com/jspahrsummers/libextobjc" target="_blank" rel="noopener noreferrer">libextobjc<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（其作者也是 ReactiveCocoa 的作者之一），是一个非常好的学习资料。下面介绍一些频繁出现的并且有代表性的宏应用场景。</p> <h3 id="装-x-符"><a href="#装-x-符" class="header-anchor">#</a> 装 X 符 -- @</h3> <p>经常在代码中看到一些以<code>@</code>为前缀的宏的使用。譬如：<code>@within_main_thread(someBlock)</code>、<code>@strongify(self)</code>、<code>@weakify(self)</code>。<code>within_main_thread</code>是我在开发过程中，经常会用到的宏，目的是确保<code>someBlock</code>在主线程执行；后两个是 ReactiveCocoa 中引入的宏。</p> <p>这些宏要求在使用时必须使用<code>@</code>为前缀进行修饰，据说这样做的主要目的是为了显眼（装 X）。我更关心它们是如何做到的，根据代码，可以看到有两种常见的实现：</p> <ul><li>在宏的开始插入空的 try 语句，即<code>try {} @catch (...) {}</code>（有时候是<code>try {} @catch (...) {}</code>）</li> <li>在宏的开始插入空的 autorelease 语句，即<code>autoreleasepool {}</code></li></ul> <p>try 和 autoreleasepool 都要求补上<code>@</code>前缀，装 X 效果就达到了。问题来了，什么时候使用 try 的，什么时候使用 autoreleasepool 呢？</p> <p>ReactiveCocoa（v2.5）的 RACEXTScope.h 的处理如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">if</span> DEBUG</span>
<span class="token macro property">#<span class="token directive keyword">define</span> rac_keywordify autoreleasepool {}</span>
<span class="token macro property">#<span class="token directive keyword">else</span></span>
<span class="token macro property">#<span class="token directive keyword">define</span> rac_keywordify try {} @catch (...) {}</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
</code></pre></div><p>即在 debug 状态使用 autoreleasepool，release 状态使用 try。为什么是这样呢？</p> <p>在 release 状态使用 try 而非 autoreleasepool 的原因是，编译器对空的 try 语句有优化处理，不会影响到性能；而对空的 autoreleasepool 语句没有优化，会有性能损耗，为了装 X 折损性能有些得不偿失。</p> <p>P.S: 这个说法参考了<a href="https://github.com/jspahrsummers/libextobjc/pull/51" target="_blank" rel="noopener noreferrer">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>当然，try 语句也有副作用，如下有一段代码：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token punctuation">{</span>
    <span class="token comment">// 定义一个返回值为BOOL类型的block</span>
    BOOL <span class="token punctuation">(</span><span class="token operator">^</span>someBlock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span>BOOL <span class="token punctuation">{</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">&quot;do nothing&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码无法通过编译，因为<code>someBlock</code>没有提供匹配类型的返回值。</p> <p>现在在这个 block 中插入一段空的 try 语句：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token punctuation">{</span>
    <span class="token comment">// 定义一个返回值为BOOL类型的block</span>
    BOOL <span class="token punctuation">(</span><span class="token operator">^</span>someBlock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span>BOOL <span class="token punctuation">{</span>
        @<span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> @<span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 或者`@try {} @finally {}`</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">&quot;do nothing&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在可以通过编译了。try 语句的缺陷很明了：它会将返回值错误给掩盖掉。</p> <p>因此，ReactiveCocoa 采取了折中方案，在 debug 时使用 autorelease，在 release 状态使用 try。</p> <h2 id="宏的命名"><a href="#宏的命名" class="header-anchor">#</a> 宏的命名</h2> <p>宏在头文件里定义，参考 imeituan，宏的标识符都是大写，单词之间用<code>_</code>隔开，譬如<code>FOO_BAR</code>，有的宏是内部使用的，需要在首尾加上双下划线，譬如<code>__FOO_BAR__</code>。</p> <p>内联函数与宏有些相似，也经常在头文件中定义，只是函数名的习惯写法是小写，单词之间也使用<code>_</code>隔开，譬如<code>foo_bar(...)</code>，对于内部内联函数，也在首尾加上双下划线，譬如<code>__foo_bar__(...)</code>。</p> <p>P.S: 关于内联函数和函数宏，需要进行更多的分析和对比，以后补充吧！</p> <p><strong>补充：typeof</strong></p> <p><code>typeof</code>是 C 语言的基本操作符，<code>typeof(x)</code>返回<code>x</code>所对应的类型。<code>x</code>可以是一个类型名，也可以是一个表达式。
这里关心的是，当<code>typeof</code>的参数是一个表达式时，<code>typeof(expression)</code>会有副作用吗？即<code>expression</code>会被执行吗？譬如如下两行代码：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token function">typeof</span><span class="token punctuation">(</span><span class="token operator">++</span>i<span class="token punctuation">)</span> j <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token comment">// i此时的值为多少？</span>
</code></pre></div><p>答案是<code>3</code>。似乎 typeof 没有副作用（side effects），果真如此吗？看如下几行代码：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token function">typeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token punctuation">;</span>  <span class="token comment">// 声明一个长度为++i的数组</span>
<span class="token comment">// i此时的值为多少？</span>
</code></pre></div><p>答案是<code>4</code>，即<code>j</code>是一个长度为 4 的 int 型一维数组。此时 typeof 的副作用就体现出来了。这就蛋疼了，为什么有时候有副作用，有时没有副作用呢？</p> <p><a href="https://gcc.gnu.org/onlinedocs/gcc/Typeof.html" target="_blank" rel="noopener noreferrer">GCC-Typeof<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>是这么说的：</p> <blockquote><p>The operand of <code>typeof</code> is evaluated for its side effects if and only if it is an expression of variably modified type or the name of such a type.</p></blockquote> <p>这句话不是很好懂，我参考了<a href="https://stackoverflow.com/questions/11504629/side-effects-within-a-typeof-expression" target="_blank" rel="noopener noreferrer">Side Effects Within A typeof Expression<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。大概意思是，当<code>typeof(x)</code>中的<code>x</code>是一个 variably modified type 时，<code>x</code>这个表达式会被执行。<code>typeof(int[++i])</code>就属于这种情况。</p> <p>P.S: 对「variably modified type」的理解还不够，除了数组类型，还有其他的吗？</p> <p><strong>本文参考</strong></p> <ul><li><a href="https://gcc.gnu.org/onlinedocs/cpp/Macros.html" target="_blank" rel="noopener noreferrer">GCC Macros<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="noopener noreferrer">宏定义的黑魔法 - 宏菜鸟起飞手册<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.50bca889.js" defer></script><script src="/assets/js/5.081d1701.js" defer></script><script src="/assets/js/80.e06c5521.js" defer></script>
  </body>
</html>
