<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>TLS 协议 | 张不坏的博客</title>
    <meta name="description" content="Just For Fun">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.37bfab3d.css" as="style"><link rel="preload" href="/assets/js/app.50bca889.js" as="script"><link rel="preload" href="/assets/js/5.081d1701.js" as="script"><link rel="preload" href="/assets/js/104.7101a956.js" as="script"><link rel="preload" href="/assets/js/4.a7413ce2.js" as="script"><link rel="prefetch" href="/assets/js/10.7bb33f06.js"><link rel="prefetch" href="/assets/js/100.014ff06c.js"><link rel="prefetch" href="/assets/js/101.28f11de0.js"><link rel="prefetch" href="/assets/js/102.be9d2e87.js"><link rel="prefetch" href="/assets/js/103.a1210d81.js"><link rel="prefetch" href="/assets/js/105.833e6f80.js"><link rel="prefetch" href="/assets/js/106.978e1fc0.js"><link rel="prefetch" href="/assets/js/107.5af47fd0.js"><link rel="prefetch" href="/assets/js/108.efc3ce89.js"><link rel="prefetch" href="/assets/js/109.a69d6b5a.js"><link rel="prefetch" href="/assets/js/11.2de4afc9.js"><link rel="prefetch" href="/assets/js/110.30984b63.js"><link rel="prefetch" href="/assets/js/12.bfc099bd.js"><link rel="prefetch" href="/assets/js/13.20253e0d.js"><link rel="prefetch" href="/assets/js/14.67131b1c.js"><link rel="prefetch" href="/assets/js/15.1af26cbd.js"><link rel="prefetch" href="/assets/js/16.4b261ee0.js"><link rel="prefetch" href="/assets/js/17.1216332f.js"><link rel="prefetch" href="/assets/js/18.c0159773.js"><link rel="prefetch" href="/assets/js/19.0f007f87.js"><link rel="prefetch" href="/assets/js/2.b4633a05.js"><link rel="prefetch" href="/assets/js/20.4b295001.js"><link rel="prefetch" href="/assets/js/21.0c46767c.js"><link rel="prefetch" href="/assets/js/22.a5e065ea.js"><link rel="prefetch" href="/assets/js/23.f43a6a7e.js"><link rel="prefetch" href="/assets/js/24.245f4f15.js"><link rel="prefetch" href="/assets/js/25.618f74a1.js"><link rel="prefetch" href="/assets/js/26.274a606b.js"><link rel="prefetch" href="/assets/js/27.c2d8fe18.js"><link rel="prefetch" href="/assets/js/28.5c522d2a.js"><link rel="prefetch" href="/assets/js/29.c90fdb1a.js"><link rel="prefetch" href="/assets/js/3.9babd8f1.js"><link rel="prefetch" href="/assets/js/30.1ccbdebc.js"><link rel="prefetch" href="/assets/js/31.acf3eca6.js"><link rel="prefetch" href="/assets/js/32.ccfdc859.js"><link rel="prefetch" href="/assets/js/33.9b262756.js"><link rel="prefetch" href="/assets/js/34.c59a4044.js"><link rel="prefetch" href="/assets/js/35.2b10fefb.js"><link rel="prefetch" href="/assets/js/36.2daeeb7b.js"><link rel="prefetch" href="/assets/js/37.d649866c.js"><link rel="prefetch" href="/assets/js/38.aba1ac95.js"><link rel="prefetch" href="/assets/js/39.58a95fd1.js"><link rel="prefetch" href="/assets/js/40.8ef4d374.js"><link rel="prefetch" href="/assets/js/41.5799de7a.js"><link rel="prefetch" href="/assets/js/42.b7ee7489.js"><link rel="prefetch" href="/assets/js/43.28a65d64.js"><link rel="prefetch" href="/assets/js/44.90f92ea2.js"><link rel="prefetch" href="/assets/js/45.30b683fd.js"><link rel="prefetch" href="/assets/js/46.f57ccc19.js"><link rel="prefetch" href="/assets/js/47.7a82bd74.js"><link rel="prefetch" href="/assets/js/48.72503020.js"><link rel="prefetch" href="/assets/js/49.3a4ba077.js"><link rel="prefetch" href="/assets/js/50.0c3297f3.js"><link rel="prefetch" href="/assets/js/51.e9ba9363.js"><link rel="prefetch" href="/assets/js/52.473ee9ff.js"><link rel="prefetch" href="/assets/js/53.166d6e7a.js"><link rel="prefetch" href="/assets/js/54.78af3662.js"><link rel="prefetch" href="/assets/js/55.f0d54751.js"><link rel="prefetch" href="/assets/js/56.5de81531.js"><link rel="prefetch" href="/assets/js/57.6e18322f.js"><link rel="prefetch" href="/assets/js/58.1fccc879.js"><link rel="prefetch" href="/assets/js/59.773775e1.js"><link rel="prefetch" href="/assets/js/6.0c9cc532.js"><link rel="prefetch" href="/assets/js/60.0d665185.js"><link rel="prefetch" href="/assets/js/61.d9ae36dc.js"><link rel="prefetch" href="/assets/js/62.fb5e3b65.js"><link rel="prefetch" href="/assets/js/63.5ace8fda.js"><link rel="prefetch" href="/assets/js/64.d44fb0af.js"><link rel="prefetch" href="/assets/js/65.ed8fe56f.js"><link rel="prefetch" href="/assets/js/66.809078da.js"><link rel="prefetch" href="/assets/js/67.2489499e.js"><link rel="prefetch" href="/assets/js/68.e3ee952d.js"><link rel="prefetch" href="/assets/js/69.071411f8.js"><link rel="prefetch" href="/assets/js/7.8188415c.js"><link rel="prefetch" href="/assets/js/70.be8269cf.js"><link rel="prefetch" href="/assets/js/71.a320347a.js"><link rel="prefetch" href="/assets/js/72.f4fda48b.js"><link rel="prefetch" href="/assets/js/73.0f9f9284.js"><link rel="prefetch" href="/assets/js/74.b4028d07.js"><link rel="prefetch" href="/assets/js/75.6d63415f.js"><link rel="prefetch" href="/assets/js/76.d5b4df24.js"><link rel="prefetch" href="/assets/js/77.62b794e1.js"><link rel="prefetch" href="/assets/js/78.63e767ab.js"><link rel="prefetch" href="/assets/js/79.45056905.js"><link rel="prefetch" href="/assets/js/8.20d7cb0f.js"><link rel="prefetch" href="/assets/js/80.e06c5521.js"><link rel="prefetch" href="/assets/js/81.bc82bd01.js"><link rel="prefetch" href="/assets/js/82.4aeb6081.js"><link rel="prefetch" href="/assets/js/83.3ed6146f.js"><link rel="prefetch" href="/assets/js/84.f2aff9f4.js"><link rel="prefetch" href="/assets/js/85.2b8f4e50.js"><link rel="prefetch" href="/assets/js/86.27aea1da.js"><link rel="prefetch" href="/assets/js/87.7f5dc71e.js"><link rel="prefetch" href="/assets/js/88.9ca6511c.js"><link rel="prefetch" href="/assets/js/89.e8f54ad1.js"><link rel="prefetch" href="/assets/js/9.ee6c43f7.js"><link rel="prefetch" href="/assets/js/90.9abac718.js"><link rel="prefetch" href="/assets/js/91.9d8f5f36.js"><link rel="prefetch" href="/assets/js/92.2277b907.js"><link rel="prefetch" href="/assets/js/93.efca2f57.js"><link rel="prefetch" href="/assets/js/94.e9cc0386.js"><link rel="prefetch" href="/assets/js/95.fa3326f7.js"><link rel="prefetch" href="/assets/js/96.82bafc57.js"><link rel="prefetch" href="/assets/js/97.da22d13e.js"><link rel="prefetch" href="/assets/js/98.d745e5ec.js"><link rel="prefetch" href="/assets/js/99.79a6f693.js">
    <link rel="stylesheet" href="/assets/css/0.styles.37bfab3d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><div class="navbar"><div class="navbar-content"><div class="slogan">Valar Morghulis</div> <div class="links"><span class="link-item"><a href="/">首页</a></span> <span class="link-item"><a href="/category/iOS/">iOS</a></span> <span class="link-item"><a href="/category/other/">其他</a></span></div></div></div> <div class="content-header"><div class="post-title">TLS 协议</div> <div class="post-info">2017-03-02</div></div> <div class="content content__default"><p>本文是对《HTTPS 权威指南：在服务器和 Web 应用上部署 SSL/TLS 和 PKI》第 2 章内容的整理，该书的本章内容比较详细的介绍了 TLS 1.2 的内容。</p> <h2 id="记录协议"><a href="#记录协议" class="header-anchor">#</a> 记录协议</h2> <p>TLS 以记录协议（record protocol）实现。</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/image2017-2-6-RecordProtocol@2x.png" srcset="/image/image2017-2-6-RecordProtocol@2x.png 2x" data-v-339c7bd5></div> <p>何为记录协议？没有找到比较权威的定义，书中描述了如下特点：</p> <ul><li>消息传输。记录协议传输由其他协议层提交给它的不透明数据缓冲区。如果缓冲区超过记录的长度限制（16384 字节），记录协议会将其切分成更小的片段；反过来，同属一个子协议的多个小缓冲区可以组合成单独的记录</li> <li>加密以及完整性验证。一旦协商握手完成，记录协议会按照协商对数据进行加密和完整性验证</li> <li>压缩。记录协议还提供了数据压缩服务，但一般不使用，通常是由上层协议处理压缩</li> <li>扩展性。记录协议只关注数据传输和加密，而将所有其他特定转交给子协议，可以在此基础上扩展子协议</li></ul> <p>TLS 的 RFC 定义了 4 个核心子协议：</p> <ul><li>握手协议（handshake protocol）</li> <li>密钥规格变更协议（change cipher spec protocol）</li> <li>应用数据协议（application data protocol）</li> <li>警报协议（alert protocol）</li></ul> <p>下文会重点对这 4 个核心子协议展开详细描述。</p> <h2 id="握手协议"><a href="#握手协议" class="header-anchor">#</a> 握手协议</h2> <p>谈起握手，难免会想到 TCP 的握手过程，三次协商，非常清晰。相较而言，TLS 的握手过程似乎没那么容易理清楚，一共有几次协商呢？我之前看到的资料有说 6 次，有说 9 次等等。实际上，根据使用的功能、配置、扩展的不同，协商的变种非常多，一般来说，通常需要交换 6~10 次消息。有 3 种常见的握手流程：</p> <ul><li>完整的握手，对服务器进行身份验证</li> <li>恢复之前的会话采用的简短握手</li> <li>对客户端和服务器都进行身份验证的握手</li></ul> <h3 id="完整的握手（单向验证）"><a href="#完整的握手（单向验证）" class="header-anchor">#</a> 完整的握手（单向验证）</h3> <p>这是最常见的握手姿势（其他环境下的握手，懒得分析了，都差不多），时序图如下：</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/image2017-2-7-FullConnection@2x.png" srcset="/image/image2017-2-7-FullConnection@2x.png 2x" data-v-339c7bd5></div> <p>下表是对上述 10 次协商消息的说明：</p> <table><thead><tr><th style="text-align:left;">序号</th> <th style="text-align:left;">消息</th> <th style="text-align:left;">必须</th> <th style="text-align:left;">作用</th> <th style="text-align:left;">说明</th></tr></thead> <tbody><tr><td style="text-align:left;">1</td> <td style="text-align:left;">ClientHello</td> <td style="text-align:left;">是</td> <td style="text-align:left;">客户端开始新的握手，将自身支持的功能告诉服务器</td> <td style="text-align:left;">包括：Version（指示客户端支持的最佳协议版本）、Random（32byte 随机数，用于后续身份验证，可能为空）、Session ID（会话 ID，第一次连接时，为空）、Cipher Suites（客户端所支持的密码套件列表）、Compression（ 客户端支持的压缩算法，默认为 null，一般为默认值）、Extensions（扩展）</td></tr> <tr><td style="text-align:left;">2</td> <td style="text-align:left;">ServerHello</td> <td style="text-align:left;">是</td> <td style="text-align:left;">服务器选择连接参数</td> <td style="text-align:left;">包括：Version（服务端所支持的协议版本）、Random（32byte 随机数）、Session ID（会话 ID）、Cipher Suite（服务端所选用的密码套件）、Extensions（扩展）</td></tr> <tr><td style="text-align:left;">3</td> <td style="text-align:left;">Certificate</td> <td style="text-align:left;">否</td> <td style="text-align:left;">服务器发送其证书链</td> <td style="text-align:left;">认证信息，一般是服务器的 X.509 证书链，也可以是 PGP 密钥</td></tr> <tr><td style="text-align:left;">4</td> <td style="text-align:left;">ServerKeyExchange</td> <td style="text-align:left;">否</td> <td style="text-align:left;">根据选择密钥交换方式，服务器发送生成 master secret 的额外信息</td> <td style="text-align:left;">携带密钥交换的额外数据。消息内容对于不同的密码套件会存在差异，譬如对于 RSA 密钥交换算法，根本不需要这个消息</td></tr> <tr><td style="text-align:left;">5</td> <td style="text-align:left;">ServerHelloDone</td> <td style="text-align:left;">是</td> <td style="text-align:left;">服务器告诉客户端自己已完成了协商过程</td> <td style="text-align:left;">表明服务器已经将所有预计的握手消息发送完毕</td></tr> <tr><td style="text-align:left;">6</td> <td style="text-align:left;">ClientKeyExchange</td> <td style="text-align:left;">是</td> <td style="text-align:left;">客户端发送生成 master secret 所需的额外信息</td> <td style="text-align:left;">携带密钥交换提供的所有信息。消息内容对于不同的密码套件会存在差异</td></tr> <tr><td style="text-align:left;">7</td> <td style="text-align:left;">ChangeCipherSpec</td> <td style="text-align:left;">是</td> <td style="text-align:left;">客户端切换加密方式并通知服务器</td> <td style="text-align:left;">表明客户端已取得用以生成连接参数的所有信息，已经生成加密密钥（master secret），并将切换到加密模式</td></tr> <tr><td style="text-align:left;">8</td> <td style="text-align:left;">Finished</td> <td style="text-align:left;">是</td> <td style="text-align:left;">客户端计算发送和接收到的握手消息的 MAC 并发送</td> <td style="text-align:left;">意味着握手已经完成，消息内容将加密</td></tr> <tr><td style="text-align:left;">9</td> <td style="text-align:left;">ChangeCipherSpec</td> <td style="text-align:left;">是</td> <td style="text-align:left;">服务器切换加密方式并通知客户端</td> <td style="text-align:left;">表明服务端已取得用以生成连接参数的所有信息，已经生成加密密钥（master secret），并将切换到加密模式</td></tr> <tr><td style="text-align:left;">10</td> <td style="text-align:left;">Finished</td> <td style="text-align:left;">是</td> <td style="text-align:left;">服务器计算发送和接收到的握手消息的 MAC 并发送</td> <td style="text-align:left;">意味着握手已经完成，消息内容将加密</td></tr></tbody></table> <p>将上述 10 次协商分成几部分来阐述。</p> <p>首先是 ClientHello 和 ServerHello，这一个回合的交互用来建立基本的连接，并协商协议版本、密码套件、压缩方法，产生一个 Session ID，ClientHello.Extensions 和 ServerHello.Extensions 还可以用来扩展协商其他信息；ClientHello.Random 和 ServerHello.Random 在计算 master secret 时会用到。</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/image2017-2-7-ClientHello@2x.png" srcset="/image/image2017-2-7-ClientHello@2x.png 2x" data-v-339c7bd5></div> <p>P.S: 关于密码套件，下文会有说明。</p> <p>实际的密钥交换在主要 3（Certificate）、4（ServerKeyExchange）、6（ClientKeyExchange）这三个消息中完成。</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/image2017-2-7-Certificate@2x.png" srcset="/image/image2017-2-7-Certificate@2x.png 2x" data-v-339c7bd5></div> <p>这几个消息的具体内容对于不同的密码套件会存在差异。</p> <p>对于 Certificate 消息，一般都是服务器的 X.509 证书链（包括证书公钥），Client 可以对该证书进行验证，确保 Server 是合法受信任的，Certificate 也可能与 PGP 密钥有关，对 PGP 不熟，就不展开了...</p> <p>对于 ServerKeyExchange，它的内容与双方协商的密钥交换方法有关。假如使用的是 RSA 密钥交换算法，客户端生成 master secret 后，使用 Certificate 中的公钥对其进行加密，然后发送给服务端就 ok 了，无需 Server 提供更多的密钥生成参数；换句话说，ServerKeyExchange 在 RAS 密钥交换算法中没有什么卵用。</p> <p>P.S: 关于密钥交换算法，下文会有更多说明。</p> <p>生成 master secret 后，Client 还得向 Server 发送两个消息：ChangeCipherSpec 和 Finished；作为回应，Server 也会向 Client 发送 ChangeCipherSpec 和 Finished 消息。</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/image2017-2-7-ChangeCipherSpec@2x.png" srcset="/image/image2017-2-7-ChangeCipherSpec@2x.png 2x" data-v-339c7bd5></div> <p>接下来以 Q &amp; A 的形式，将握手流程搞得更清楚一点。</p> <p><strong>Q: 握手过程中，Server 连续向 Client 发送 ServerHello、Certificate、ServerKeyExchange、ServerHelloDone 这几个消息，可以把它们揉成一起吗？</strong></p> <p>A: 当然可以，本文开头描述记录协议的特点时讲到，对于同一个子协议的消息，如果内容过短，记录协议会将它们组合成一条记录；同样，如果消息内容过长，记录协议会将它拆分为多条记录（多次发送）；换句话说，是否将这些连续发送的消息揉成一起，还得看缓冲区的大小和消息内容的长度；用户无需操心。</p> <p><strong>Q: 为毛 ChangeCipherSpec 是一个独立的协议，而不是握手协议的一部分？</strong></p> <p>A: StackExchange 里有一个相关的问题：<a href="https://security.stackexchange.com/questions/24755/why-is-change-cipher-spec-an-independent-protocol-content-type-and-not-part-of-h" target="_blank" rel="noopener noreferrer">Why is change cipher spec an independent protocol content type and not part of Handshake Messages<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。其中的回答描述得非常清楚，结合这个答案，我的阐述是：ChangeCipherSpec 的作用是告诉另一端，接下来的消息将使用已经生成的 master secret 来加密。因此，需要确保 ChangeCipherSpec 之后的消息不会和之前的消息组合成一条记录，因为加密方式不一样嘛！ <em>ChangeCipherSpec 是一个单独的子协议</em> 这个事实能够解决这个问题，因为记录协议组合多个消息的前提是，这些消息同属一个子协议。</p> <p><strong>Q: Finished 消息有什么用？为啥最后 Server 还要向 Client 发送 ChangeCipherSpec 和 Finished 消息呢？</strong></p> <p>A: Finished 消息的数据其实非常简单，它包含一个 vertify_data 字段，该字段值的计算公式可以简单描述为：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// PRF（pseudorandom function，伪随机函数），该算法在密码套件中说明</span>
<span class="token comment">// master_secret，主密钥</span>
<span class="token comment">// finished_label，标签，一个字符串</span>
<span class="token comment">// Hash(handshake_messages)，即握手过程中所有消息的散列值</span>
vertify_data <span class="token operator">=</span> <span class="token function">PRF</span><span class="token punctuation">(</span>master_secret<span class="token punctuation">,</span> finished_label<span class="token punctuation">,</span> <span class="token function">Hash</span><span class="token punctuation">(</span>handshake_messages<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>两端的 PRF 算法是一样的，但会使用不同的标签（finished_label），对于 server，对应<code>&quot;server finished&quot;</code>，对于 client，对应<code>&quot;client finished&quot;</code>。</p> <p>vertify_data 字段有什么用呢？该字段用于验证密钥交换和认证过程都是 ok 了；<a href="https://tools.ietf.org/html/rfc5246#section-7.4.9" target="_blank" rel="noopener noreferrer">RFC5246<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的描述是：</p> <blockquote><p>Once a side has sent its Finished message and received and validated the Finished message from its peer, it may begin to send and receive application data over the connection.</p></blockquote> <p>可以看到，两端只有在发出 Finished 消息、接收对方的 Finished 消息并且验证通过后，才可以在信道中发送和接收应用层数据。</p> <p>P.S: 似乎 RFC 并没有强调发出 Finished 消息和接收 Finished 的次序...</p> <h3 id="计算-master-secret"><a href="#计算-master-secret" class="header-anchor">#</a> 计算 Master Secret</h3> <p>握手阶段的所有协商，最终目的是计算得到 master secret，后者用于传输应用层数据时的加密算法（对称加密算法）的密钥，粗略描述计算过程很简单：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 48 bytes</span>
master_secret <span class="token operator">=</span> <span class="token function">PRF</span><span class="token punctuation">(</span>pre_master_secret<span class="token punctuation">,</span> <span class="token string">&quot;master secret&quot;</span><span class="token punctuation">,</span> ClientHello<span class="token punctuation">.</span>random <span class="token operator">+</span> ServerHello<span class="token punctuation">.</span>random<span class="token punctuation">)</span>
</code></pre></div><h2 id="密码套件"><a href="#密码套件" class="header-anchor">#</a> 密码套件</h2> <p>之前的第三弹 理解 HTTPS 对密码套件（Cipher Suite）已有所描述，这一部分再补充一下。下图描述了密码套件的名称构成：</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/image2017-2-7-Cipher-Suite@2x.png" srcset="/image/image2017-2-7-Cipher-Suite@2x.png 2x" data-v-339c7bd5></div> <p>图中的这个套件在不同版本下的 TLS，有不同的解释，对于 TLS 1.2 而言，它描述的信息包括：</p> <ul><li>密钥交换：ECDHE_RSA</li> <li>加密：AES_128_GCM</li> <li>MAC（Message Authentication Code，用于计算消息摘要，与完整性保护有关）：SHA256</li> <li>PRF（用于计算 master secret）：SHA256</li></ul> <h2 id="密钥交换"><a href="#密钥交换" class="header-anchor">#</a> 密钥交换</h2> <p>TLS 1.2 支持的密钥交换算法有很多，譬如 RSA、Diffie-Hellman（DH）、椭圆曲线 Diffie-Hellman 等，对加密而言，我完全是门外汉，本文只是简单介绍 RSA 和 DH 这两种密钥交换算法，目的仍然是帮助更好理解 TLS 协议。</p> <h3 id="rsa-密钥交换"><a href="#rsa-密钥交换" class="header-anchor">#</a> RSA 密钥交换</h3> <p>RSA 本身是公钥加密算法（非对称加密算法），其密钥交换的核心思想非常简单：客户端产生一个 48 字节的 pre master secret，然后使用 server 的证书的公钥对其进行加密，然后传给 server，server 收到后，使用私钥进行解密；之后，双方使用相同的 pre master secret，在之前协商的 PRF 计算得到 master secret。RFC 的描述是：</p> <blockquote><p>When RSA is used for server authentication and key exchange, a 48- byte pre_master_secret is generated by the client, encrypted under the server's public key, and sent to the server. The server uses its private key to decrypt the pre_master_secret. Both parties then convert the pre_master_secret into the master_secret, as specified above.</p></blockquote> <p>RSA 非常直接简单，但是存在一个非常严重的弱点。用于加密 pre master secret 的公钥，一般会保持多年不变。如果私钥被窃取了，那么攻击者就可以恢复得到 pre master secret，从而危害会话的安全性。</p> <h3 id="diffie-hellman-密钥交换"><a href="#diffie-hellman-密钥交换" class="header-anchor">#</a> Diffie-Hellman 密钥交换</h3> <p>Diffie-Hellman（DH）密钥交换是一种密钥协定的协议，它使两端在不安全的信道上生成共享密钥称为可能。</p> <p>抛开算法细节，DH 密钥交换需要 6 个参数，其中包括两个域参数（使用 g、p 标记），一般由 server 提供；协商过程中，客户端和服务器各自生成两个参数，对于客户端，使用 c 和 C 标记，对于服务器，使用 s 和 S 标记，c 和 s 是私密的，C 和 S 分别由 c 和 s 计算得来，需要在协商过程中传给对方。对于 TLS 而言，DH 最终产生的目标数即上文提到的 pre master secret，如下图：</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/image2017-2-7-Diffie-Hellman@2x.png" srcset="/image/image2017-2-7-Diffie-Hellman@2x.png 2x" data-v-339c7bd5></div> <p>DH 密钥交换算法的安全性取决于域参数的质量，域参数由 server 提供，client 对之无能为力。另外，DH 算法是计算密集型任务，容易受到阻塞性攻击，即攻击者请求大量的密钥，受攻击者得花费相当多的资源去做没啥意义的计算，因此 DH 密钥交换通常与身份验证联合使用，以避免中间人攻击。</p> <p>P.S: 关于 Diffie-Hellman 的更多内容，参考<a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" target="_blank" rel="noopener noreferrer">Diffie-Hellman<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.50bca889.js" defer></script><script src="/assets/js/5.081d1701.js" defer></script><script src="/assets/js/104.7101a956.js" defer></script><script src="/assets/js/4.a7413ce2.js" defer></script>
  </body>
</html>
