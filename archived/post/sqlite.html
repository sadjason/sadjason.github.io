<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>漫谈 SQLite | 张不坏的博客</title>
    <meta name="description" content="Just For Fun">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.37bfab3d.css" as="style"><link rel="preload" href="/assets/js/app.50bca889.js" as="script"><link rel="preload" href="/assets/js/5.081d1701.js" as="script"><link rel="preload" href="/assets/js/101.28f11de0.js" as="script"><link rel="preload" href="/assets/js/4.a7413ce2.js" as="script"><link rel="prefetch" href="/assets/js/10.7bb33f06.js"><link rel="prefetch" href="/assets/js/100.014ff06c.js"><link rel="prefetch" href="/assets/js/102.be9d2e87.js"><link rel="prefetch" href="/assets/js/103.a1210d81.js"><link rel="prefetch" href="/assets/js/104.7101a956.js"><link rel="prefetch" href="/assets/js/105.833e6f80.js"><link rel="prefetch" href="/assets/js/106.978e1fc0.js"><link rel="prefetch" href="/assets/js/107.5af47fd0.js"><link rel="prefetch" href="/assets/js/108.efc3ce89.js"><link rel="prefetch" href="/assets/js/109.a69d6b5a.js"><link rel="prefetch" href="/assets/js/11.2de4afc9.js"><link rel="prefetch" href="/assets/js/110.30984b63.js"><link rel="prefetch" href="/assets/js/12.bfc099bd.js"><link rel="prefetch" href="/assets/js/13.20253e0d.js"><link rel="prefetch" href="/assets/js/14.67131b1c.js"><link rel="prefetch" href="/assets/js/15.1af26cbd.js"><link rel="prefetch" href="/assets/js/16.4b261ee0.js"><link rel="prefetch" href="/assets/js/17.1216332f.js"><link rel="prefetch" href="/assets/js/18.c0159773.js"><link rel="prefetch" href="/assets/js/19.0f007f87.js"><link rel="prefetch" href="/assets/js/2.b4633a05.js"><link rel="prefetch" href="/assets/js/20.4b295001.js"><link rel="prefetch" href="/assets/js/21.0c46767c.js"><link rel="prefetch" href="/assets/js/22.a5e065ea.js"><link rel="prefetch" href="/assets/js/23.f43a6a7e.js"><link rel="prefetch" href="/assets/js/24.245f4f15.js"><link rel="prefetch" href="/assets/js/25.618f74a1.js"><link rel="prefetch" href="/assets/js/26.274a606b.js"><link rel="prefetch" href="/assets/js/27.c2d8fe18.js"><link rel="prefetch" href="/assets/js/28.5c522d2a.js"><link rel="prefetch" href="/assets/js/29.c90fdb1a.js"><link rel="prefetch" href="/assets/js/3.9babd8f1.js"><link rel="prefetch" href="/assets/js/30.1ccbdebc.js"><link rel="prefetch" href="/assets/js/31.acf3eca6.js"><link rel="prefetch" href="/assets/js/32.ccfdc859.js"><link rel="prefetch" href="/assets/js/33.9b262756.js"><link rel="prefetch" href="/assets/js/34.c59a4044.js"><link rel="prefetch" href="/assets/js/35.2b10fefb.js"><link rel="prefetch" href="/assets/js/36.2daeeb7b.js"><link rel="prefetch" href="/assets/js/37.d649866c.js"><link rel="prefetch" href="/assets/js/38.aba1ac95.js"><link rel="prefetch" href="/assets/js/39.58a95fd1.js"><link rel="prefetch" href="/assets/js/40.8ef4d374.js"><link rel="prefetch" href="/assets/js/41.5799de7a.js"><link rel="prefetch" href="/assets/js/42.b7ee7489.js"><link rel="prefetch" href="/assets/js/43.28a65d64.js"><link rel="prefetch" href="/assets/js/44.90f92ea2.js"><link rel="prefetch" href="/assets/js/45.30b683fd.js"><link rel="prefetch" href="/assets/js/46.f57ccc19.js"><link rel="prefetch" href="/assets/js/47.7a82bd74.js"><link rel="prefetch" href="/assets/js/48.72503020.js"><link rel="prefetch" href="/assets/js/49.3a4ba077.js"><link rel="prefetch" href="/assets/js/50.0c3297f3.js"><link rel="prefetch" href="/assets/js/51.e9ba9363.js"><link rel="prefetch" href="/assets/js/52.473ee9ff.js"><link rel="prefetch" href="/assets/js/53.166d6e7a.js"><link rel="prefetch" href="/assets/js/54.78af3662.js"><link rel="prefetch" href="/assets/js/55.f0d54751.js"><link rel="prefetch" href="/assets/js/56.5de81531.js"><link rel="prefetch" href="/assets/js/57.6e18322f.js"><link rel="prefetch" href="/assets/js/58.1fccc879.js"><link rel="prefetch" href="/assets/js/59.773775e1.js"><link rel="prefetch" href="/assets/js/6.0c9cc532.js"><link rel="prefetch" href="/assets/js/60.0d665185.js"><link rel="prefetch" href="/assets/js/61.d9ae36dc.js"><link rel="prefetch" href="/assets/js/62.fb5e3b65.js"><link rel="prefetch" href="/assets/js/63.5ace8fda.js"><link rel="prefetch" href="/assets/js/64.d44fb0af.js"><link rel="prefetch" href="/assets/js/65.ed8fe56f.js"><link rel="prefetch" href="/assets/js/66.809078da.js"><link rel="prefetch" href="/assets/js/67.2489499e.js"><link rel="prefetch" href="/assets/js/68.e3ee952d.js"><link rel="prefetch" href="/assets/js/69.071411f8.js"><link rel="prefetch" href="/assets/js/7.8188415c.js"><link rel="prefetch" href="/assets/js/70.be8269cf.js"><link rel="prefetch" href="/assets/js/71.a320347a.js"><link rel="prefetch" href="/assets/js/72.f4fda48b.js"><link rel="prefetch" href="/assets/js/73.0f9f9284.js"><link rel="prefetch" href="/assets/js/74.b4028d07.js"><link rel="prefetch" href="/assets/js/75.6d63415f.js"><link rel="prefetch" href="/assets/js/76.d5b4df24.js"><link rel="prefetch" href="/assets/js/77.62b794e1.js"><link rel="prefetch" href="/assets/js/78.63e767ab.js"><link rel="prefetch" href="/assets/js/79.45056905.js"><link rel="prefetch" href="/assets/js/8.20d7cb0f.js"><link rel="prefetch" href="/assets/js/80.e06c5521.js"><link rel="prefetch" href="/assets/js/81.bc82bd01.js"><link rel="prefetch" href="/assets/js/82.4aeb6081.js"><link rel="prefetch" href="/assets/js/83.3ed6146f.js"><link rel="prefetch" href="/assets/js/84.f2aff9f4.js"><link rel="prefetch" href="/assets/js/85.2b8f4e50.js"><link rel="prefetch" href="/assets/js/86.27aea1da.js"><link rel="prefetch" href="/assets/js/87.7f5dc71e.js"><link rel="prefetch" href="/assets/js/88.9ca6511c.js"><link rel="prefetch" href="/assets/js/89.e8f54ad1.js"><link rel="prefetch" href="/assets/js/9.ee6c43f7.js"><link rel="prefetch" href="/assets/js/90.9abac718.js"><link rel="prefetch" href="/assets/js/91.9d8f5f36.js"><link rel="prefetch" href="/assets/js/92.2277b907.js"><link rel="prefetch" href="/assets/js/93.efca2f57.js"><link rel="prefetch" href="/assets/js/94.e9cc0386.js"><link rel="prefetch" href="/assets/js/95.fa3326f7.js"><link rel="prefetch" href="/assets/js/96.82bafc57.js"><link rel="prefetch" href="/assets/js/97.da22d13e.js"><link rel="prefetch" href="/assets/js/98.d745e5ec.js"><link rel="prefetch" href="/assets/js/99.79a6f693.js">
    <link rel="stylesheet" href="/assets/css/0.styles.37bfab3d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><div class="navbar"><div class="navbar-content"><div class="slogan">Valar Morghulis</div> <div class="links"><span class="link-item"><a href="/">首页</a></span> <span class="link-item"><a href="/category/iOS/">iOS</a></span> <span class="link-item"><a href="/category/other/">其他</a></span></div></div></div> <div class="content-header"><div class="post-title">漫谈 SQLite</div> <div class="post-info">2019-11-24</div></div> <div class="content content__default"><p>作为移动开发者，或多或少会与 SQLite 直接或间接打过交道，在使用过程中可能有如下疑问：</p> <ul><li>SQLite 是线程安全的吗？</li> <li>SQLite 支持并发读写吗？</li> <li>常在数据库文件目录看到的 -wal 文件是什么？</li> <li>常看到的概念 checkpoint 是什么？</li></ul> <p>本文是浅层次但较系统学习 SQLite 后的总结笔记，看完或许能解答上述问题；本文叙述的出发点是从设计一个简单的 SQLite framework 开始；关于 SQLite 的第三方库有很多，对于 iOS 生态，知名的包括 FMDB、WCDB、GRDB、SQLite.swift 等，学习它们也是本文的一个任务之一。</p> <blockquote><p>以熟悉 Swift 和 SQLite 为目的，写了一个类似于 FMDB 的 SQLite wrapper，详见 <a href="https://github.com/sadjason/SBDB" target="_blank" rel="noopener noreferrer">SBDB<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <p>在设计一个 SQLite framework 过程中，需要理解 SQLite APIs 的使用，以及一些核心概念，包括 SQLite 的线程安全模型、所支持的并发模型等等。编写一个 SQLite 工具库并非常见需求，但私以为此过程有助于帮助更全面理解 SQLite 以及更好地使用 SQLite。</p> <h2 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h2> <p>关于 SQLite 的介绍可以从官方的 <a href="https://sqlite.org/about.html" target="_blank" rel="noopener noreferrer">About SQLite<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 开始，本文罗列一些重要的点：</p> <ul><li>发明人：<a href="http://www.hwaci.com/drh/" target="_blank" rel="noopener noreferrer">D. Richard Hipp<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>本质上是一个 ANSI-C 库，轻量（百 KB 级别），<a href="https://sqlite.org/src/doc/trunk/README.md" target="_blank" rel="noopener noreferrer">开源<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <ul><li>兼容性好，所有系统都可以调用 C 语言写的库</li> <li>低依赖，在最小配置下，只使用了 memcmp、strcmp 等少数几个标准库 API</li></ul></li> <li>主流移动操作系统（iOS &amp; Android）已内置</li> <li>数据库文件格式稳定，向后兼容，跨平台；坚持 50 年不动摇（2000-2050）</li> <li>本地存储，不支持网络访问</li> <li>无权限管理机制</li> <li>不支持加密
<ul><li>可以使用开源的加密库代替系统内置的动态库实现加密，譬如 <a href="https://github.com/sqlcipher/sqlcipher" target="_blank" rel="noopener noreferrer">SQLCipher<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></li> <li>支持全文搜索（FTS）</li> <li>当前主流版本是 v3，这也是本文内容的参考版本</li> <li>变长记录存储，即删除数据也不会减小数据库文件，除非使用 <code>vacuum</code> 命令 rebuild 数据库文件</li></ul> <h3 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h3> <p>把 SQLite 数据类型专门拧出来介绍是因为它相对于其他 SQL 数据库有一些特别之处...</p> <p>SQLite 支持 5 种存储类型：</p> <ul><li><strong>integer</strong>: 有符号整型，根据数值大小，可能存 1/2/3/4/6/8 bytes</li> <li><strong>real</strong>: 浮点类型，8 bytes</li> <li><strong>text</strong>: 字符串（支持 utf-8、utf-16）</li> <li><strong>blob</strong>: 二进制数据，输入啥，就存啥</li> <li><strong>null</strong>: NULL 值</li></ul> <p>和其他 SQL 数据库不太一样的是，SQLite 的列没有真正的类型约束；作为对比，其他数据库譬如 MySQL 在创建数据表定义字段时，一定要指定列（字段）类型，之后插入数据时，得确保值和列类型匹配。SQLite 没有这样的约束，任何列（除了 integer 型主键列 ）都可以同时存储如上 5 种类型值。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token operator">&gt;</span> <span class="token keyword">create</span> <span class="token keyword">table</span> foo <span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">-- 定义字段 bar，但没有指定类型</span>
<span class="token operator">&gt;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> foo <span class="token punctuation">(</span>bar<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">-- 插入整型值</span>
<span class="token operator">&gt;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> foo <span class="token punctuation">(</span>bar<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">-- 插入 null</span>
<span class="token operator">&gt;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> foo <span class="token punctuation">(</span>bar<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token string">&quot;42&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">-- 插入字符串</span>
<span class="token operator">&gt;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> foo <span class="token punctuation">(</span>bar<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">42.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">-- 插入浮点值</span>
<span class="token operator">&gt;</span> <span class="token keyword">select</span> typeof<span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">,</span> bar <span class="token keyword">from</span> foo<span class="token punctuation">;</span>     <span class="token comment">-- 其中 `typeof` 返回值类型</span>
<span class="token number">42</span>   <span class="token operator">|</span> <span class="token keyword">integer</span>
     <span class="token operator">|</span> <span class="token boolean">null</span>
<span class="token number">42</span>   <span class="token operator">|</span> <span class="token keyword">text</span>
<span class="token number">42.0</span> <span class="token operator">|</span> <span class="token keyword">real</span>
</code></pre></div><p>然而，SQLite 定义数据表时也是可以为字段指定类型的，譬如: <code>create table foo (field1 numeric, field2 blob, field3)</code>，但这些类型并不起约束作用，它们在 SQLite 语义中被称为：type affinity，常译为「类型相像」。也有 5 种类型：<strong>integer</strong>、<strong>real</strong>、<strong>text</strong>、<strong>blob</strong>、<strong>numeric</strong>。</p> <p>可以把 type affinity 理解为转换器，以 text 为例，如果列的 type affinity 为 text，那么 insert 数据时，内部会将插入的数据尽可能转为字符串，譬如插入 <code>1</code>，则存为 <code>&quot;1&quot;</code>；插入 <code>2.0</code>，则存为 <code>&quot;2.0&quot;</code>；如果插入 <code>null</code>，则仍然存为 <code>null</code>。<a href="https://www.sqlite.org/datatype3.html#type_affinity" target="_blank" rel="noopener noreferrer">SQLite 官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中有着详细说明，本文不多赘述。</p> <h3 id="核心-apis"><a href="#核心-apis" class="header-anchor">#</a> 核心 APIs</h3> <p>SQLite 的 APIs 超过 <a href="https://www.sqlite.org/cintro.html" target="_blank" rel="noopener noreferrer">200<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 个，但查看使用 SQLite 的知名库（譬如 FMDB、YYCache  等）的源码，可以发现它们使用的 API 都非常少。</p> <p>实际上，基于 2 个类型，8 个核心 APIs 就能完成基本功能：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token punctuation">{</span>
    <span class="token comment">// 两个核心类型：</span>
    <span class="token comment">// - sqlite3: 句柄，代表连接</span>
    <span class="token comment">// - sqlite3_stmt: statement，可以简单理解为 sql 语句的抽象</span>
    sqlite3 <span class="token operator">*</span>db <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> sqlite3_stmt <span class="token operator">*</span>stmt <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token comment">// 八个核心 APIs:</span>
    <span class="token comment">// - sqlite3_open/sqlite3_close: 用于打开/关闭连接</span>
    <span class="token comment">// - sqlite3_prepare/sqlite3_finalize: 创建/销毁 statement</span>
    <span class="token comment">// - sqlite3_bind 系列: 为 statement 绑定参数</span>
    <span class="token comment">// - sqlite3_step: 执行 statement，对于 select 语句，可能要执行多次</span>
    <span class="token comment">// - sqlite3_reset: 将 statement 恢复到初始状态（譬如解除绑定的参数），以便重复使用</span>
    <span class="token comment">// - sqlite3_exec: sqlite3_prepare/sqlite3_step/sqlite3_finalize 的 wrapper</span>
    <span class="token function">sqlite3_open</span><span class="token punctuation">(</span><span class="token string">&quot;path/to/db&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sqlite3_prepare</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">&quot;select * from someTable where id = ?&quot;</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stmt<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sqlite3_bind_int</span><span class="token punctuation">(</span>stmt<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">sqlite3_step</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span> <span class="token operator">==</span> SQLITE_ROW<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用 sqlite3_column 系列 API 提取数据</span>
    <span class="token punctuation">}</span>
    <span class="token function">sqlite3_finalize</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 或者使用 `sqlite3_reset(stmt);`</span>
    <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">&quot;drop table someTable&quot;</span><span class="token punctuation">,</span> nil<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sqlite3_close</span><span class="token punctuation">(</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 如上 API 中，除了 sqlite3_stmt 和相关 API，都比较容易理解；</span>
<span class="token comment">// 对于 sqlite3_stmt 和相关 API，花太多文字描述感觉意义不大，写点 demo 就能很快理解了</span>
</code></pre></div><p>看起来挺简单？然而，实际操作中有不少问题要处理，包括但不限于：</p> <ul><li>基本问题
<ul><li>类型适配、API 封装</li> <li>线程安全：选择合适的线程模型</li> <li>事务与并发：设计合适的事务管理模式</li> <li>提高易用性：ORM、避免用户写 SQL 语句</li> <li>防注入</li></ul></li> <li>性能与可靠性
<ul><li>性能监控</li> <li>损坏修复</li> <li>性能提升</li></ul></li></ul> <p>本文没打算将上述所有点都涉及到，将内容主要收敛在基础方面，讨论：线程安全、事务、并发。</p> <h2 id="线程安全"><a href="#线程安全" class="header-anchor">#</a> 线程安全</h2> <p>不同场景下，讨论线程安全的关注点可能不一样，譬如死锁、非主线程执行 UI 操作等。对于 SQLite，本文讨论的点是：是否可以在任何线程使用 SQLite 的 API，且不会带来数据安全问题。</p> <p>SQLite 的 API 是支持多线程访问的，多线程访问必然带来数据安全问题。</p> <p>为了确保数据库安全，SQLite 内部抽象了两种类型的互斥锁（锁的具体实现和宿主平台有关）来应对线程并发问题：</p> <ul><li><strong>fullMutex</strong> <ul><li>可以理解为 connection mutex，和连接句柄（上问描述的 sqlite3 结构体）绑定</li> <li>保证任何时候，最多只有一个线程在执行基于连接的事务</li></ul></li> <li><strong>coreMutex</strong> <ul><li>当前进程中，与文件绑定的锁</li> <li>用于保护数据库相关临界资源，确保在任何时候，最多只有一个线程在访问</li></ul></li></ul> <p>下面画了一张图用来描述 fullMutex 和 coreMutex 所起到的作用：</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/sqlite_mutex.png" srcset="/image/sqlite_mutex.png 2x" data-v-339c7bd5></div> <p>如何理解 fullMutex？SQLite 中与数据访问相关的 API 都是通过连接句柄 sqlite3 进行访问的，基于 fullMutex 锁，如果多个线程同时访问某个 API -- 譬如 <code>sqlite3_exec(db, ...)</code>，SQLite 内部会根据连接的 mutex 将该 API 的逻辑给保护起来，确保只有一个线程在执行，其他线程会被 mutex 给 block 住。</p> <p>对于 coreMutex，它用来保护数据库相关临界资源，包括本文将要介绍的文件锁。</p> <p>用户可以配置这两种锁，对这两种锁的控制衍生出 SQLite 所支持的 <a href="https://www.sqlite.org/threadsafe.html" target="_blank" rel="noopener noreferrer">三种线程模型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p> <ul><li><strong>single-thread</strong> <ul><li>coreMutex 和 fullMutex 都被禁用</li> <li>用户层需要确保在任何时候只有一个线程访问 API，否则报错（crash）</li></ul></li> <li><strong>multi-thread</strong> <ul><li>coreMutex 保留，fullMutex 禁用</li> <li>可以多个线程基于不同的连接并发访问数据库，但单个连接在任何时候只能被一个线程访问</li> <li>单个 connection，如果并发访问，会报错（crash）
<ul><li>报错信息：illegal multi-threaded access to database connection</li></ul></li></ul></li> <li><strong>serialized</strong> <ul><li>coreMutex 和 fullMutex 都保留</li></ul></li></ul> <p>如何配置线程模型呢？有三个阶段可以配置线程模型：</p> <ul><li><strong>compile-time</strong> <ul><li>相当于全局设置</li> <li>在编译时设置编译选项 SQLITE_THREADSAFE 的值指定线程模型：
<ul><li><code>0</code> : single-thread, <code>1</code> : serialized, <code>2</code>: multi-thread</li></ul></li> <li>通过 <code>sqlite3_threadsafe()</code> 可以在运行时知道所用的 sqlite3 库的 SQLITE_THREADSAFE 编译选项值</li></ul></li> <li><strong>start-time</strong> <ul><li>相当于应用级设置，会覆盖 SQLITE_THREADSAFE 的选项配置</li> <li>在第一次使用 SQLite API 之前，通过 sqlite3_config 指定线程模型
<ul><li><code>sqlite3_config(SQLITE_CONFIG_SINGLETHREAD</code>: 设置 single-thread
<ul><li>经测试验证，iOS 和 macOS 内置的 SQLite 不允许该模式</li></ul></li> <li><code>sqlite3_config(SQLITE_CONFIG_MULTITHREAD)</code>: 设置 multi-thread</li> <li><code>sqlite3_config(SQLITE_CONFIG_SERIALIZED)</code>: 设置 serialized</li></ul></li></ul></li> <li><strong>run-time</strong> <ul><li>使用 <code>sqlite3_open_v2()</code> 建立连接时为第三个参数（flags 参数）指定值，即为每个连接配置 fullMutex 的使能开关：
<ul><li><code>SQLITE_OPEN_NOMUTEX</code>，关闭 fullMutex，即 multi-thread 模式</li> <li><code>SQLITE_OPEN_FULLMUTEX</code>，打开 fullMutex，即 serialized 模式</li></ul></li></ul></li></ul> <p>来个 Demo 直观感受这几种线程模型：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// multi-thread.c</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">access_database</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>db<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sqlite3 <span class="token operator">*</span><span class="token punctuation">)</span>db<span class="token punctuation">,</span> <span class="token string">&quot;begin&quot;</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sqlite3 <span class="token operator">*</span><span class="token punctuation">)</span>db<span class="token punctuation">,</span> <span class="token string">&quot;end&quot;</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sqlite3_config</span><span class="token punctuation">(</span>SQLITE_CONFIG_MULTITHREAD<span class="token punctuation">)</span> <span class="token operator">==</span> SQLITE_OK<span class="token punctuation">)</span> 
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;设置 multi-thread 模式成功\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    sqlite3 <span class="token operator">*</span>db <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token function">sqlite3_open</span><span class="token punctuation">(</span><span class="token string">&quot;./test.db&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 模拟主线程和子线程并发访问数据库</span>
        pthread_t p<span class="token punctuation">;</span>
        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> access_database<span class="token punctuation">,</span> db<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">access_database</span><span class="token punctuation">(</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">sqlite3_close</span><span class="token punctuation">(</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// gcc multi-thread.c -lsqlite3</span>
</code></pre></div><p>上述 demo 代码中，两个线程基于同一个连接访问数据库，分别访问了 1000 次，基本上能够触发两个线程同时访问数据库的场景，程序的执行会以 crash 结束，因为在一开始通过 <code>sqlite3_config()</code> 配置了 multi-thread 线程模式。</p> <p>如果将 <code>SQLITE_CONFIG_MULTITHREAD</code> 改为 <code>SQLITE_CONFIG_SERIALIZED</code>，即将 multi-thread 线程模式改为 serialized 模式，程序就可以正常运行。</p> <p>另外，如果上述 demo 中两个线程使用的是独立的连接，又是不一样的结果：multi-thread 模式下，SQLite 允许多个线程使用访问数据库，只要不是同一个连接就 ok 了。</p> <p>搞清楚了 fullMutex 和 coreMutex 的作用，理解 SQLite 提供的这三种线程模型并不难，此处稍作总结。</p> <p>single-thread 模式下，使用者要承担较多线程安全职责：确保在任何时候，只有一个线程访问数据库，对于移动端而言，实在想不到使用它的收益，对于别的场景，譬如单线程模式下的嵌入式设备，或许有它存在的价值。经测试，macOS、iOS 内置 SQLite 禁掉了该模型。</p> <p>Serialized 模式看似是最省心的，用户完全不用担心「illegal multi-threaded access to database connection」crash；但它付出的代价是，任何基于连接句柄的 API 操作都会有一个锁检测逻辑，对效率有所折损。</p> <blockquote><p>关于 fullMutex 锁的效率折损，经 demo 测试：上千次连续读写，发现并不明显。</p></blockquote> <p>在实际使用中，选择最多的是 multi-thread 模式，它也是 iOS/macOS 内置 sqlite 库的默认模式；在multi-thread 模式，需要在用户层保证任何时候只有线程在使用连接句柄（sqlite3 实例）访问数据库。</p> <h2 id="事务与并发"><a href="#事务与并发" class="header-anchor">#</a> 事务与并发</h2> <p>SQLite 的线程安全问题相对来说是比较容易搞定的，毕竟可以通过配置合适的线程模型，或者在应用层通过队列等手段来规避；但并发问题就复杂得多。</p> <p>不同语境下并发所指的意义可能不一样，对于 SQLite 而言，讨论并发的粒度是事务；也就 SQLite 是否支持并发事务；所以本文将事务和并发放在一起讨论。先抛出结论：</p> <ul><li><strong>SQLite 支持并发执行读事务，即可以同时开启多个进程/线程从数据库读数据</strong></li> <li><strong>SQLite 不支持并发执行写事务，即不能多个进程/线程同时往数据库写数据</strong></li></ul> <blockquote><p>如上并非完整的结论，SQLite 对并发读写 -- 也即同时进行读事务和写事务 -- 的支持如何？这个问题的答案与用户所选择的日志模型有关，下文有分析。</p></blockquote> <blockquote><p>上文介绍了 coreMutex、fullMutex 两种锁，可能对理解并发造成一些干扰，此处补充一些说明。在 serialized 和 multi-thread 模式下，用户可以并发访问 SQLite API，但并不意味着可以读写成功，「支持并发访问 API」和「支持并发执行事务」完全是两回事。</p></blockquote> <p>接下来的重点叙述包括：理解 SQLite 事务，理解 SQLite 事务的实现原理。</p> <h3 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h3> <p>事务是 SQL 数据库里的通用概念，它描述的是一个或一组数据库操作指令的执行单元；具有四个属性：原子性、一致性、隔离性、持久性，即所谓 <a href="https://en.wikipedia.org/wiki/ACID" target="_blank" rel="noopener noreferrer">ACID<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，关于它的概念本文不过多赘述。</p> <p>默认情况下，SQLite 数据库的所有操作都是事务的，即所谓<strong>隐式事务</strong>（implicit transaction）。如下就是一个隐式事务：</p> <div class="language-c extra-class"><pre class="language-c"><code>sqlite3_stmt <span class="token operator">*</span>stmt <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token function">sqlite3_prepare</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">&quot;select * from table_name&quot;</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stmt<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">sqlite3_step</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span> <span class="token operator">==</span> SQLITE_ROW<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用 sqlite3_column 系列 API 提取数据</span>
<span class="token punctuation">}</span>
<span class="token function">sqlite3_finalize</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 或者使用 `sqlite3_reset(stmt);`</span>
</code></pre></div><p>用户还可以自行指定事务的开始与结束，即所谓<strong>显式事务</strong>（explicit transaction），语法详见 <a href="https://www.sqlite.org/lang_transaction.html" target="_blank" rel="noopener noreferrer">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，如下是一个小 demo：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">&quot;begin&quot;</span><span class="token punctuation">,</span> nil<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">&quot;insert into table_name (column_name) values (42)&quot;</span><span class="token punctuation">,</span> nil<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">&quot;end&quot;</span><span class="token punctuation">,</span> nil<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>无论显式事务还是隐式事务，根据是否会对数据库进行修改，可以分为：<strong>读事务</strong> 和 <strong>写事务</strong>。理清楚读事务和写事务这两个概念对于分析事务并发非常重要。</p> <p>drop、update、insert 等 SQL 语句，因为都涉及数据库变更，所以包含这些语句的事务都是写事务；如果事务中只有 select 语句，那么它属于读事务。</p> <p>对事务有一个基本的了解后，现在将注意力集中在问题中：SQLite 是如何实现事务的呢？</p> <p>这个问题涉及太多细节，难以用几段文字把它描述清楚；但如果想用好 SQLite，这个问题又不得不理清楚。我们先从 SQLite 的日志模型开始讨论。</p> <h3 id="两种日志模型"><a href="#两种日志模型" class="header-anchor">#</a> 两种日志模型</h3> <p>一个很重要的事实是，要想实现事务，单靠数据库文件是难以完成的，需要借助一个文件辅助完成，这个辅助文件被称为日志文件（journal）。</p> <p>SQLite 支持两种日志记录方式，或者说两种日志模型：<a href="https://www.sqlite.org/atomiccommit.html" target="_blank" rel="noopener noreferrer">Rollback<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 <a href="https://www.sqlite.org/wal.html" target="_blank" rel="noopener noreferrer">WAL<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>这两种模型，日志的文件格式不同，更重要的是日志在事务执行过程中扮演的角色不同；换句话说，选择了日志模型，相当于选择了一种事务处理模型。</p> <p>下面来分别简述这两种日志模型中的事务处理逻辑。</p> <h3 id="理解-rollback"><a href="#理解-rollback" class="header-anchor">#</a> 理解 Rollback</h3> <p>在 rollback 日志模型中，当执行写事务的时候，会在数据库文件（本文称为 .db）所在目录下产生一个日志文件（本文称为 .db-journal），下图简单描述了写事务执行过程中，.db-journal 所起到的作用：</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/sqlite_rollback.png" srcset="/image/sqlite_rollback.png 2x" data-v-339c7bd5></div> <p>如下补充一些文字说明：</p> <ul><li>1 初始状态，此时只有数据库文件</li> <li>2 执行写事务，SQLite 检测到要修改 page 1 和 page 3；创建 .db-journal 文件，将 page 1 和 page 3 的内容拷贝到其中，作为备份</li> <li>3 在数据库文件中直接修改</li> <li>4 Commit 或者 Rollback（只能二选一）
<ul><li>4.1 提交修改，删除 .db-journal 文件</li> <li>4.2 放弃修改，即回滚，使用 .db-journal 里的拷贝将数据库文件恢复到事务发生之前的模样</li></ul></li></ul> <p>SQLite 官方在 <a href="https://www.sqlite.org/atomiccommit.html" target="_blank" rel="noopener noreferrer">Atomic Commit In SQLite<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 花了相当多的笔墨介绍 rollback 日志模式下事务处理的逻辑细节。上图省掉了很多细节（锁管理、内存-磁盘交互等），将重点放在了描述日志文件本身上，可以看出：</p> <ul><li>写操作是直接在数据文件 .db 上进行的</li> <li>.db-journal 在写事务中起到了备份作用。备份要修改的 pages、.db 文件原大小，在写的过程中可以回退，即将备份信息给还原回去：恢复 pages 的原数据，或将 .db 文件切回之前的 size</li> <li>.db-journal 是一个临时文件。当写事务完成提交（commit）或回退（rollback）时，该文件会被清理掉（有多种清理方式）</li> <li>在任何时候一个数据库文件最多只对应一个 .db-journal 文件</li> <li>.db-journal 文件是否存在且有效是描述 .db 文件是否稳定完整的核心依据
<ul><li>创建 .db-journal 后，如果发生了断电或者程序崩溃退出等异常情况，下次重新访问数据库时，会首先根据 .db-journal 将数据库恢复到原来的样子，这保证了数据库的一致性（consistency）</li></ul></li></ul> <p>接下来谈谈 rollback 模式下的锁逻辑。SQLite 使用文件锁来保证事务之间的隔离性（isolation）和原子性（atomicity）。</p> <p>所谓文件锁，并不是一个计算机原语，也即没有所谓的 API 来直接控制它；它是 SQLite 抽象的一个概念，具体的实现和宿主有关，其实现细节并非本文讨论重点；需要注意的是它的 feature：</p> <ul><li>和数据库文件关联。这意味它不仅可以实现线程阻塞，也可以实现进程阻塞</li> <li>有五种状态。UNLOCKED、SHARED、RESERVED、PENDING、EXCLUSIVE
<ul><li>关于这五种状态的叙述参考 <a href="https://www.sqlite.org/lockingv3.html" target="_blank" rel="noopener noreferrer">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></li></ul> <blockquote><p>SQLite 文件里专门有一段数据区域与锁有关，详见 <a href="https://sqlite.org/fileformat2.html" target="_blank" rel="noopener noreferrer">Database File Format<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的「The Lock-Byte Page」；文件锁的具体实现与宿主有关，对于 Unix 而言，详见 <a href="https://github.com/mackyle/sqlite/blob/master/src/os_unix.c" target="_blank" rel="noopener noreferrer">src/os_unix.c<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 里 unixLock() 函数。根据官方文档的说法，文件锁相关数据不会回写到磁盘，所以不用担心某个进程持有该锁后，因为异常无法释放导致永久死锁。</p></blockquote> <p>针对文件锁五种状态的转换，<a href="https://activesphere.com/blog/2018/12/24/understanding-sqlite-busy" target="_blank" rel="noopener noreferrer">Understanding SQLITE_BUSY<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 画了一张非常棒的图，copy 如下：</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/sqlite_file_lock.png" srcset="/image/sqlite_file_lock.png 2x" data-v-339c7bd5></div> <ul><li>.db 文件锁的初始状态是 unlocked</li> <li>任何连接想要开启读操作，需要获取 shared 锁
<ul><li>可以有多个连接获取 shared 锁</li></ul></li> <li>任何连接想要开启写操作，需要获取 reserved 锁
<ul><li>只能有一个连接获取 reserved 锁</li> <li>获取到 reserved，transaction 可以写数据，但只是写在用户空间</li></ul></li> <li>将修改的数据同步到数据库文件中（提交事务），需要获取 exclusive 锁
<ul><li>如果此时有连接在读数据，锁会变成 pending 状态，其他连接都退出读状态后，才进入 exclusive 状态</li> <li>当文件锁处于 pending 状态，或者 exclusive 状态，表示磁盘中的 .db 文件即将或正在发生变化，此时是不可读的</li></ul></li></ul> <p>下面从代码层面进一步理解一下：</p> <div class="language-c extra-class"><pre class="language-c"><code>sqlite3 <span class="token operator">*</span>db <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token function">sqlite3_open</span><span class="token punctuation">(</span><span class="token string">&quot;path/to/db&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 开始事务</span>
<span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">&quot;begin&quot;</span><span class="token punctuation">,</span> nil<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取 shared 锁</span>
<span class="token comment">// 如果文件锁处于 pending 或 exclusive 状态，则失败，返回：SQLITE_BUSY 错误码</span>
<span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">&quot;select * from table_name&quot;</span><span class="token punctuation">,</span> nil<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取 reserved 锁</span>
<span class="token comment">// 仅当文件锁处于 shared 或 unlocked 状态，才能成功；否则失败，返回：SQLITE_BUSY 错误码</span>
<span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">&quot;drop table table_name&quot;</span><span class="token punctuation">,</span> nil<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取 pending 锁，等待升级为 exclusive 锁</span>
<span class="token comment">// 仅当 shared 锁全部被释放，才能成功执行，否则失败返回：SQLITE_BUSY 错误码</span>
<span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">&quot;commit&quot;</span><span class="token punctuation">,</span> nil<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>有些类似于 <a href="https://en.wikipedia.org/wiki/Two-phase_locking" target="_blank" rel="noopener noreferrer">2PL<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 并发控制机制；但 SQLite 做得更复杂一些，以规避 dead lock。</p></blockquote> <p>此处可以对 rollback 日志模式稍作总结：</p> <ul><li>每次写事务都有两个写 IO 的操作（一次是创建 .db-journal，一次修改数据库）</li> <li>可以同时执行多个读事务</li> <li>不能同时执行多个写事务</li> <li>读事务会影响写事务，如果读事务较多，写事务在提交阶段（获取 exclusive 锁）常会遇到 SQLITE_BUSY 错误</li> <li>写事务会影响读事务，在写事务的提交阶段，读事务是无法进行的</li> <li>写事务遇到 SQLITE_BUSY 错误的节点较多</li></ul> <h4 id="使用-rollback-模式"><a href="#使用-rollback-模式" class="header-anchor">#</a> 使用 Rollback 模式</h4> <p>激活 rollback 日志模式可以在连接数据库后使用 <code>pragma journal_mode</code> 开启：</p> <div class="language-c extra-class"><pre class="language-c"><code>sqlite3 <span class="token operator">*</span>db <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token function">sqlite3_open</span><span class="token punctuation">(</span><span class="token string">&quot;path/to/db&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">&quot;pragma journal_mode=delete&quot;</span><span class="token punctuation">,</span> nil<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>其中 rollback 模式下 journal_mode 的可选值包括如下值，它们用于指定 .db-journal 的清理方式：</p> <ul><li><strong>delete</strong>: 清理 .db-journal 的方式是直接删除</li> <li><strong>truncate</strong>: 清理 .db-journal  的方式是清空文件内容（不删除，保留文件留作下次使用）</li> <li><strong>persist</strong>: 保留 .db-journal 文件，但会对文件的 header 做一些处理，以便 SQLite 能识别该文件是否有效</li> <li><strong>memory</strong>: .db-journal 文件不写磁盘，而是放在内存中；这种模式下，如果程序崩溃、断电，数据库可能就 gg 了</li></ul> <p>SQLite 默认的日志模式是 rollback，清理模式为 delete。</p> <h3 id="理解-wal"><a href="#理解-wal" class="header-anchor">#</a> 理解 WAL</h3> <p>WAL 的全称是 Write-Ahead Logging。</p> <p>在 rollback 日志模式中，写操作是直接发生在数据库文件上的，日志充当备份用，主要用于确保数据库的一致性；正常完成写事务后，它就被销毁了。</p> <p>wal 日志模式中，提供了另一种日志类型，常称为 wal 文件，记为 .db-wal，在这个模型中，写操作都发生在 wal 文件中；另一个不同点是，.db-wal 文件是持久存储的，它是数据库完整的重要组成部分。</p> <p>SQLite 官方对 rollback 日志模式有着非常详细的图文并茂的 <a href="https://www.sqlite.org/atomiccommit.html" target="_blank" rel="noopener noreferrer">介绍<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，但 wal 日志模式的待遇没那么好，<a href="https://www.sqlite.org/wal.html" target="_blank" rel="noopener noreferrer">介绍信息<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 相对来说没那么生动，于是动手根据自己的理解分别针对写操作和读操作画了两张图。</p> <p>先看看写事务：</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/sqlite_wal_1.png" srcset="/image/sqlite_wal_1.png 2x" data-v-339c7bd5></div> <p>从上图可以看出，数据库的全局数据可能分布在两个地方：.db 和 .db-wal 中，那么读操作是怎样读数据的呢？详见下图：</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/sqlite_wal_2.png" srcset="/image/sqlite_wal_2.png 2x" data-v-339c7bd5></div> <p>对 WAL 模式稍作一些总结：</p> <ul><li>wal 模式比 rollback 模式有更高的并发性：读写互相不影响</li> <li>wal 模式比 rollback 模式降低了损坏率（写数据库操作频率极大降低）</li> <li>使用好 wal 模式的关键点在于设计良好的 checkpoint 策略
<ul><li>wal 文件记录了更改的全量，会膨胀得非常快</li> <li>checkpoint 频率过低，导致 wal 文件过大，消耗磁盘空间，且影响 read 的效率</li> <li>checkpoint 频率过高，增大数据库的损坏率</li></ul></li></ul> <h4 id="使用-wal-模式"><a href="#使用-wal-模式" class="header-anchor">#</a> 使用 WAL 模式</h4> <p>激活 wal 模式可以在连接数据库后使用 pragma 开启：</p> <div class="language-c extra-class"><pre class="language-c"><code>sqlite3 <span class="token operator">*</span>db <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token function">sqlite3_open</span><span class="token punctuation">(</span><span class="token string">&quot;path/to/db&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">&quot;pragma journal_mode=wal&quot;</span><span class="token punctuation">,</span> nil<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// `pragma journal_mode=wal` 语句会有一个返回值，返回当前 journal mode</span>
<span class="token comment">// 如果不为 wal，表示失败</span>
</code></pre></div><h3 id="三种事务类型"><a href="#三种事务类型" class="header-anchor">#</a> 三种事务类型</h3> <p>再回过头来补充一些事务类型相关内容，使用 SQLite 时可能常会和它们打交道。开启显式事务时，可以指定三种类型：</p> <ul><li><code>begin deferred ... end</code></li> <li><code>begin immediate ... end</code></li> <li><code>begin exclusive ... end</code></li></ul> <p>默认情况下，SQLite 选用 deferred 类型。该类型下，调用 <code>begin deferred</code> 并不会立马开始一个 transaction，而是延迟到第一次访问数据库时，如果事务的所有指令都是读操作，那么这一个事务被认为是读事务；只要其中包括写事务，那么它就升级为写事务。如下 demo：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">&quot;begin deferred&quot;</span><span class="token punctuation">,</span> nil<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 这是一个读事务，获取 shared 锁</span>
<span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">&quot;select * from table_name&quot;</span><span class="token punctuation">,</span> nil<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 升级为写事务，获取 reserved 锁</span>
<span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">&quot;drop table table_name&quot;</span><span class="token punctuation">,</span> nil<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">&quot;commit&quot;</span><span class="token punctuation">,</span> nil<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Immediate 类型也被较多使用，它相当于直接告诉 SQLite 开始写事务了，即便包含的 SQL 语句全部是读操作，甚至不执行任何 SQL 语句；它会尝试获取 reserved 锁，因为 reserved 锁有唯一约束，所以在执行 <code>begin immediate</code> 时可能会产生 SQLITE_BUSY 错误。</p> <p>对于 exclusive 类型事务，两种日志模式下的表现不一样。在 wal 模式下，它和 immediate 类型一样。在 rollback 日志模式下，它会尝试获取 exclusive 锁，要求独占数据库，这意味着它成功的前提是：当前数据库是完全闲置的，没有其他的读事务或写事务在进行；换句话说，执行 <code>begin exclusive</code> 比 <code>begin immediate</code>  产生 SQLITE_BUSY 错误的概率更大。</p> <p>搞清楚这三种事务以及互相的影响，有利于理解 SQLite 的事务处理逻辑，以及各种锁在哪个阶段发挥作用，限于篇幅，本文不展开赘述，直接抛结果。</p> <p>下表中，将事务分为 4 类：deferred read、deferred write、immediate、exclusive；为叙述方便，将每个事务的执行分为：三个阶段：begin -&gt; execute -&gt; commit。表中描述某个事务执行过程中对其他事务的影响。</p> <p>第一列纵坐标表示正在执行（尚未 commit）的事务类型，横坐标描述该事务对其他类型事务的影响。</p> <p>Rollback 日志模式下，事务之间的影响如下表：</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/sqlite_rollback_transaction_impact.png" srcset="/image/sqlite_rollback_transaction_impact.png 2x" data-v-339c7bd5></div> <p>值得注意的是：</p> <ul><li>对于 immediate 事务
<ul><li><code>begin immediate</code> 会尝试获取 reserved 锁</li> <li><code>commit</code> 会尝试获取 exclusive，哪怕 immediate 事务啥都没做（空事务）</li></ul></li> <li>对于 exclusive 事务
<ul><li><code>begin immediate</code> 会尝试获取 exclusive 锁</li></ul></li></ul> <p>WAL 日志模式下，事务之间的影响如下图：</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/sqlite_wal_transaction_impact.png" srcset="/image/sqlite_wal_transaction_impact.png 2x" data-v-339c7bd5></div> <p>注意：exclusive 类型在 wal 模式下不起作用，和 immediate 效果一样。</p> <p>「无影响」 表格即代表着所支持的并发情况，显然，wal 日志模式下的并发支持要比 rollback 模式下支持得好得多。</p> <blockquote><p>上述两个表格的 cases 可以从：<a href="https://github.com/sadjason/SBDB/blob/master/SBDBTests/Cases/TransactionModeRollbackTests.swift" target="_blank" rel="noopener noreferrer">Rollback 日志模式下事务之间的影响<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 <a href="https://github.com/sadjason/SBDB/blob/master/SBDBTests/Cases/TransactionModeWalTests.swift" target="_blank" rel="noopener noreferrer">WAL 日志模式下事务之间的影响<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 验证得到。</p></blockquote> <h3 id="busy-错误与处理"><a href="#busy-错误与处理" class="header-anchor">#</a> Busy 错误与处理</h3> <p>上文频繁出现 SQLITE_BUSY，它是 SQLite 内部用来描述并发错误的错误码，详见 <a href="https://www.sqlite.org/rescode.html#busy" target="_blank" rel="noopener noreferrer">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；从上文对事务逻辑的分析可以看出，SQLite 事务执行的过程中，可能出现 SQLITE_BUSY 错误的节点非常多，在 rollback 日志模式下尤其如此。</p> <p>对于任何一个 SQLite 库，处理 busy 错误是必不可少的。</p> <p>对于 SQLite 本身而言，它提供了简单的 busy retry 方案，即设置超时时间，设超时后，SQLite 在遇到 SQLITE_BUSY 错误后，会在内部做一些重试尝试。有多种设置超时时间的方式：</p> <ul><li><a href="https://www.sqlite.org/c3ref/busy_timeout.html" target="_blank" rel="noopener noreferrer">sqlite3_busy_timeout()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>: 设置 busy retry 的休眠时间</li> <li><a href="https://www.sqlite.org/pragma.html#pragma_busy_timeout" target="_blank" rel="noopener noreferrer">PRAGMA busy_timeout<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>: 设置 busy retry 的休眠时间</li> <li><a href="https://www.sqlite.org/c3ref/busy_handler.html" target="_blank" rel="noopener noreferrer">sqlite3_busy_handler()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>: 注册 busy handler；通常在 busy handler 里做一些休眠然后再返回</li></ul> <p>基于 SQLite 提供的 busy retry 方案，在 retry 过程中，休眠时间的长短和重试次数，是决定性能和操作成功率的关键。Retry 超时时间的设置因不同操作不同场景而不同。若休眠时间太短或重试次数太多，会空耗CPU的资源；若休眠时间过长，会造成等待的时间太长；若重试次数太少，则会降低操作的成功率。</p> <p>即便有了 busy retry 方案，SQLITE_BUSY 错误还可能还是会出现，使用过程中不应该忽视该问题的存在，在知名的 SQLite 库的里都能看到大量的 APIs 返回布尔值：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/** FMDB 库的一些 APIs **/</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>executeUpdate<span class="token operator">:</span><span class="token punctuation">(</span>NSString<span class="token operator">*</span><span class="token punctuation">)</span>sql<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>

<span class="token comment">/** WCDB 库的一些 APIs **/</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>insertObject<span class="token operator">:</span><span class="token punctuation">(</span>WCTObject <span class="token operator">*</span><span class="token punctuation">)</span>object into<span class="token operator">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>tableName<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>beginTransaction<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>commitTransaction<span class="token punctuation">;</span>
</code></pre></div><p>像 beginTransaction、commitTransaction 这种 API 返回 false 的原因基本上就是 SQLITE_BUSY 错误导致的。</p> <p>从框架的角度来看，似乎很难在内部规避掉 SQLITE_BUSY 错误，因为很难去约束用户的使用姿势、譬如日志模型、线程管理等。</p> <p>对于 iOS 生态，因为每个应用都是独立进程，无需担心多进程引起的并发问题，问题相对简单了一些。如果遵循如下姿势使用 SQLite 数据库，应该能基本上规避 busy 问题：</p> <ul><li>日志模式使用 wal 模式</li> <li>用串行队列管理写操作</li></ul> <blockquote><p>这是根据先验知识所总结的，不具备权威性，实际上是否还会存在一些其他边界没考虑到，得经过充分的实践才能知道。</p></blockquote> <h3 id="一些第三方库"><a href="#一些第三方库" class="header-anchor">#</a> 一些第三方库</h3> <p>这一部分简单介绍 iOS 平台中一些知名第三方 SQLite 库。</p> <h4 id="fmdb"><a href="#fmdb" class="header-anchor">#</a> FMDB</h4> <p><a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener noreferrer">FMDB<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 可能是 Objective-C 社区使用最多的 SQLite 第三方库，它对 sqlite3 C API 比较薄地包了一层，非常轻量级，没有任何限制，有三个主要类：</p> <ul><li><strong>FMDatabase</strong>: 对 API 的直接封装，每个对象对应一个连接句柄，没有做线程管理、日志模型约束等</li> <li><strong>FMDatabaseQueue</strong>: 对 FMDatabase 进行封装，每个 FMDatabaseQueue 对象对应一个 FMDatabase 实例；约束所有数据库操作都在一个串行队列上进行，避免并发</li> <li><strong>FMDatabasePool</strong>: 管理多个 FMDatabase，即维护一个连接池，支持并发；但仍然没有约束用户选择日志模型</li></ul> <p>使用 FMDatabaseQueue 比较安全，但效率显然较低，如果是时间敏感型业务，用它可能有些捉急。</p> <p>但如果使用 FMDatabasePool，作者在 FMDatabasePool.h 里留下的 comment 可能让用户有些紧张：</p> <div class="custom-image-wrapper" data-v-339c7bd5><img src="/image/fmdatabase_warn.png" srcset="/image/fmdatabase_warn.png 2x" data-v-339c7bd5></div> <p>这段 comment 恐吓如果使用不当可能会导致死锁；然而，作者给的死锁 case 不太靠谱，经测试没用，作者似乎也认识到了，详见 <a href="https://github.com/ccgus/fmdb/issues/598" target="_blank" rel="noopener noreferrer">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；个人感觉，FMDatabasePool 还是值得一用的。</p> <p>总之，FMDB 是一个没有态度的 SQLite 三方库，没有约束日志模型、checkpoint 策略等，只是提供了最简单直接的使用姿势。</p> <p>没有提供 ORM 功能，除了易用性上有些捉急之外，我认为 FMDB 还有一个不足点：缺乏日志收集、性能监控相关 API；对于深度使用 SQLite 的功能，这是一个非常大的不足。</p> <h4 id="wcdb"><a href="#wcdb" class="header-anchor">#</a> WCDB</h4> <p>WCDB 是微信团队出品的，经得起检验。相对于 FMDB，WCDB 要重得多。对于 iOS，如果使用 WCDB，意味着要引入两个库：WCDBOptimizedSQLCipher 和 WCDB。</p> <p><a href="https://github.com/Tencent/sqlcipher/tree/wcdb" target="_blank" rel="noopener noreferrer">WCDBOptimizedSQLCipher<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 是从 <a href="https://github.com/sqlcipher/sqlcipher" target="_blank" rel="noopener noreferrer">SQLCipher<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> fork 的一个库，后者提供了加密功能，微信团队在此基础上做了大量的性能优化。WCDB 提供的 <a href="https://github.com/Tencent/wcdb/wiki/WCDB-iOS-benchmark" target="_blank" rel="noopener noreferrer">性能报告<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，在多方面都吊打 FMDB，就是因为 WCDBOptimizedSQLCipher 从 SQLite 源码层面做了一些优化工作，详见 <a href="https://cloud.tencent.com/developer/article/1005554" target="_blank" rel="noopener noreferrer">微信 iOS SQLite 源码优化实践<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>WCDB 库本身而言，最大的特色是提供了 ORM 等易用性方面的功能，使用体验挺不错。支持 ORM 对于很多高级语言（譬如 Swift）而言，是一件挺简单的事情；但对于 Objective-C 而言挺为难，语言 feature 太少了，譬如不支持符号重载，这在支持 ORM 中可能用得较多。</p> <blockquote><p>微信读书团队基于 FMDB 做了一个 ORM 库：<a href="https://github.com/Zepo/GYDataCenter" target="_blank" rel="noopener noreferrer">GYDataCenter<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，但看起来不太好用。</p></blockquote> <p>WCDB 主要代码都是 C++，基于 C++ 的 feature 实现的 ORM 使用起来要好用得多。此外，WCDB 还针对数据库损坏，提供了修复功能。</p> <p>WCDB 默认使用 wal 日志模型，和 FMDatabasePool 类似，在内部维护了一个连接池，提供了良好的并发性。</p> <p>总之，WCDB 是一个非常牛 x 的库，如果开发比较重的、强依赖 SQLite 的业务，它可能是一个不错的选择。</p> <h4 id="sqlite-swift"><a href="#sqlite-swift" class="header-anchor">#</a> SQLite.swift</h4> <p><a href="https://github.com/stephencelis/SQLite.swift" target="_blank" rel="noopener noreferrer">SQLite.swift<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 是 Swift 生态中，stars 最多的第三方库。但个人观感，虽然 stars 多，但质量一般，在学习分析过程中，发现了好几处 bug；更新频次低；issues 较多但大多没有响应，给人感觉这个库没人维护了。</p> <h4 id="grdb"><a href="#grdb" class="header-anchor">#</a> GRDB</h4> <p><a href="https://github.com/groue/GRDB.swift" target="_blank" rel="noopener noreferrer">GRDB<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 是另一个 Swift 生态中的 SQLite 三方库；维护良好，感觉比 <a href="https://github.com/stephencelis/SQLite.swift" target="_blank" rel="noopener noreferrer">SQLite.swift<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 要好很多。但 stars 比后者少得多（2.5k v.s 6.5k），大概是因为取名没有后者好，出现时机没有后者早吧。</p> <h2 id="更多参考"><a href="#更多参考" class="header-anchor">#</a> 更多参考</h2> <ul><li><a href="https://sqlite.org/doclist.html" target="_blank" rel="noopener noreferrer">SQLite 官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <ul><li>SQLite 官方资料质量很高，作为入门资料足以</li></ul></li> <li><a href="https://cloud.tencent.com/developer/user/598196" target="_blank" rel="noopener noreferrer">微信终端开发团队系列 SQLite 相关博客<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://activesphere.com/blog/2018/12/24/understanding-sqlite-busy" target="_blank" rel="noopener noreferrer">Understanding SQLITE_BUSY<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.50bca889.js" defer></script><script src="/assets/js/5.081d1701.js" defer></script><script src="/assets/js/101.28f11de0.js" defer></script><script src="/assets/js/4.a7413ce2.js" defer></script>
  </body>
</html>
