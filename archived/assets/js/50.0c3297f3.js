(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{148:function(a,r,t){"use strict";t.r(r);var e=t(0),s=Object(e.a)({},(function(){var a=this,r=a.$createElement,t=a._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#深入-ios：各种实现原理"}},[a._v("深入 iOS：各种实现原理")]),t("ul",[t("li",[t("a",{attrs:{href:"#weak-的实现原理"}},[a._v("weak 的实现原理")])]),t("li",[t("a",{attrs:{href:"#kvo-的实现原理"}},[a._v("KVO 的实现原理")])]),t("li",[t("a",{attrs:{href:"#动画的实现原理"}},[a._v("动画的实现原理")])]),t("li",[t("a",{attrs:{href:"#autorelease-pool-的实现原理"}},[a._v("Autorelease Pool 的实现原理")])]),t("li",[t("a",{attrs:{href:"#atomic-的实现原理"}},[a._v("atomic 的实现原理")])]),t("li",[t("a",{attrs:{href:"#synchronized-self-的实现原理"}},[a._v("@synchronized(self) 的实现原理")])])])]),t("li",[t("a",{attrs:{href:"#framework"}},[a._v("Framework")])]),t("li",[t("a",{attrs:{href:"#crash"}},[a._v("Crash")]),t("ul",[t("li",[t("a",{attrs:{href:"#基本-crash-知识"}},[a._v("基本 Crash 知识")])]),t("li",[t("a",{attrs:{href:"#分析-crash-有哪些途径"}},[a._v("分析 Crash 有哪些途径")])]),t("li",[t("a",{attrs:{href:"#碰上了什么疑难-crash"}},[a._v("碰上了什么疑难 Crash")])]),t("li",[t("a",{attrs:{href:"#如何捕捉-crash-栈信息"}},[a._v("如何捕捉 Crash 栈信息")])]),t("li",[t("a",{attrs:{href:"#dsym-符号表"}},[a._v("dSYM (符号表)")])])])]),t("li",[t("a",{attrs:{href:"#性能监控"}},[a._v("性能监控")]),t("ul",[t("li",[t("a",{attrs:{href:"#卡顿和帧率"}},[a._v("卡顿和帧率")])]),t("li",[t("a",{attrs:{href:"#卡顿检测的原理"}},[a._v("卡顿检测的原理")])]),t("li",[t("a",{attrs:{href:"#监控-fps"}},[a._v("监控 FPS")])]),t("li",[t("a",{attrs:{href:"#离屏渲染"}},[a._v("离屏渲染")])]),t("li",[t("a",{attrs:{href:"#影响帧率的常见因素"}},[a._v("影响帧率的常见因素")])]),t("li",[t("a",{attrs:{href:"#提高帧率的手段"}},[a._v("提高帧率的手段")])]),t("li",[t("a",{attrs:{href:"#性能调优相关工具"}},[a._v("性能调优相关工具")])])])]),t("li",[t("a",{attrs:{href:"#各种对比"}},[a._v("各种对比")]),t("ul",[t("li",[t("a",{attrs:{href:"#进程和线程的区别"}},[a._v("进程和线程的区别")])])])])])]),t("p"),a._v(" "),t("h1",{attrs:{id:"深入-ios：各种实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深入-ios：各种实现原理"}},[a._v("#")]),a._v(" 深入 iOS：各种实现原理")]),a._v(" "),t("p",[a._v("个人认为：讲各种实现原理就是脑残...")]),a._v(" "),t("h2",{attrs:{id:"weak-的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#weak-的实现原理"}},[a._v("#")]),a._v(" weak 的实现原理")]),a._v(" "),t("p",[a._v("参考："),t("a",{attrs:{href:"https://www.jianshu.com/p/13c4fb1cedea",target:"_blank",rel:"noopener noreferrer"}},[a._v("iOS 底层解析weak的实现原理"),t("OutboundLink")],1)]),a._v(" "),t("p",[a._v("Runtime维护了一个 weak 表，用于存储指向某个对象的所有 weak 指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象指针的地址）数组。")]),a._v(" "),t("h2",{attrs:{id:"kvo-的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kvo-的实现原理"}},[a._v("#")]),a._v(" KVO 的实现原理")]),a._v(" "),t("ul",[t("li",[a._v("当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。派生类在被重写的 setter 方法内实现真正的通知机制。")]),a._v(" "),t("li",[a._v("如果原类为 Person，那么生成的派生类名为 NSKVONotifying_Person，每个类对象中都有一个"),t("code",[a._v("isa")]),a._v("指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将"),t("code",[a._v("isa")]),a._v("指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法。")]),a._v(" "),t("li",[a._v("键值观察通知依赖于 NSObject 的两个方法: "),t("code",[a._v("willChangeValueForKey:")]),a._v("和"),t("code",[a._v("didChangevlueForKey:")]),a._v("；在一个被观察属性发生改变之前，"),t("code",[a._v("willChangeValueForKey:")]),a._v("一定会被调用，这就会记录旧的值。而当改变发生后，"),t("code",[a._v("didChangeValueForKey:")]),a._v("会被调用，继而"),t("code",[a._v("observeValueForKey:ofObject:change:context:")]),a._v("也会被调用。")]),a._v(" "),t("li",[a._v("KVO 的这套实现机制中苹果还偷偷重写了class方法，让我们误认为还是使用的当前类，从而达到隐藏生成的派生类")])]),a._v(" "),t("h2",{attrs:{id:"动画的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动画的实现原理"}},[a._v("#")]),a._v(" 动画的实现原理")]),a._v(" "),t("p",[a._v("所谓动画，其实是各个 UI 属性值在时间轴上的变化。巴拉巴拉随便扯...")]),a._v(" "),t("h2",{attrs:{id:"autorelease-pool-的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#autorelease-pool-的实现原理"}},[a._v("#")]),a._v(" Autorelease Pool 的实现原理")]),a._v(" "),t("p",[a._v("随便吹...")]),a._v(" "),t("h2",{attrs:{id:"atomic-的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#atomic-的实现原理"}},[a._v("#")]),a._v(" atomic 的实现原理")]),a._v(" "),t("p",[a._v("随便吹...")]),a._v(" "),t("h2",{attrs:{id:"synchronized-self-的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-self-的实现原理"}},[a._v("#")]),a._v(" @synchronized(self) 的实现原理")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("@synchronized")]),a._v("结构在工作时为传入的对象分配了一个递归锁")]),a._v(" "),t("li",[t("code",[a._v("@synchronized")]),a._v("并不会持有对象，它只是基于对象的地址创建一个 SyncData")]),a._v(" "),t("li",[a._v("传"),t("code",[a._v("nil")]),a._v("是无法起到加锁作用的")])]),a._v(" "),t("div",{staticClass:"language-objectivec extra-class"},[t("pre",{pre:!0,attrs:{class:"language-objectivec"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("@try")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("objc_sync_enter")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// do work")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("@finally")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("objc_sync_exit")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("    \n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("h1",{attrs:{id:"framework"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#framework"}},[a._v("#")]),a._v(" Framework")]),a._v(" "),t("p",[a._v("参考"),t("a",{attrs:{href:"https://juejin.im/entry/57b957d80a2b58005c954808",target:"_blank",rel:"noopener noreferrer"}},[a._v("iOS 静态库，动态库与 Framework"),t("OutboundLink")],1),a._v("。")]),a._v(" "),t("p",[a._v("Framework 实际上是一种打包方式，将库的二进制文件，头文件和有关的资源文件打包到一起，方便管理和分发。")]),a._v(" "),t("p",[a._v("在 iOS 8 之前，iOS 平台不支持使用动态 Framework，开发者可以使用的 Framework 只有苹果自家的 UIKit.Framework，Foundation.Framework 等。开发者想要在 iOS 平台共享代码，唯一的选择就是打包成静态库 .a 文件，同时附上头文件。但是这样的打包方式不够方便，使用时也比较麻烦，大家还是希望共享代码都能能像 Framework 一样，直接扔到工程里就可以用。")]),a._v(" "),t("p",[a._v("iOS 8/Xcode 6 推出之后，iOS 平台添加了动态库的支持，同时 Xcode 6 也原生自带了 Framework 支持（动态和静态都可以）。为什么 iOS 8 要添加动态库的支持？唯一的理由大概就是 Extension 的出现。")]),a._v(" "),t("p",[a._v("但是这种动态 Framework 和系统的 UIKit.Framework 还是有很大区别。系统的 Framework 不需要拷贝到目标程序中，我们自己做出来的 Framework 哪怕是动态的，最后也还是要拷贝到 App 中（App 和 Extension 的 Bundle 是共享的），因此苹果又把这种 Framework 称为 Embedded Framework。")]),a._v(" "),t("h1",{attrs:{id:"crash"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#crash"}},[a._v("#")]),a._v(" Crash")]),a._v(" "),t("h2",{attrs:{id:"基本-crash-知识"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本-crash-知识"}},[a._v("#")]),a._v(" 基本 Crash 知识")]),a._v(" "),t("ul",[t("li",[a._v("BAD_ACCESS\n"),t("ul",[t("li",[a._v("访问了野指针，比如访问已经释放的对象的成员变量或者发消息、死循环等。")]),a._v(" "),t("li",[a._v("Unrecognized Selector")])])])]),a._v(" "),t("h2",{attrs:{id:"分析-crash-有哪些途径"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分析-crash-有哪些途径"}},[a._v("#")]),a._v(" 分析 Crash 有哪些途径")]),a._v(" "),t("ul",[t("li",[a._v("比较简单的，从调用栈就可以看出来")])]),a._v(" "),t("h2",{attrs:{id:"碰上了什么疑难-crash"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#碰上了什么疑难-crash"}},[a._v("#")]),a._v(" 碰上了什么疑难 Crash")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://km.sankuai.com/page/121923108",target:"_blank",rel:"noopener noreferrer"}},[a._v("9.10.800 上线后出现大面积崩溃"),t("OutboundLink")],1),a._v(" "),t("a",{attrs:{href:"https://km.sankuai.com/page/33220971",target:"_blank",rel:"noopener noreferrer"}},[a._v("记一次 Emoji 引发的Crash"),t("OutboundLink")],1)]),a._v(" "),t("p",[a._v("这个 case 的难点在于难以找到复现路径。")]),a._v(" "),t("h2",{attrs:{id:"如何捕捉-crash-栈信息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何捕捉-crash-栈信息"}},[a._v("#")]),a._v(" 如何捕捉 Crash 栈信息")]),a._v(" "),t("p",[a._v("详见"),t("a",{attrs:{href:"https://www.jianshu.com/p/8123fc17fe0e",target:"_blank",rel:"noopener noreferrer"}},[a._v("移动端监控体系之技术原理剖析"),t("OutboundLink")],1),a._v("。")]),a._v(" "),t("p",[a._v("主要包括两方面：Unix 信号捕获、NSException 捕获。")]),a._v(" "),t("p",[a._v("对于 Unix 信号捕获。进程退出的时候会有各种各样的退出状态，开发者可以向这些状态注册 handler，可以在 handler 里完成栈信息捕获。")]),a._v(" "),t("p",[a._v("对于 NSException 捕获，可以设置 NSSetUncaughtExceptionHandler。")]),a._v(" "),t("h2",{attrs:{id:"dsym-符号表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dsym-符号表"}},[a._v("#")]),a._v(" dSYM (符号表)")]),a._v(" "),t("p",[a._v("用于将 crash 栈信息给符号化。")]),a._v(" "),t("p",[a._v("参考"),t("a",{attrs:{href:"https://juejin.im/entry/59dc90d16fb9a04508089cd6",target:"_blank",rel:"noopener noreferrer"}},[a._v("iOS开发符号表(dSYM)知识总结"),t("OutboundLink")],1),a._v("。")]),a._v(" "),t("p",[a._v("iOS 构建时产生的符号表，它是内存地址与函数名，文件名，行号的映射表。 符号表元素如下所示：")]),a._v(" "),t("div",{staticClass:"language-raw extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("<起始地址> <结束地址> <函数> [<文件名:行号>]\n")])])]),t("p",[a._v("而 iOS 应用 crash 时也有堆栈，release 版的应用，crash 时的堆栈信息，全是二进制的地址信息；而 debug 版本的应用，crash 时的堆栈信息有时能看到函数名字，但是也看不到对应的源代码文件的行号，这样也没法定位问题。")]),a._v(" "),t("p",[a._v("将产品提供给项目成员体验时，不管是 debug 版本还是 release 版本都需要符号表来帮我们将crash的堆栈信息还原成源代码文件对应的信息，以便快速定位问题")]),a._v(" "),t("h1",{attrs:{id:"性能监控"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#性能监控"}},[a._v("#")]),a._v(" 性能监控")]),a._v(" "),t("h2",{attrs:{id:"卡顿和帧率"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#卡顿和帧率"}},[a._v("#")]),a._v(" 卡顿和帧率")]),a._v(" "),t("p",[a._v("参考"),t("a",{attrs:{href:"https://www.jianshu.com/p/a87c5d77fe13",target:"_blank",rel:"noopener noreferrer"}},[a._v("卡顿与帧率的关系"),t("OutboundLink")],1),a._v("：")]),a._v(" "),t("ul",[t("li",[a._v("帧率稳定，但过低时：持续低于 12 fps 时，动画无法连贯（类似幻灯片，体验极差），持续低于 30 fps 时，动画连贯性受到影响\n"),t("ul",[t("li",[a._v("动画有些闪烁，相比 60 fps，体验较差")])])]),a._v(" "),t("li",[a._v("帧率不稳定时：比如一会 60 fps，一会 20 fps。动画运动速率不一致吗，被人眼识别出后，产生的卡顿感\n"),t("ul",[t("li",[a._v("流畅中偶尔卡顿，体验略差")])])])]),a._v(" "),t("h2",{attrs:{id:"卡顿检测的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#卡顿检测的原理"}},[a._v("#")]),a._v(" 卡顿检测的原理")]),a._v(" "),t("p",[a._v("基于 Runloop，监控哪两个时间节点？")]),a._v(" "),t("p",[a._v("监控如下这三种 Activity，如果超过一定阈值，则上报卡顿")]),a._v(" "),t("ul",[t("li",[a._v("kCFRunLoopBeforeSources")]),a._v(" "),t("li",[a._v("kCFRunLoopBeforeWaiting（貌似只有美团监控了这个）")]),a._v(" "),t("li",[a._v("kCFRunLoopAfterWaiting")])]),a._v(" "),t("p",[a._v("阈值一般是 16 或 20 微秒。为什么监控这两个？它们可能和渲染时机有关系")]),a._v(" "),t("h2",{attrs:{id:"监控-fps"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#监控-fps"}},[a._v("#")]),a._v(" 监控 FPS")]),a._v(" "),t("p",[a._v("通过"),t("code",[a._v("CADisplayLink")]),a._v("即可，因为"),t("code",[a._v("CADisplayLink")]),a._v("的调用频次和刷新帧率有关。把它添加到 NSRunLoop 的 commonModes 中。")]),a._v(" "),t("h2",{attrs:{id:"离屏渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#离屏渲染"}},[a._v("#")]),a._v(" 离屏渲染")]),a._v(" "),t("p",[a._v("基本概念：")]),a._v(" "),t("ul",[t("li",[a._v("屏幕渲染：指的是 GPU 的渲染操作是在当前用于显示的屏幕缓冲区进行")]),a._v(" "),t("li",[a._v("离屏渲染：指的是 GPU 在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作")])]),a._v(" "),t("p",[a._v("当前屏幕渲染不需要额外创建新的缓存，也不需要开启新的上下文，相对于离屏渲染性能更好。但是受当前屏幕渲染的局限因素限制（只有自身上下文、屏幕缓存有限等)，当前屏幕渲染有些情况下的渲染解决不了的，就使用到离屏渲染。")]),a._v(" "),t("p",[a._v("相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：")]),a._v(" "),t("ul",[t("li",[a._v("创建新缓冲区：要想进行离屏渲染，首先要创建一个新的缓冲区")]),a._v(" "),t("li",[a._v("上下文切换：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen），等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。代价很大")])]),a._v(" "),t("p",[a._v("下面的情况或操作会引发离屏渲染：")]),a._v(" "),t("ul",[t("li",[a._v("为图层设置遮罩")]),a._v(" "),t("li",[a._v("layer.masksToBounds = true")]),a._v(" "),t("li",[a._v("设置阴影：设置 shadowPath")]),a._v(" "),t("li",[a._v("圆角：可使用 CAShapeLayer 优化")])]),a._v(" "),t("h2",{attrs:{id:"影响帧率的常见因素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#影响帧率的常见因素"}},[a._v("#")]),a._v(" 影响帧率的常见因素")]),a._v(" "),t("p",[a._v("CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。")]),a._v(" "),t("h2",{attrs:{id:"提高帧率的手段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提高帧率的手段"}},[a._v("#")]),a._v(" 提高帧率的手段")]),a._v(" "),t("ul",[t("li",[a._v("避免在主线程进行大量计算\n"),t("ul",[t("li",[a._v("异步计算")])])]),a._v(" "),t("li",[a._v("避免离屏渲染")]),a._v(" "),t("li",[a._v("异步绘制")])]),a._v(" "),t("p",[t("a",{attrs:{href:"http://www.starming.com/2017/06/20/deeply-ios-performance-optimization/",target:"_blank",rel:"noopener noreferrer"}},[a._v("深入剖析 iOS 性能优化"),t("OutboundLink")],1)]),a._v(" "),t("h2",{attrs:{id:"性能调优相关工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#性能调优相关工具"}},[a._v("#")]),a._v(" 性能调优相关工具")]),a._v(" "),t("ul",[t("li",[a._v("Instruments: Core Animation\n"),t("ul",[t("li",[a._v("检测离屏渲染")]),a._v(" "),t("li",[a._v("包含 Color Blended Layers 等")])])]),a._v(" "),t("li",[a._v("Instruments: Time Profiler\n"),t("ul",[t("li",[a._v("找出耗时调用")])])])]),a._v(" "),t("h1",{attrs:{id:"各种对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#各种对比"}},[a._v("#")]),a._v(" 各种对比")]),a._v(" "),t("h2",{attrs:{id:"进程和线程的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程的区别"}},[a._v("#")]),a._v(" 进程和线程的区别")]),a._v(" "),t("p",[a._v("前者是一个资源管理单元？后者是一个执行单元？")])])}),[],!1,null,null,null);r.default=s.exports}}]);