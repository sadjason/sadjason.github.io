(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{179:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("单例模式（singleton）对 Objective-C 开发者而言并不陌生，常见的实现方式为：在类编写名为"),a("code",[t._v("sharedInstance")]),t._v("的方法，该方法只会返回全类共用的单例实例，而不会在每次调用时都创建新的实例。假设有一个类叫"),a("code",[t._v("TestClass")]),t._v("，那么这个共享实例一般会这么写：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("sharedInstance "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" TestClass "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("sharedInstance "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nil"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("synchronized")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("sharedInstance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            sharedInstance "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),t._v(" alloc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" init"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" sharedInstance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),t._v(" "),a("p",[t._v("单例模式很容易引起激励讨论，Objective-C 的单例尤其如此。线程安全是大家争论的主要问题。为了保证线程安全，上述代码将创建单例实例的代码包裹在"),a("strong",[t._v("同步块")]),t._v("里。无论是好是坏，反正这种实现方式很常用，这样的代码也随处可见。")]),t._v(" "),a("p",[t._v("不过，GCD 引入了一项特性，能使单例实现起来更加容易。所用的函数是：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_once")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dispatch_once_t "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("token"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" dispatch_block_t block"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("此函数接受类型为"),a("code",[t._v("dispatch_once_t")]),t._v("的特殊参数，称其为"),a("strong",[t._v("标记")]),t._v("（token），此外还接受 block 参数，对于给定 token 来说，该函数保证相关的 block 必定会执行，且仅执行一次。首次调用该函数时，必然会执行 block 的代码，最重要的一点在于，此操作完全是线程安全的。请注意，对于只需执行一次的块来说，每次调用函数时传入的 token 都必须是完全相同的。因此，开发者通常将标记变量声明在"),a("code",[t._v("static")]),t._v("或"),a("code",[t._v("global")]),t._v("作用域里。")]),t._v(" "),a("p",[t._v("上述实现单例模式所用的"),a("code",[t._v("sharedInstance")]),t._v("方法，可以用此函数来改写：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("sharedInstance "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" TestClass "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("sharedInstance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" dispatch_once_t onceToken"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// typedef long dispatch_once_t;")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_once")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("onceToken"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        sharedInstance "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),t._v(" alloc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" init"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" sharedInstance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("使用"),a("code",[t._v("disptch_once")]),t._v("可以简化代码并且彻底保证线程安全，开发者根本无须担心加锁或同步。所有问题都由 GCD 在底层处理。由于每次调用时都必须使用完全相同的 token，所以 token 要声明成"),a("code",[t._v("static")]),t._v("。把该变量定义在"),a("code",[t._v("static")]),t._v("作用域中，可以保证编译器在每次执行"),a("code",[t._v("sharedInstance")]),t._v("方法时都会复用这个变量，而不会创建新变量。")]),t._v(" "),a("p",[t._v("此外，"),a("code",[t._v("dispatch_once")]),t._v("更高效。它没有使用重量级的同步机制，若是那样做的话，每次运行代码前都要获取锁，相反，此函数采用原子访问（atomic access）来查询标记，以判断其所对应的代码原来是否已经执行过。《Effective Objective-C 2.0》的作者在装有 64 位的 Mac OS X 10.8.2 系统的电脑上简单测试了性能，分别采用"),a("code",[t._v("@synchronized")]),t._v("方式及"),a("code",[t._v("dispatch_once")]),t._v("方式来实现"),a("code",[t._v("sharedInstance")]),t._v("，结果显示，后者的速度几乎是前者的 2 倍。")]),t._v(" "),a("p",[t._v("总结：")]),t._v(" "),a("ol",[a("li",[t._v("经常需要编写"),a("strong",[t._v("只需执行一次的线程安全代码")]),t._v("（thread-safe single-code execution），通过 GCD 提供的"),a("code",[t._v("dispatch_once")]),t._v("函数，很容易就能实现此功能。")]),t._v(" "),a("li",[t._v("token 应该声明在"),a("code",[t._v("static")]),t._v("或"),a("code",[t._v("global")]),t._v("中，这样的话，在把只需一次执行的块传给"),a("code",[t._v("dispatch_once")]),t._v("函数时，传进去的标记也是相同的。")])]),t._v(" "),a("h2",{attrs:{id:"本文参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本文参考"}},[t._v("#")]),t._v(" 本文参考")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://book.douban.com/subject/21370593/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Effective Objective-C 2.0"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=e.exports}}]);