(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{127:function(e,t,o){"use strict";o.r(t);var n=o(0),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h2",{attrs:{id:"nsoperation"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#nsoperation"}},[e._v("#")]),e._v(" NSOperation")]),e._v(" "),o("p",[o("s",[e._v("NSOperation 其实是对 task 的一种 Objective-C 封装。")])]),e._v(" "),o("p",[o("code",[e._v("NSOperation")]),e._v("是个抽象类，官方文档是这么描述的：")]),e._v(" "),o("blockquote",[o("p",[e._v("The NSOperation class itself is an abstract base class that must be subclassed in order to do any useful work.")])]),e._v(" "),o("p",[e._v("值得一提的是，Objective-C 中的 abstract class 和其余语言中的 abstract class 不太一样，其他语言（主要是静态语言）中的抽象类是不允许进行实例化的，如果对抽象类实例化了，则在编译阶段就可以检查出来；对于 Objective-C，对抽象类的说明仅仅停留在文档层面，如果作者想让某个类称为抽象类，则需要在开发文档中进行说明（没有所谓的 abstract 关键字来修饰），告诉用户不要直接对此类进行实例化，而是去继承它然后自己实现相关方法的定义，但是如果用户实例化该类，则也不会有啥问题（至少在编译阶段是没啥问题）。")]),e._v(" "),o("p",[e._v("如果抽象类的定义只是依靠文档说明，则未免有些太弱了，通常的做法是：You can force a user to at least override certain methods by raising an exception in those methods implementation in your abstract class:")]),e._v(" "),o("div",{staticClass:"language-objectivec extra-class"},[o("pre",{pre:!0,attrs:{class:"language-objectivec"}},[o("code",[o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("NSException raise"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("NSInternalInconsistencyException \n            format"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),o("span",{pre:!0,attrs:{class:"token string"}},[e._v('@"You must override %@ in a subclass"')]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("NSStringFromSelector")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("_cmd"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),o("p",[e._v("当然，也可以使用"),o("code",[e._v("assert")]),e._v("或"),o("code",[e._v("NSAssert")]),e._v("处理。这和 Python 很多场合对抽象类的处理有些类似，更多讯息参考来自 stackoverflow 的"),o("a",{attrs:{href:"http://stackoverflow.com/questions/1034373/creating-an-abstract-class-in-objective-c",target:"_blank",rel:"noopener noreferrer"}},[e._v("Creating an abstract class in Objective-C"),o("OutboundLink")],1),e._v("。")]),e._v(" "),o("p",[e._v("Foundation Framework 提供了两个比较好用的"),o("code",[e._v("NSOperation")]),e._v("子类，"),o("code",[e._v("NSInvocationOperation")]),e._v("和"),o("code",[e._v("NSBlockOperation")]),e._v("。")]),e._v(" "),o("p",[e._v("就我目前的使用经验来看，还没有遇到直接使用"),o("code",[e._v("NSOperation")]),e._v("的机会，更多的时候使用 AFNetworking 框架提供的"),o("code",[e._v("AFHTTPRequestOperation")]),e._v("。")]),e._v(" "),o("p",[o("strong",[e._v("执行 operation")])]),e._v(" "),o("p",[o("code",[e._v("NSOperation")]),e._v("对象往往关联一段代码，执行这段代码有两种方式：")]),e._v(" "),o("ol",[o("li",[e._v("直接执行其"),o("code",[e._v("start")]),e._v("方法；")]),e._v(" "),o("li",[e._v("将"),o("code",[e._v("NSOperation")]),e._v("对象添加到"),o("code",[e._v("NSOperationQueue")]),e._v("中；")])]),e._v(" "),o("p",[e._v("P.S: 关于"),o("code",[e._v("NSOperation")]),e._v("的内容还有很多，譬如优先级、completion block 之类的，更多信息参考 Apple 文档"),o("a",{attrs:{href:"https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Concurrency Programming Guide"),o("OutboundLink")],1),e._v("，写得很详细。")]),e._v(" "),o("h2",{attrs:{id:"nsoperationqueue"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#nsoperationqueue"}},[e._v("#")]),e._v(" NSOperationQueue")]),e._v(" "),o("p",[e._v("在阅读"),o("a",{attrs:{href:"https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Concurrency Programming Guide"),o("OutboundLink")],1),e._v("的过程中，不免和 GCD 进行对比，非常疑惑的问题是，"),o("code",[e._v("NSOperation")]),e._v("的执行大概是什么样子的？并行？FIFO？在 main thread 还是 other threads？下面就围绕这些问题进行阐述。")]),e._v(" "),o("h3",{attrs:{id:"创建-nsoperationqueue-对象"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#创建-nsoperationqueue-对象"}},[e._v("#")]),e._v(" 创建 NSOperationQueue 对象")]),e._v(" "),o("p",[e._v("创建"),o("code",[e._v("NSOperationQueue")]),e._v("有两种方式：")]),e._v(" "),o("div",{staticClass:"language-objectivec extra-class"},[o("pre",{pre:!0,attrs:{class:"language-objectivec"}},[o("code",[o("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 1. NSOperationQueue")]),e._v("\nNSOperationQueue "),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v("operationQueue1 "),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("NSOperationQueue alloc"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" init"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    \n"),o("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 2. NSOperationQueue")]),e._v("\nNSOperationQueue "),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v("operationQueue2 "),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("NSOperationQueue mainQueue"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),o("p",[e._v("先说"),o("code",[e._v("mainQueue")]),e._v("，it returns the operation queue associated with the main thread，简而言之，"),o("code",[e._v("mainQueue")]),e._v("上的 operation（或曰 task）都是在 main thread 上完成的，进一步来说，"),o("code",[e._v("mainQueue")]),e._v("中的 operation 都有控制 UI 的能力；对于第一种方式"),o("code",[e._v("[NSOperationQueue alloc]")]),e._v("，则不然，其关联的 thread 与 main thread 或许无关。")]),e._v(" "),o("p",[e._v("所以也可以看出来："),o("strong",[e._v("operation 的执行 thread 由其所在的 NSOperationQueue 决定")]),e._v("。")]),e._v(" "),o("p",[e._v("值得一提的是，同一个"),o("code",[e._v("NSOperationQueue")]),e._v("的不同 operation 的执行线程并非同一个，因为"),o("code",[e._v("NSOperationQueue")]),e._v("可能同时涉及多个线程。")]),e._v(" "),o("p",[e._v("并且这和 GCD 不同，GCD 中，dispatch_queue 中的 block 的执行线程不单由 queue 决定，还与 block 的派发方式有关。")]),e._v(" "),o("p",[o("code",[e._v("NSOperationQueue")]),e._v("对象不存在所谓的"),o("code",[e._v("start")]),e._v("之类的启动方法，根据我的理解，自它被创建了就开始工作了。")]),e._v(" "),o("p",[e._v("P.S: 目前还没有到有用到"),o("code",[e._v("[NSOperationQueue mainQueue]")]),e._v("的应用，很想知道在哪些场合会用到...")]),e._v(" "),o("h3",{attrs:{id:"nsoperationqueue-的工作方式"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#nsoperationqueue-的工作方式"}},[e._v("#")]),e._v(" NSOperationQueue 的工作方式")]),e._v(" "),o("p",[e._v("根据"),o("a",{attrs:{href:"https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Concurrency Programming Guide"),o("OutboundLink")],1),e._v("上介绍，获悉：")]),e._v(" "),o("ol",[o("li",[o("code",[e._v("NSOperationQueue")]),e._v("是不支持 FIFO 的，因为"),o("code",[e._v("NSOperation")]),e._v("存在 priority 的概念，所以"),o("code",[e._v("NSOperationQueue")]),e._v("是不支持 FIFO 的；")]),e._v(" "),o("li",[o("code",[e._v("NSOperationQueue")]),e._v("上的 operation 是并发执行的，但是用户可以配置同一时刻最多可以并发的 operation 数量，对应属性是"),o("code",[e._v("maxConcurrentOperationCount")]),e._v("，也就是说，如果"),o("code",[e._v("maxConcurrentOperationCount")]),e._v("的值设置为 1，则"),o("code",[e._v("NSOperationQueue")]),e._v("中的 operation 是串行执行的（串行顺序依然受 priority 和就绪状态决定，不遵循 FIFO）；")])]),e._v(" "),o("h3",{attrs:{id:"nsoperation-的-completion-block"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#nsoperation-的-completion-block"}},[e._v("#")]),e._v(" NSOperation 的 completion block")]),e._v(" "),o("p",[e._v("考虑到接触的频率非常之高，有必要对"),o("code",[e._v("NSOperation")]),e._v("的 completion block 做更多的了解。")]),e._v(" "),o("blockquote",[o("p",[e._v("In OS X v10.6 and later, an operation can execute a completion block when its main task finishes executing. You can use a completion block to perform any work that you do not consider part of the main task. For example, you might use this block to notify interested clients that the operation itself has completed. A concurrent operation object might use this block to generate its final KVO notifications.\nTo set a completion block, use the setCompletionBlock: method of NSOperation. The block you pass to this method should have no arguments and no return value.")])]),e._v(" "),o("p",[e._v("考虑这么一个应用场景，使用"),o("code",[e._v("NSOperation")]),e._v("服务下载一张图片，在 completion block 中更新相关"),o("code",[e._v("UIImageView")]),e._v("，图片下载图片后，就会调用 completion block。")]),e._v(" "),o("p",[e._v("结合这个应用场景，刚开始，对"),o("code",[e._v("NSOperation")]),e._v("的 completion block 比较疑惑的地方在于，completion block 哪一个线程执行，在 main thread，还是和"),o("code",[e._v("NSOperation")]),e._v("所在线程是同一个？前者的可能性不高；如果是后者，考虑到只有 main thread 上代码才有控制 UI 的资格，那么"),o("code",[e._v("NSOperation")]),e._v("必须得在 main thread 上执行，即其所在 operation queue 的创建方式是"),o("code",[e._v("oq = [NSOperationQueue mainQueue];")]),e._v("，但是 download image 代码难免会产生阻塞，必然会影响 UI 的交互，显然是不可取。")]),e._v(" "),o("p",[e._v("将"),o("code",[e._v("NSOperation")]),e._v("和其 completion block 割裂来看的做法显然是愚蠢的，也就是说，执行"),o("code",[e._v("NSOperation")]),e._v("的 completion block 的线程和执行"),o("code",[e._v("NSOperation")]),e._v("的线程是一样的，也都是由其所在的"),o("code",[e._v("NSOperationQueue")]),e._v("决定的。")]),e._v(" "),o("p",[e._v("带着这个问题，我查看了 AFNetworking 的处理代码，它的做法是这样的，执行网络任务的"),o("code",[e._v("NSOperation")]),e._v("所在的"),o("code",[e._v("NSOperation")]),e._v("所关联的 thread 都不是 main thread，为了在下载图片（也可能是其他数据）后更新 UI，其调用 completion block 的方式并不是直接调用，而是使用"),o("code",[e._v("dispatch_group_async")]),e._v("函数将用户指定的 completion block 添加到 main thread。\n简单来说，在用户的 completion block 基础上加了一层，确保用户的 completion block 在 main thread 上执行，认识到这一点很重要！")]),e._v(" "),o("p",[e._v("P.S: AFNetworking 的网络任务的 CompletionBlock 都是在 main thread 中完成的，这从"),o("code",[e._v("AFHTTPRequestOperation")]),e._v("的"),o("code",[e._v("setCompletionBlockWithSuccess:fuilure:")]),e._v("方法定义可以看出来。")]),e._v(" "),o("h2",{attrs:{id:"nsoperation-v-s-gcd"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#nsoperation-v-s-gcd"}},[e._v("#")]),e._v(" NSOperation v.s GCD")]),e._v(" "),o("p",[e._v("关于"),o("code",[e._v("NSOperation")]),e._v("（以及"),o("code",[e._v("NSOperationQueue")]),e._v("）和 GCD 的关系，引用《Effective-C 2.0》的描述：")]),e._v(" "),o("blockquote",[o("p",[e._v("The similarity to GCD's dispatch queues is not a coincidence. Operation queues came before GCD, but there is no doublt that GCD is based on the principles made popular by operation queues. In fact, from iOS 4 and Mac OS X 10.6 onward, operation queues use GCD under hood.")])]),e._v(" "),o("p",[e._v("GCD 的同步机制无与伦比，但有些时候使用"),o("code",[e._v("NSOperation")]),e._v("或许是更好的选择，相较于 GCD，"),o("code",[e._v("NSOperation")]),e._v("有如下这些优势：")]),e._v(" "),o("ol",[o("li",[o("p",[e._v("取消操作（任务）\n在 GCD 中，是没办法对添加到 queue 的 task 进行 cancel 操作的，但是"),o("code",[e._v("NSOperation")]),e._v("是可以的；值得一提的是，"),o("code",[e._v("NSOperation")]),e._v("取消操作只适用于哪些还没被执行的 operation，如果 operation 正在 running，则 cancel 操作是无效的。")])]),e._v(" "),o("li",[o("p",[e._v("Operation dependencies\nAn operation can have dependencies on as many other operations as it wishes. This enables you to create a hierarchy of operations dictating that certain operations can execute only after another operation has completed successfully. For example, you may have operations to download and process files from a server that requires a manifest file to be downloaded first before others can be processed. The operation to download the manifest file first could be a dependency of the subsequent download operations. If the operation queue were set to allow concurrent execution, the subsequent downloads could execute in parallel but only after the dependent operation had completed.")])]),e._v(" "),o("li",[o("p",[e._v("KVO\n对"),o("code",[e._v("NSOperation")]),e._v("，还可以对其某些属性进行 KVO 处理，这对于基于 C-API 的 GCD 是没办法做到的，至于"),o("code",[e._v("NSOperation")]),e._v("哪些属性支持 KVO，还需要参考"),o("a",{attrs:{href:"https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Concurrency Programming Guide"),o("OutboundLink")],1),e._v("。")])]),e._v(" "),o("li",[o("p",[e._v("优先级控制\nGCD 的 dispatch queue 中的任务的执行顺序全部遵循 FIFO，但是"),o("code",[e._v("NSOperationQueue")]),e._v("中对 operation 的调用更复杂一些，因为它每个 operation 都有优先级，所以用户可以通过优先级控制实现对任务更复杂的管理。")])]),e._v(" "),o("li",[o("p",[e._v("Reuse of operations\n因为"),o("code",[e._v("NSOperation")]),e._v("是完全支持面向对象的类，所以其对 reuse 的支持也是相对于 GCD 的一大优势。")])])]),e._v(" "),o("h2",{attrs:{id:"本文参考"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#本文参考"}},[e._v("#")]),e._v(" 本文参考")]),e._v(" "),o("ul",[o("li",[o("a",{attrs:{href:"http://www.raywenderlich.com/19788/how-to-use-nsoperations-and-nsoperationqueues",target:"_blank",rel:"noopener noreferrer"}},[e._v("How To Use NSOperations and NSOperationQueues"),o("OutboundLink")],1),e._v("；")]),e._v(" "),o("li",[o("a",{attrs:{href:"https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Concurrency Programming Guide"),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"https://book.douban.com/subject/21370593/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Effective Objective-C 2.0"),o("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=a.exports}}]);