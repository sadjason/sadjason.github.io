(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{154:function(e,s,o){"use strict";o.r(s);var i=o(0),t=Object(i.a)({},(function(){var e=this,s=e.$createElement,o=e._self._c||s;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[e._v("最近写 Web 服务，过程中梳理了一下 Cookie 和 Session 的知识，完成度勉强可以，于是以博客的方式进行展示。")]),e._v(" "),o("p",[e._v("HTTP 请求都是无状态的，但 Web 应用通常都需要记录一些状态信息，譬如知道发起请求的人是谁。Cookie 和 Session 正是用来弥补用户状态追踪的两种机制；它们的区别是啥呢？博文"),o("a",{attrs:{href:"https://justsee.iteye.com/blog/1570652",target:"_blank",rel:"noopener noreferrer"}},[e._v("Session 机制详解"),o("OutboundLink")],1),e._v("里举了几个非常精彩的例子，直接摘抄如下：")]),e._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[e._v("🌰")]),e._v(" "),o("p",[e._v("让我们用几个例子来描述一下 cookie 和 session 机制之间的区别与联系。笔者曾经常去的一家咖啡店有喝5杯咖啡免费赠一杯咖啡的优惠，然而一次性消费5杯咖啡的机会微乎其微，这时就需要某种方式来纪录某位顾客的消费数量。想象一下其实也无外乎下面的几种方案：")]),e._v(" "),o("p",[e._v("1、该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。")]),e._v(" "),o("p",[e._v("2、发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态。")]),e._v(" "),o("p",[e._v("3、发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在服务器端保持状态。")]),e._v(" "),o("p",[e._v("由于HTTP协议是无状态的，而出于种种考虑也不希望使之成为有状态的，因此，后面两种方案就成为现实的选择。具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。")])]),e._v(" "),o("h1",{attrs:{id:"cookie"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[e._v("#")]),e._v(" Cookie")]),e._v(" "),o("h2",{attrs:{id:"相关首部"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#相关首部"}},[e._v("#")]),e._v(" 相关首部")]),e._v(" "),o("p",[e._v("站在 HTTP 协议的角度来看，HTTP 协议中有两个与 Cookie 直接相关首部：")]),e._v(" "),o("ul",[o("li",[e._v("Set-Cookie，由 response 携带，指示 client 存储 cookie 到本地")]),e._v(" "),o("li",[e._v("Cookie，由 request 携带，将本地 cookie 传给 server")])]),e._v(" "),o("p",[e._v("Server 发送 response 时，通过 Set-Cookie 首部，告诉客户端（譬如浏览器）将 cookie 内容给存储起来。该字段包括如下常用属性用来指导「客户端如何存储」：")]),e._v(" "),o("ul",[o("li",[e._v("Domain：cookie 适用的域名，若不指定，则默认为创建 cookie 的服务器的域名")]),e._v(" "),o("li",[e._v("Path：cookie 适用的 path")]),e._v(" "),o("li",[e._v("Expires：到期时间，若不指定，则浏览器关闭时即删除")]),e._v(" "),o("li",[e._v("Secure：指示是否仅当在 HTTPS 链接上才传输")]),e._v(" "),o("li",[e._v("HttpOnly：加以限制，使得 cookie 不能被 JavaScript 脚本访问（意味着不能 JS 不能通过"),o("code",[e._v("document.cookie")]),e._v("的方式访问 cookie）")])]),e._v(" "),o("p",[e._v("这几个常用属性都不难理解，其中 Domain 和 Path 限制了 cookie 的使用范围，浏览器在发起 request 的时候，会根据这两个属性将符合使用范围的 cookie 发给 server；Secure 指示是否在 HTTPS 环境下才能传输。")]),e._v(" "),o("p",[e._v("事实上，Cookie 还有更多其他属性，只是不怎么常用；之前的博客"),o("router-link",{attrs:{to:"/post/http-draft.html"}},[e._v("HTTP 碎片信息")]),e._v("对 Cookie 的发展史和字段详情有更详细的描述。")],1),e._v(" "),o("p",[e._v("下图是使用 Charles 抓包的一个 Set-Cookie 信息样例：")]),e._v(" "),o("e-img",{attrs:{src:"/image/charles-set-cookie.png"}}),e._v(" "),o("p",[e._v("客户端在发起 request 请求时，会根据 Domain 和 Path 将符合规则的本地 Cookie 内容给找出来发送给 server，内容存储在 Cookie 首部中，如下图：")]),e._v(" "),o("e-img",{attrs:{src:"/image/charles-cookie.png"}}),e._v(" "),o("h2",{attrs:{id:"持久-cookie-会话-cookie"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#持久-cookie-会话-cookie"}},[e._v("#")]),e._v(" 持久 Cookie & 会话 Cookie")]),e._v(" "),o("p",[e._v("从存活时长来看，Cookie 通常被笼统划分为两种类型：会话 cookie、持久 cookie。前者是一种临时 cookie，会话结束（一般是浏览器被关闭）时，cookie 就被删除了。持久 cookie 的生存时间更长一些，它们存储在硬盘上，应用程序退出时，仍然会保留它们。")]),e._v(" "),o("p",[e._v("简单来说，当设置了 Discard，或者没有设置 Expires 或 Max-Age，就意味着这个 cookie 是一个会话 cookie。")]),e._v(" "),o("h1",{attrs:{id:"session"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#session"}},[e._v("#")]),e._v(" Session")]),e._v(" "),o("p",[e._v("关于 Cookie 和 Session 的对比，一种常见的说法是：")]),e._v(" "),o("ul",[o("li",[e._v("Cookie：在客户端保存用户状态")]),e._v(" "),o("li",[e._v("Session：在服务端保存用户状态")])]),e._v(" "),o("p",[e._v("在我看来，第一句没问题，第二句不是很准确。为啥不准确呢？Cookie 是一种事实上的标准，但 Session 不是，它只是一种比较常见的概念，没有所谓的实现标准；换句话说，不同的服务框架，Session 的实现机制可能是不一样的，它可能被保存在服务端，也可能保存在客户端。")]),e._v(" "),o("h2",{attrs:{id:"session-的实现机制"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#session-的实现机制"}},[e._v("#")]),e._v(" Session 的实现机制")]),e._v(" "),o("p",[e._v("这一部分讲述 Session 的常见实现机制。据我所知，从存储的角度看，session 的常见实现机制有两种。")]),e._v(" "),o("p",[e._v("第一种姿势：session 信息存储在服务端。这种实现机制中，服务端负责生成和管理 session 信息，每个 session 会有一个 session id，server 返回 response 给 client 时会让后者以 cookie 的形式存储 session id，后续发起 request 请求时，都会在 HTTP 报文的 Cookie 首部中携带 session id，server 根据 id 找到对应的 session 信息。")]),e._v(" "),o("p",[e._v("第二种姿势：session 信息存储在客户端。这种实现机制中，服务端负责生成 session 信息，但不存储，在 response 中，通过 Set-Cookie 首部让 client 把 session 信息（一般都进行了加密）存在 cookie 中，后续 client 发起 request 请求时，server 从 Cookie 首部取出 session 信息进行解密读取，以及进行各种操作，然后再通过 Set-Cookie 回写到 client。")]),e._v(" "),o("p",[e._v("这两种姿势有何优劣？如下谈谈个人的理解。")]),e._v(" "),o("p",[e._v("从客户端角度看，第一种姿势 client 承担的任务更轻一些，毕竟只需管理 session id，第二种姿势负责管理的信息更重一些：整个 session 信息，虽然可能是加密压缩的。当 session 信息比较大时，负载无疑更重。")]),e._v(" "),o("p",[e._v("第一种姿势更常见，好处貌似更明显；为啥还有第二种姿势存在呢？")]),e._v(" "),o("p",[e._v("对于轻量级的应用，以线程或协程为粒度处理 request 的服务框架（譬如 Java、Go 生态），一般都采用第一种。而笔者实践过的 Egg.js 框架，提供的默认 session 实现机制是第二种。我认为很重要的原因是 Node 无法提供线程服务，为了提高服务端响应速度，通常开启多个 node 进程，进程之间共享数据却是个麻烦，把 session 数据放在客户端能规避这个麻烦，服务端基本上无需在管理 session 上费心，因为 session 已然是 request 的一部分。")]),e._v(" "),o("p",[e._v("然而，对于大型分布式应用，一般都采用第一种姿势，在分布式场景下，管理 session 是一个重要的议题，而 Redis 在其中扮演者重要角色，本文就不展开描述了。")])],1)}),[],!1,null,null,null);s.default=t.exports}}]);