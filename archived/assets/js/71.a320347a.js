(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{114:function(t,e,a){"use strict";a.r(e);var s=a(0),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("曾认真阅读过《图解 HTTP》和《HTTP 权威指南》，本文是过程中的阅读笔记。")]),t._v(" "),a("h2",{attrs:{id:"http-相关-rfc-文档"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-相关-rfc-文档"}},[t._v("#")]),t._v(" HTTP 相关 RFC 文档")]),t._v(" "),a("p",[t._v("HTTP（HyperText Transfer Protocol）于 1990 年问世，下表是相关 RFC 及年份信息：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("HTTP")]),t._v(" "),a("th",[t._v("RFC")]),t._v(" "),a("th",[t._v("年份")]),t._v(" "),a("th",[t._v("说明")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("HTTP 0.9")]),t._v(" "),a("td",[t._v("无")]),t._v(" "),a("td",[t._v("1990 年")]),t._v(" "),a("td",[t._v("作为非正式标准被提出")])]),t._v(" "),a("tr",[a("td",[t._v("HTTP 1.0")]),t._v(" "),a("td",[a("a",{attrs:{href:"https://tools.ietf.org/html/rfc1945",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC1945"),a("OutboundLink")],1)]),t._v(" "),a("td",[t._v("1996 年 5 月")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("HTTP 1.1")]),t._v(" "),a("td",[a("a",{attrs:{href:"https://www.ietf.org/rfc/rfc2068.txt",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC2068"),a("OutboundLink")],1),t._v("、"),a("a",{attrs:{href:"https://www.ietf.org/rfc/rfc2616.txt",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC2616"),a("OutboundLink")],1),t._v("（修订版）")]),t._v(" "),a("td",[t._v("1997 年 1 月")]),t._v(" "),a("td",[t._v("目前主流")])]),t._v(" "),a("tr",[a("td",[t._v("HTTP 2.0")]),t._v(" "),a("td",[a("a",{attrs:{href:"https://tools.ietf.org/html/rfc7540",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC7540"),a("OutboundLink")],1)]),t._v(" "),a("td",[t._v("2015 年 5 月")]),t._v(" "),a("td",[t._v("基于"),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/SPDY",target:"_blank",rel:"noopener noreferrer"}},[t._v("SPDY"),a("OutboundLink")],1)])])])]),t._v(" "),a("h2",{attrs:{id:"uri"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#uri"}},[t._v("#")]),t._v(" URI")]),t._v(" "),a("p",[t._v("URI 有两种：URL 和 URN，即 URL 和 URN 都是 URI 的子集。现在的 Web 世界中，几乎所有的 URI 都是 URN。但是 URL 有个毛病，若资源从一个位置移到另外一个位置，则意味着对应的 URL 失效了，URN 致力于解决这个问题。")]),t._v(" "),a("ul",[a("li",[t._v("URL，譬如"),a("code",[t._v("http://www.example.com/index.html")])]),t._v(" "),a("li",[t._v("URN，譬如"),a("code",[t._v("urn:ietf:rfc:2141")])])]),t._v(" "),a("p",[t._v("URL 的基本格式是：")]),t._v(" "),a("div",{staticClass:"language-textile extra-class"},[a("pre",{pre:!0,attrs:{class:"language-textile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("scheme")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("://")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("user")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("password")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("host")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("port")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("path")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("params")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("query")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("fragment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),a("p",[t._v("可以看到，URL 包括很多组件，但是在实际应用中，几乎没有哪个 URL 包含了所有这些组件。最重要的组件有 3 个：scheme、host、path。简单说明：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("@")]),t._v("将用户和密码组件与 URL 的其余部分隔开开来")]),t._v(" "),a("li",[t._v("path 组件可以由很多个路径分段，譬如"),a("code",[t._v("/path/to/hell/")]),t._v("，每个分段可以有一个参数（param）组件")]),t._v(" "),a("li",[t._v("query 的格式没有限制，但是一般是"),a("code",[t._v("item1=value1&item2=value2")]),t._v("这种结构")]),t._v(" "),a("li",[t._v("片段（fragment）组件表示一个资源内部的片段，当资源比较大时常会用到")])]),t._v(" "),a("p",[t._v("一些常见 URL 的基本格式：")]),t._v(" "),a("div",{staticClass:"language-textile extra-class"},[a("pre",{pre:!0,attrs:{class:"language-textile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("http://")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("host")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("port")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("path")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("query")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("fragment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("mailto:<rfc"),a("span",{pre:!0,attrs:{class:"token inline"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token deleted"}},[t._v("822")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")])]),t._v("addr-spec>\nftp://")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("user")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("password")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("host")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("port")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("path")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("params")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("file://")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("host")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("path")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("telnet://")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("user")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("password")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("host")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("port")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("/\n")])])])]),a("h2",{attrs:{id:"http-消息格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-消息格式"}},[t._v("#")]),t._v(" HTTP 消息格式")]),t._v(" "),a("p",[t._v("TCP 的数据单位被称为 TCP 报文（segment），HTTP 的数据单位被称为 HTTP 消息（message），下文简称 HTTP 消息为 message。\n从方向或应答角度来看，message 有两种：请求消息（Request）、响应消息（Response）。请求消息和响应消息都由 1 个开始行（start-line）、0 个或多个消息头（headers）、可有可无的消息主体（message-body）组成，如下：")]),t._v(" "),a("div",{staticClass:"language-textile extra-class"},[a("pre",{pre:!0,attrs:{class:"language-textile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("generic-message =\n    start-line                 ; 开始行\n    *(message-header CRLF)     ; 消息头\n    CRLF\n    [message-body]             ; 消息主体\n     \n;  其中CRLF表示“结束符”\n;  *表示“0个或多个“”\n;  []表示“可有可无”\n")])])])]),a("p",[t._v("下面将围绕开始行、消息头、消息主体这几个概念进行最粗浅的概述。")]),t._v(" "),a("h3",{attrs:{id:"开始行（start-line）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开始行（start-line）"}},[t._v("#")]),t._v(" 开始行（Start-Line）")]),t._v(" "),a("p",[t._v("开始行是什么样的格式？这可不一定，因为对于不同的消息类型（请求消息和响应消息），开始行的格式是不同的：")]),t._v(" "),a("ul",[a("li",[t._v("对于请求消息，start-line 是 Request-Line（请求行），请求行的格式")]),t._v(" "),a("li",[t._v("对于响应消息，start-line 是 Status-Line（状态行），状态行的格式")])]),t._v(" "),a("h3",{attrs:{id:"消息头（headers）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息头（headers）"}},[t._v("#")]),t._v(" 消息头（Headers）")]),t._v(" "),a("p",[t._v("根据作用域来分，消息头分为：常用头（general-header）、请求头（request-header）、响应头（response-header）、实体头（entity-header）。无论如何，它们的格式总是这样：")]),t._v(" "),a("div",{staticClass:"language-textile extra-class"},[a("pre",{pre:!0,attrs:{class:"language-textile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("message"),a("span",{pre:!0,attrs:{class:"token inline"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token deleted"}},[t._v("header = field")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")])]),t._v('name ":" [field-value]\n')])])])]),a("p",[t._v("其中"),a("code",[t._v("field-name")]),t._v("对大小写不敏感。首部内容非常丰富，估计得专门开辟一篇博客来记录。")]),t._v(" "),a("p",[a("code",[t._v("field-value")]),t._v("对大小写敏感吗？似乎没有确切的说法，参考：")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"http://stackoverflow.com/questions/5258977/are-http-headers-case-sensitive",target:"_blank",rel:"noopener noreferrer"}},[t._v("Are HTTP headers case-sensitive?"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"http://stackoverflow.com/questions/10953635/are-the-http-connection-header-values-case-sensitive",target:"_blank",rel:"noopener noreferrer"}},[t._v("Are the HTTP Connection header values case sensitive?"),a("OutboundLink")],1)])]),t._v(" "),a("h3",{attrs:{id:"消息主体（message-body）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息主体（message-body）"}},[t._v("#")]),t._v(" 消息主体（Message-Body）")]),t._v(" "),a("p",[t._v("RFC2616 中讲：")]),t._v(" "),a("blockquote",[a("p",[t._v("The message-body (if any) of an HTTP message is used to carry the entity-body associated with the request or response.")])]),t._v(" "),a("p",[t._v("如下：")]),t._v(" "),a("div",{staticClass:"language-textile extra-class"},[a("pre",{pre:!0,attrs:{class:"language-textile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("message"),a("span",{pre:!0,attrs:{class:"token inline"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token deleted"}},[t._v("body = entity")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")])]),t._v("body | <entity"),a("span",{pre:!0,attrs:{class:"token inline"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token deleted"}},[t._v("body encoded as per Transfer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")])]),t._v("Encoding>\n")])])])]),a("h2",{attrs:{id:"消息主体-v-s-实体主体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息主体-v-s-实体主体"}},[t._v("#")]),t._v(" 消息主体 v.s 实体主体")]),t._v(" "),a("p",[t._v("消息主体（message-body）和实体主体（entity-body）是非常容易混淆的两个概念：")]),t._v(" "),a("ul",[a("li",[t._v("entity-body 可以被理解为客户端想让服务端看到的内容")]),t._v(" "),a("li",[t._v("message-body 指的是服务端接收到的（来自于客户端）实际内容")])]),t._v(" "),a("p",[t._v("通常，消息主体等于实体主体，但是，当在传输过程中进行编码时，entity-body 就不再等于 message-body 了，此时，根据我的理解，message-body 等于传输编码后的 entity-body。")]),t._v(" "),a("h2",{attrs:{id:"安全方法和幂等方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安全方法和幂等方法"}},[t._v("#")]),t._v(" 安全方法和幂等方法")]),t._v(" "),a("p",[t._v("请求消息有若干种方法，常见划分种类有两种：安全方法（Safe Methods）和幂等方法（Idempotent Mehtods）。")]),t._v(" "),a("p",[t._v("要理解安全方法，先介绍一个概念：副作用，副作用指当你发送完一个请求以后，网站上的资源状态没有发生修改，即认为这个请求是无副作用的。比如注册用户这个请求是有副作用的，获取用户详情可以认为是无副作用的。")]),t._v(" "),a("p",[t._v("对于幂等方法，幂等是说一个请求原封不动的发送 N 次和 M 次（N 不等于 M，N 和 M 都大于 1）服务器上资源的状态最终是一致的。比如发贴是非幂等的，重放 10 次发贴请求会创建 10 个帖子。但修改帖子内容是幂等的，一个修改请求重放无论多少次，帖子最终状态都是一致的。")]),t._v(" "),a("p",[t._v("请求消息的方法众多，有些的方法只是读取服务器的资源，有的方法可能会修改服务器的资源。GET 和 HEAD 属于前者，它们只是获取资源，这些方法被称为安全方法；POST、PUT、DELETE 属于后者，它们可能使服务器的资源发生变化，这些方法被称为幂等方法。")]),t._v(" "),a("p",[t._v("P.S: 根据我的理解，所谓的安全方法和幂等方法只是一种臆想，不是绝对的。举个例子，服务器有某篇文章，现在浏览器通过 GET 方法获取这篇文章，当然，客户端并没有修改这篇文章，但是，服务器可能做了这样的处理：将这篇文章的浏览次数+1；客观来讲，这个 GET 方法还是修改了服务器的资源；所以，知道安全方法和幂等方法这两个概念就好，不必当真。")]),t._v(" "),a("p",[t._v("P.P.S: 这只是我的理解，可能是错的...")]),t._v(" "),a("h2",{attrs:{id:"持久连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持久连接"}},[t._v("#")]),t._v(" 持久连接")]),t._v(" "),a("p",[t._v("客户端发起一个请求，服务端给出响应，这个一来一回的过程被称为 "),a("em",[t._v("一个 HTTP 事务")]),t._v(" 。在非持久连接中，每个 HTTP 事务处理结束之后，TCP 连接会被关闭。")]),t._v(" "),a("p",[t._v("而从 1.1 版本开始，HTTP 默认开启持久连接。简单来说，在事务处理结束之后仍然保持在打开状态的 TCP 链接被称为持久连接。")]),t._v(" "),a("p",[t._v("HTTP/1.1 和 HTTP/1.0 实现持久连接的方式不一样，因此得分开讨论。")]),t._v(" "),a("h3",{attrs:{id:"http-1-0-的持久连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0-的持久连接"}},[t._v("#")]),t._v(" HTTP/1.0 的持久连接")]),t._v(" "),a("p",[t._v("在 HTTP/1.1 之前版本中，HTTP 默认都是非持久连接，某些实现支持了持久连接，若想维持持久连接，client 需要在 request 中携带"),a("code",[t._v("Connection: Keep-Alive")]),t._v("首部，同样，sever 需要在 response 中也携带"),a("code",[t._v("Connection: Keep-Alive")]),t._v("首部。\n使用 HTTP/1.0 的 Keep-Alive，有一些限制和需要澄清的地方：")]),t._v(" "),a("ul",[a("li",[t._v("如果 response 中没有"),a("code",[t._v("Connection: Keep-Alive")]),t._v("首部，意味着 server 会在之后关闭连接")]),t._v(" "),a("li",[a("code",[t._v("Connection: Keep-Alive")]),t._v("首部必须随所有希望保持持久连接的报文一起发送，如果某个 request 没有发送该首部，则服务器会在那条请求之后关闭连接")]),t._v(" "),a("li",[t._v("只有在无需检测到连接的关闭即可确定 entity-body 长度的情况下，才能将连接保持在持久状态，也就是说\n"),a("ul",[a("li",[t._v("必须有正确的 Content-Length 来标明 entity-body 的长度")]),t._v(" "),a("li",[t._v("有 multipart 媒体类型，或者用分块传输编码的方式进行了编码")])])]),t._v(" "),a("li",[t._v("《HTTP 权威指南》还有一些说明...")])]),t._v(" "),a("h3",{attrs:{id:"http-1-1-的持久连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1-的持久连接"}},[t._v("#")]),t._v(" HTTP/1.1 的持久连接")]),t._v(" "),a("p",[t._v("在 HTTP/1.1 版本中，持久连接在默认情况下是激活的，无需开启。除非特别指明，否则 HTTP/1.1 假定所有连接都是持久的。要在事务处理结束之后将连接关闭，HTTP/1.1 应用程序必须向报文显式添加"),a("code",[t._v("Connection: close")]),t._v("首部。")]),t._v(" "),a("p",[t._v("问题："),a("code",[t._v("Connection: close")]),t._v("首部是在 request 中，还是在 response 中呢？答案是：Client 和 server 都可以在报文中携带该首部。")]),t._v(" "),a("p",[t._v("HTTP/1.1 持久连接的使用，也有一些限制和需要澄清的地方：")]),t._v(" "),a("ul",[a("li",[t._v("发送了"),a("code",[t._v("Connection: close")]),t._v("请求首部后，client 就无法在那条连接上发送更多的请求了")]),t._v(" "),a("li",[t._v("如果 client 不想在连接上发送其他请求，就应该在最后一条请求中发送一个"),a("code",[t._v("Connection: close")]),t._v("首部")]),t._v(" "),a("li",[t._v("只有当连接上所有的报文都有正确的、自定义报文长度时，连接才能持久保持，也就是说，entity-body 长度和 Content-Length 一致，或者用分块传输编码方式编码")]),t._v(" "),a("li",[t._v("一个 client 对任何 server 或者 proxy，只能维持两条持久连接，以防 server 过载")])]),t._v(" "),a("h3",{attrs:{id:"keep-alive-首部"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-首部"}},[t._v("#")]),t._v(" Keep-Alive 首部")]),t._v(" "),a("p",[t._v("HTTP/1.0 定义了 Keep-Alive 首部（在 HTTP/1.1 中不复存在），可以用来调节持久连接的行为，譬如：")]),t._v(" "),a("div",{staticClass:"language-textile extra-class"},[a("pre",{pre:!0,attrs:{class:"language-textile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("Keep-Alive: timeout=10, max=500\n")])])])]),a("p",[t._v("说明如下：")]),t._v(" "),a("ul",[a("li",[t._v("参数 timeout 是在 response 首部里发送的，它估计了 server 持久连接保持活跃的时间，这并不是一个承诺值")]),t._v(" "),a("li",[t._v("参数 max 也是在 response 首部里发送的，它估计了 server 还希望为多少个事务保持此连接的活跃状态，这依然不是一个承诺值")])]),t._v(" "),a("p",[t._v("P.S: 注意区分 Keep-Alive 首部和上文的"),a("code",[t._v("Connection: Keep-Alive")]),t._v("首部，后者中的"),a("code",[t._v("Keep-Alive")]),t._v("是一个 field value，前者是一个 field name。")]),t._v(" "),a("p",[t._v("P.S: 显然，Keep-Alive 首部只有在提供"),a("code",[t._v("Connection: Keep-Alive")]),t._v("的情况下才有意义。")]),t._v(" "),a("p",[t._v("根据我的理解，Keep-Alive 首部在 HTTP/1.1 中没有使用的必要。")]),t._v(" "),a("h2",{attrs:{id:"cookie"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[t._v("#")]),t._v(" Cookie")]),t._v(" "),a("p",[t._v("Cookie 用于管理服务器和客户端之间的状态，它并没有被纳入到 HTTP/1.1 的 RFC2616 中，但其应用非常广泛。这一部分旨在整理 Cookie 相关知识，并尝试搞清楚它在移动客户端中的应用。")]),t._v(" "),a("h3",{attrs:{id:"cookie-相关协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie-相关协议"}},[t._v("#")]),t._v(" Cookie 相关协议")]),t._v(" "),a("p",[t._v("Cookie 最开始由网景公司于 1994 年为其浏览器开发，并制定了相关的规则标准，目前最为普及的 Cookie 方式也只是在此基础上建立的。后来陆陆续续又产生了一些 RFC：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("RFC")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("说明")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("a",{attrs:{href:"https://www.ietf.org/rfc/rfc2109.txt",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC2109"),a("OutboundLink")],1)]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("差不多淡出人们视线了")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("a",{attrs:{href:"https://www.ietf.org/rfc/rfc2965.txt",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC2965"),a("OutboundLink")],1)]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("诞生于 IE 和 Netscape 浏览器大战的年代，定义了新的 Set-Cookie2 和 Cookie2，事实上，几乎没怎么被使用")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("a",{attrs:{href:"https://www.ietf.org/rfc/rfc6265.txt",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC6265"),a("OutboundLink")],1)]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("将网景公司制定的标准作为业界事实标准，重新定义 Cookie 标准后的产物")])])])]),t._v(" "),a("p",[t._v("目前使用的最广泛的 Cookie 标准不是上述 RFC 中的任何一个...")]),t._v(" "),a("h3",{attrs:{id:"相关首部"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关首部"}},[t._v("#")]),t._v(" 相关首部")]),t._v(" "),a("p",[t._v("为 cookie 服务的常用首部字段有两个：")]),t._v(" "),a("ul",[a("li",[t._v("Set-Cookie，由 response 携带，指示 client 存储 cookie 到本地")]),t._v(" "),a("li",[t._v("Cookie，由 request 携带，将本地 cookie 传给 server")])]),t._v(" "),a("p",[t._v("P.S: 这两个首部没有在 HTTP/1.1 中定义。")]),t._v(" "),a("p",[a("strong",[t._v("Set-Cookie 首部")])]),t._v(" "),a("p",[t._v("Set-Cookie 字段包括好些属性，如下是说明：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("属性")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("说明")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("版本")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("举例")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("Expires")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("到期时间，若不指定，则浏览器关闭时即删除")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("网景、RFC6265")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("Domain")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("cookie 适用的域名，若不指定，则默认为创建 cookie 的服务器的域名")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("网景、RFC2965、RFC6265")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("Path")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("cookie 适用的 path")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("网景、RFC2965、RFC6265")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("Secure")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("指示客户端仅当在 HTTPS 请求时才发送 Cookie")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("网景、RFC2965、RFC6265")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("Set-Cookie: id=42; secure")]),t._v("意味着，告诉客户端只对 HTTPS 请求发送 cookie")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("HttpOnly")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("加以限制，使得 cookie 不能被 JavaScript 脚本访问")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("RFC6265")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("防止跨站脚本攻击（Cross-site scripting，XSS）")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("Version")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("必选，Set-Cookies2 使用")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("RFC2965")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("Comment")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("说明 server 将如何使用这个 cookie")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("RFC2965")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("CommentURL")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("更加详细说明 server 如何使用这个 cookie 的 url")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("RFC2965")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("Discard")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("如果提供了这个属性，客户端在程序终止时，需删除 cookie")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("RFC2965")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("Max-Age")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("和 Expires 作用类似")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("RFC2965、RFC6265")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("Port")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("cookie 适用的端口")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("RFC2965")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}})])])]),t._v(" "),a("p",[t._v("前五个属性是目前使用最广泛的。")]),t._v(" "),a("p",[t._v("《HTTP 权威指南》将 cookie 笼统分为了两种类型：会话 cookie、持久 cookie。前者是一种临时 cookie，应用程序退出时，会话 cookie 就被删除了。持久 cookie 的生存时间更长一些，它们存储在硬盘上，应用程序退出时，仍然会保留它们。简单来说，当设置了 Discard，或者没有设置 Expires 或 Max-Age，就意味着这个 cookie 是一个会话 cookie。")]),t._v(" "),a("p",[a("strong",[t._v("Cookie 首部")])]),t._v(" "),a("p",[t._v("Cookie 首部比较简单，用于将本地 cookie 传给 server，没啥好说的。")]),t._v(" "),a("h3",{attrs:{id:"ios-与-cookie"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ios-与-cookie"}},[t._v("#")]),t._v(" iOS 与 Cookie")]),t._v(" "),a("p",[t._v("作为 iOS 开发者，我比较关心 iOS 中与 Cookie 相关的资源。iOS 里有两个与 HTTP cookie 相关的类型：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("NSHTTPCookie")]),t._v("，用于封装 cookie，它的属性覆盖了上文表格中"),a("code",[t._v("Set-Cookie")]),t._v("的每一个属性")]),t._v(" "),a("li",[a("code",[t._v("NSHTTPCookieStorage")]),t._v("，单例类，提供了管理所有"),a("code",[t._v("NSHTTPCookie")]),t._v("对象的接口，在 OS X 里，cookie 是在所有程序中共享的，而在 iOS 中，cookie 只当当前应用中有效")])]),t._v(" "),a("h2",{attrs:{id:"实体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实体"}},[t._v("#")]),t._v(" 实体")]),t._v(" "),a("p",[t._v("实体（entity）包括实体首部（entity-header）和实体主体（entity-body）：")]),t._v(" "),a("e-img",{attrs:{src:"/image/entity-body@2x.png"}}),t._v(" "),a("p",[t._v("实体首部和实体主体之间被一个空白行（CRLF）分隔。")]),t._v(" "),a("p",[t._v("P.S: CR（0d，\\r）LF（0a，\\n）。")]),t._v(" "),a("h3",{attrs:{id:"划定报文结束"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#划定报文结束"}},[t._v("#")]),t._v(" 划定报文结束")]),t._v(" "),a("p",[t._v("HTTP 1.1 与之前版本，划定报文结束的逻辑处理时不一样的。")]),t._v(" "),a("p",[t._v("早期版本（1.1 之前版本），采用关闭连接的办法来划定报文的结束。即便这样，如果没有 Content-Length 首部，client 无法区分到底是报文结束时正常的连接关闭，还是报文传输中由于 server 出差错而导致的关闭，因此 Content-Length 还是非常必要的。")]),t._v(" "),a("p",[t._v("对于 1.1 版本，由于 HTTP 默认为持久连接，无法再根据 TCP 报文来判断 body 传输完毕...")]),t._v(" "),a("h3",{attrs:{id:"实体首部字段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实体首部字段"}},[t._v("#")]),t._v(" 实体首部字段")]),t._v(" "),a("p",[t._v("实体首部还蛮多，如下表：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("首部")]),t._v(" "),a("th",[t._v("说明")]),t._v(" "),a("th",[t._v("例子")]),t._v(" "),a("th",[t._v("报文类型")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Allow")]),t._v(" "),a("td",[t._v("通知 client 所支持的 request 方法类型（GET、POST）")]),t._v(" "),a("td",[t._v("Allow: GET, HEAD")]),t._v(" "),a("td",[t._v("Response")])]),t._v(" "),a("tr",[a("td",[t._v("Content-Type")]),t._v(" "),a("td",[t._v("实体中所承载对象的类型")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Response")])]),t._v(" "),a("tr",[a("td",[t._v("Content-Length")]),t._v(" "),a("td",[t._v("如果有压缩，该值记录的是压缩后的大小（单位是字节），而不是原始大小；除非使用分块编码，否则该字段是带有实体的报文必须要使用的。")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Response")])]),t._v(" "),a("tr",[a("td",[t._v("Content-Language")]),t._v(" "),a("td",[t._v("与所传送对象最相匹配的人类语言")]),t._v(" "),a("td",[t._v("Content-Language: zh-CN")]),t._v(" "),a("td",[t._v("Response")])]),t._v(" "),a("tr",[a("td",[t._v("Content-Encoding")]),t._v(" "),a("td",[t._v("通知 client 对 entity-body 所使用的内容编码方式，主要有 4 种：gzip、compress、deflate、identity（没有编码）")]),t._v(" "),a("td",[t._v("Content-Encoding: gzip")]),t._v(" "),a("td",[t._v("Response")])]),t._v(" "),a("tr",[a("td",[t._v("Content-Location")]),t._v(" "),a("td",[t._v("给出与 entity-body 相对应的 URI，表明该 entity-body 取自何处")]),t._v(" "),a("td",[t._v("Content-Location: http://www.example.com")]),t._v(" "),a("td",[t._v("Response")])]),t._v(" "),a("tr",[a("td",[t._v("Content-MD5")]),t._v(" "),a("td",[t._v("对 entity-body 的校验和，客户端会对接收的 entity-body 执行相同的 MD5 算法，然后与该字段值进行比较")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Response")])]),t._v(" "),a("tr",[a("td",[t._v("Content-Range")]),t._v(" "),a("td",[t._v("如果这是个部分 entity，该首部说明它是整体的哪个部分")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Response")])]),t._v(" "),a("tr",[a("td",[t._v("Expires")]),t._v(" "),a("td",[t._v("指定资源失效的时间")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Response")])]),t._v(" "),a("tr",[a("td",[t._v("Last-Modified")]),t._v(" "),a("td",[t._v("指定资源最终被修改的时间")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("Response")])])])]),t._v(" "),a("h2",{attrs:{id:"内容编码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内容编码"}},[t._v("#")]),t._v(" 内容编码")]),t._v(" "),a("p",[t._v("内容编码（Content Encoding）通常用于对实体内容进行压缩编码，目的是优化传输，例如用 gzip 压缩文本文件，能大幅减小体积。内容编码通常是选择性的，例如 jpg/ png 这类文件一般不开启，因为图片格式已经是高度压缩过的，再压一遍没什么效果不说还浪费 CPU。")]),t._v(" "),a("p",[t._v("关于它，没啥好说的...")]),t._v(" "),a("h2",{attrs:{id:"传输编码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传输编码"}},[t._v("#")]),t._v(" 传输编码")]),t._v(" "),a("p",[t._v("曾一度弄不清楚内容编码和传输编码的区别，《图解 HTTP》这本书似乎也没讲清楚这个问题。再次翻看《HTTP 权威指南》才恍惚搞懂是怎么回事儿。")]),t._v(" "),a("p",[t._v("除了《HTTP 权威指南》，博客"),a("a",{attrs:{href:"https://imququ.com/post/transfer-encoding-header-in-http.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP 协议中的 Transfer-Encoding"),a("OutboundLink")],1),t._v("也很清晰解释了何为传输编码，参考它们就好了，本文就不再对这个概念进行赘述。")]),t._v(" "),a("h3",{attrs:{id:"传输编码相关首部"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传输编码相关首部"}},[t._v("#")]),t._v(" 传输编码相关首部")]),t._v(" "),a("p",[t._v("与传输编码相关的首部有两个：")]),t._v(" "),a("p",[a("strong",[t._v("Transfer-Encoding")])]),t._v(" "),a("p",[t._v("该首部用于指定传输编码的编码方式，在 1.1 版本之前，HTTP 支持多种传输编码方式，但在 1.1 版本中，只支持一种传输编码方式 -- 分块传输编码，即"),a("code",[t._v("Transfer-Encoding")]),t._v("只能指定首部值"),a("code",[t._v("chunked")]),t._v("，即"),a("code",[t._v("Transfer-Encoding: chunked")]),t._v("。")]),t._v(" "),a("p",[t._v("该首部一般在 server 发给的 client 的 response 报文中出现，告诉 client 已经对 body 进行了分块传输编码。")]),t._v(" "),a("p",[a("strong",[t._v("TE")])]),t._v(" "),a("p",[t._v("Server 怎么知道它发送的分块编码报文是否能被 client 接受呢？"),a("code",[t._v("TE")]),t._v("首部正是用于解决这个问题，它用在 request 报文中，告知 server 可以使用哪些传输编码（当然，一般只有值"),a("code",[t._v("chunked")]),t._v("），譬如"),a("code",[t._v("TE: chunked")]),t._v("。")]),t._v(" "),a("p",[t._v("P.S: "),a("code",[t._v("TE")]),t._v("首部还可以挂上"),a("code",[t._v("trailers")]),t._v("参数，下文会提到。")]),t._v(" "),a("h3",{attrs:{id:"传输编码的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传输编码的作用"}},[t._v("#")]),t._v(" 传输编码的作用")]),t._v(" "),a("p",[t._v("传输编码的意义有哪些呢？《HTTP 权威指南》总结了两点：")]),t._v(" "),a("ul",[a("li",[t._v("处理未知尺寸的报文。这是本文阐述的重点，详见下文的分块传输编码部分")]),t._v(" "),a("li",[t._v("提高安全性，可以用传输编码把报文扰乱，然后在共享网络上传输；不过，由于 SSL/TLS 这种传输层安全体系的流行，很少要靠传输编码来处理安全性事务了")])]),t._v(" "),a("p",[t._v("对于第二点 "),a("em",[t._v("提高安全性")]),t._v(" ，我还不咋理解，如何通过传输编码提高安全性？暂且搁下吧，若有需要，以后再补充...")]),t._v(" "),a("h3",{attrs:{id:"分块编码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分块编码"}},[t._v("#")]),t._v(" 分块编码")]),t._v(" "),a("p",[t._v("对于分块编码，《HTTP 权威指南》的描述是：分块编码把报文分割为若干个大小已知的块。")]),t._v(" "),a("p",[t._v("我刚开始以为分块编码是把一个 HTTP 报文拆分为多个报文，后来发现完全理解错了。")]),t._v(" "),a("h3",{attrs:{id:"分块编码与持久连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分块编码与持久连接"}},[t._v("#")]),t._v(" 分块编码与持久连接")]),t._v(" "),a("p",[t._v("如上文所述，刚开始，我以为分块编码是把一个 HTTP 报文拆分为多个报文，若果真如此，那么持久连接显然是分块编码的先决条件...")]),t._v(" "),a("p",[t._v("在非持久连接中，client 无需知道它正在读取的 body 的长度，只需读到 server 关闭连接为止，Content-Length 于 client 而言没那么必要。但一旦 HTTP 支持持久连接后，就不能再以连接关闭作为 body 读取完毕的哨兵事件了，因此非常依赖 server 提供的 Content-Length 首部。")]),t._v(" "),a("p",[t._v("有时候，server 提供 Content-Length 是一件非常吃力的事情，借用"),a("a",{attrs:{href:"https://imququ.com/post/transfer-encoding-header-in-http.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP 协议中的 Transfer-Encoding"),a("OutboundLink")],1),t._v("的举例说明：")]),t._v(" "),a("blockquote",[a("p",[t._v("例如实体来自于网络文件，或者由动态语言生成。这时候要想准确获取长度，只能开一个足够大的 buffer，等内容全部生成好再计算。但这样做一方面需要更大的内存开销，另一方面也会让客户端等更久。")])]),t._v(" "),a("p",[t._v("分块编码就是为了解决这种困难而生的。它允许 server 把 body 逐块发送，说明每个 block 的大小即可。因为 body 是动态创建的，server 可以缓冲它的一部分，发送 block 及相应的 size 说明，然后在 body 发送完之前重复这个过程，最后，server 用大小为 0 的 block 作为 body 结束的信号，这样就可以继续保持连接，为下一个 response 做准备了。")]),t._v(" "),a("p",[t._v("再次说明，这些过程仍然是在一个 message 上进行的，并没有将 message 拆分为多个。")]),t._v(" "),a("h3",{attrs:{id:"分块编码报文的基本结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分块编码报文的基本结构"}},[t._v("#")]),t._v(" 分块编码报文的基本结构")]),t._v(" "),a("p",[t._v("分块编码报文的基本结构非常简单，和普通的 HTTP 报文差距仅在于 body 部分。body 部分由各个 block 组成，某个 block 包含一个长度值和该 block 的数据，长度值和 block 数据使用 CRLF 分隔开，长度值是十六进制形式，block 数据大小以字节计。最后一个 block 有些特别，它的长度值为 0，无数据部分，表示 body 结束。如下图所示：")]),t._v(" "),a("e-img",{attrs:{src:"/image/transfor-encoding-trunk@2x.png"}}),t._v(" "),a("h3",{attrs:{id:"分块报文的拖挂"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分块报文的拖挂"}},[t._v("#")]),t._v(" 分块报文的拖挂")]),t._v(" "),a("p",[t._v("如上图所示，在最后一个 block 后面还有一个拖挂（trailer），这个名字挺怪的；我的理解，server 可以在分块报文的末尾加上可选元数据，数据格式 HTTP 不作要求。")]),t._v(" "),a("p",[t._v("上图的拖挂是"),a("code",[t._v("Content-MD5")]),t._v("首部，只是因为"),a("code",[t._v("Content-MD5")]),t._v("只有在 body 全部生成完了才能计算，所以把它放在 trailer 里是合适的选择。")]),t._v(" "),a("p",[t._v("对于 client 来说，它可以对 trailer 不做任何处理；对于 server 而言，它如何知道 client 是否会处理 trailer 呢？如果不处理，硬塞一个 trailer 岂不浪费？HTTP 的 TE 首部解决了这个问题，TE 首部除了告诉 server 它接受的传输编码方式之外，它还可以指定 trailers 属性，以告诉 server 它可以处理分块报文中携带的拖挂，譬如："),a("code",[t._v("TE: trailers")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"q-a"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#q-a"}},[t._v("#")]),t._v(" Q & A")]),t._v(" "),a("p",[t._v("这部分以 Q & A 的形式补充对 HTTP 基本概念的理解。")]),t._v(" "),a("h3",{attrs:{id:"如何在-http-消息中指定-url"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何在-http-消息中指定-url"}},[t._v("#")]),t._v(" 如何在 HTTP 消息中指定 URL")]),t._v(" "),a("p",[t._v("HTTP 基于 URL 定位网络资源，有多种方式指定 URL。")]),t._v(" "),a("p",[t._v("请求行（Request-Line）的格式如下：")]),t._v(" "),a("div",{staticClass:"language-textile extra-class"},[a("pre",{pre:!0,attrs:{class:"language-textile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("Request"),a("span",{pre:!0,attrs:{class:"token inline"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token deleted"}},[t._v("Line = Method SP Request")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")])]),t._v("URL SP HTTP-Version CRLF\n;\n; SP表示“分隔符”\n; CRLF表示“结束符”\n")])])])]),a("p",[t._v("显然，可以在 Request-Line 中指定 URL，譬如这样：")]),t._v(" "),a("div",{staticClass:"language-textile extra-class"},[a("pre",{pre:!0,attrs:{class:"language-textile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("; 请求行\nGET http://example.com/index.html HTTP/1.1\n")])])])]),a("p",[t._v("也可以这样：")]),t._v(" "),a("div",{staticClass:"language-textile extra-class"},[a("pre",{pre:!0,attrs:{class:"language-textile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token phrase"}},[t._v("; 请求行\nGET /index.html HTTP/1.1\n; 首部字段Host中写明网络域名或IP地址\nHost: example.com\n")])])])]),a("h3",{attrs:{id:"get-请求可以携带消息主体吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-请求可以携带消息主体吗"}},[t._v("#")]),t._v(" GET 请求可以携带消息主体吗")]),t._v(" "),a("p",[t._v("据我所知，RFC 文档没有明确表明 GET 请求不能携带 message-body，综合各种说法，我的判断是：有些 server 不处理 GET 的 message-body 信息，有些 server 会处理。总之，与具体的实现有关。")]),t._v(" "),a("p",[t._v("参考：")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"http://stackoverflow.com/questions/978061/http-get-with-request-body",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://stackoverflow.com/questions/978061/http-get-with-request-body"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"http://stackoverflow.com/questions/5216567/is-this-statement-correct-http-get-method-always-has-no-message-body",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://stackoverflow.com/questions/5216567/is-this-statement-correct-http-get-method-always-has-no-message-body"),a("OutboundLink")],1)])]),t._v(" "),a("h3",{attrs:{id:"client-可以发送分块编码的报文给-server-吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#client-可以发送分块编码的报文给-server-吗"}},[t._v("#")]),t._v(" Client 可以发送分块编码的报文给 server 吗")]),t._v(" "),a("p",[t._v("Client 也可以发送分块的数据给 server。只是，client 事先不知道 server 是否接受分块编码（这是因为 server 不会在给 client 响应中发送 TE 首部），所以 server 必须做好 server 用 411 Length Required（需要 Content-Length 首部）响应来拒绝分块请求的准备。")])],1)}),[],!1,null,null,null);e.default=r.exports}}]);